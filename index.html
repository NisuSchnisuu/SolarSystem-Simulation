<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Sonnensystem-Simulation (6. Klasse) - Realistische Bahnen & Saturnschatten</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <style>
        html {
            height: 100%;
            height: 100dvh;
            width: 100%;
            margin: 0;
        }
        body {
            height: 100%;
            height: 100dvh;
            width: 100%;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            overscroll-behavior: none;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
	}

        #ui-container {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.75);
            padding: 15px;
            border-radius: 12px;
            max-width: 320px;
            width: calc(100% - 40px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 85dvh;
            max-height: calc(100dvh - 20px - env(safe-area-inset-bottom));
            
            /*  Flex-Layout f√ºr die Stapelung  */
            display: flex;
            flex-direction: column;
            
            /*  GE√ÑNDERT: Scrollen wird an Kind-Element √ºbergeben  */
            overflow-y: hidden; /* ALT: auto */
            
            transition: max-width 0.3s ease, padding 0.3s ease;
            z-index: 1000;

            /*  GE√ÑNDERT: Bottom-Padding wird an Scroll-Element √ºbergeben  */
            padding-bottom: 15px; /* ALT: 120px */
        }

        /* Der fixe Header-Bereich */
        #ui-fixed-header {
            flex-shrink: 0; /* Verhindert, dass dieser Bereich schrumpft */
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 2px solid #777; /* KORREKTUR: Klarere Trennlinie */
        }

        /* Der scrollbare Inhalts-Bereich */
        #ui-scrollable-content {
            flex-grow: 1; /* Nimmt den restlichen Platz ein */
            overflow-y: auto; /* NUR dieser Bereich scrollt */
            padding-bottom: 30px; /* Das alte Padding f√ºr das Scroll-Ende */
            
            /* Optional: Scrollbar-Styling f√ºr bessere Optik */
            scrollbar-width: thin;
            scrollbar-color: #555 #333;
            -webkit-overflow-scrolling: touch;
        }

        /*  FIX: Versteckt Header & Inhalt komplett, wenn minimiert  */
        #ui-container.minimized #ui-fixed-header,
        #ui-container.minimized #ui-scrollable-content,
        #ui-container.minimized #scroll-indicator { /* Dazu kommen wir gleich */
            display: none !important;
            border: none;
        }



        #toggle-ui {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
        }
        #toggle-ui:hover {
            background: rgba(255,255,255,0.1);
        }

        #ui-container.minimized {
            max-width: 50px; 
            padding: 10px;
            overflow: hidden;
            height: 30px; 
        }
        #ui-container.minimized .control-group {
            display: none;
        }
        #ui-container.minimized #toggle-ui {
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             border: none;
        }

        .control-group {
            margin-bottom: 15px;
        }
        #ui-scrollable-content .control-group:first-of-type {
            margin-top: 0;
        }

        .control-group h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 10px 0;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        #fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            
            /* √ÑNDERUNG: Transparent und kein Rahmen */
            background: transparent;
            border: none;
            
            /* WICHTIG: Wir behalten eine "unsichtbare" Gr√∂√üe von 44x44px 
               damit man den Knopf auf dem iPad gut mit dem Finger trifft */
            width: 44px; 
            height: 44px;
            padding: 0;

            /* Flexbox zum Zentrieren des Icons in der unsichtbaren Box */
            display: flex;
            align-items: center;
            justify-content: center;
            
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        #fullscreen-btn:hover {
            /* Beim Dr√ºberfahren nur gr√∂√üer werden, kein Hintergrund */
            transform: scale(1.2);
        }
        
        /* Style f√ºr das SVG Icon */
        #fullscreen-btn svg {
            width: 30px;  /* Etwas gr√∂√üer, da kein Rahmen mehr da ist */
            height: 30px;
            fill: #ffffff70;   /* Icon-Farbe Wei√ü */
            
            /* WICHTIG: Ein Schlagschatten, damit man das wei√üe Icon 
               auch sieht, wenn es √ºber der hellen Sonne liegt */
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.8));
        }
        
        /* Greift nur auf Ger√§ten mit Touchscreen (keine Maus) -> iPad/Tablet */
        @media (hover: none) and (pointer: coarse) {
            
            /* Nur wenn JavaScript die Klasse 'is-fullscreen' gesetzt hat 
               UND das Men√º minimiert ist */
            body.is-fullscreen #ui-container.minimized {
                top: 60px !important; /* Schiebt das Men√º unter den Apple-Button */
                transition: top 0.3s ease; /* Macht die Bewegung fl√ºssig */
            }
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: 500;
        }

        .btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease; 
        }

        .btn:hover {
            background-color: #0056b3;
        }
        
        .btn:active {
            transform: scale(0.98);
        }

        #play-pause-btn.playing {
            background-color: #28a745; 
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5); 
        }
        #play-pause-btn.playing:hover {
            background-color: #218838;
        }
        
        /*  Style f√ºr Zur√ºckspul-Button  */
        #rewind-btn.playing {
            background-color: #007bff; 
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
        }
        #rewind-btn.playing:hover {
            background-color: #0056b3;
        }

        #play-pause-btn {
            /* Flexbox sorgt daf√ºr, dass das Icon perfekt mittig ist */
            display: flex;
            align-items: center;
            justify-content: center;
            
            /* Verhindert, dass der Button springt, wenn sich das Icon √§ndert */
            min-width: 44px; 
            padding: 8px 12px;
        }

        /* Style f√ºr das SVG im Button */
        #play-pause-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor; /* WICHTIG: Nimmt die Textfarbe (Weiss) an */
            pointer-events: none; /* Klicks gehen durch das Icon auf den Button */
        }

        #rewind-btn {
            /* Flexbox sorgt f√ºr perfekte Zentrierung */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            
            /* Optional: Padding leicht anpassen, falls der Button zu breit/hoch wirkt */
            padding: 8px 12px; 
        }

        #rewind-btn svg {
            width: 18px; /* Angenehme Gr√∂√üe im Verh√§ltnis zum Text daneben */
            height: 18px;
            fill: currentColor; /* WICHTIG: Nimmt die Textfarbe (Wei√ü) an */
            pointer-events: none; /* Klicks gehen durch das Icon auf den Button */
        }
        /*  --------   */


        .btn-secondary {
            background-color: #4a4a4a;
        }
        .btn-secondary:hover {
            background-color: #666;
        }

        .btn-focus {
            background-color: #388e3c; 
            color: white;
        }
        .btn-focus:hover {
            background-color: #4caf50; 
        }

        .btn-planet {
            background-color: #d87c1c; 
            color: white;
            font-size: 12px !important; 
            padding: 6px 8px !important;
        }
        .btn-planet:hover {
            background-color: #e69545; 
        }

        .btn-moon {
            background-color: #6f42c1; 
            color: white;
            font-size: 11px !important; 
            padding: 4px 8px !important;
        }
        .btn-moon:hover {
            background-color: #59359a;
        }
        
        .btn-warning {
            background-color: #ffc107;
            color: #000;
        }
        .btn-warning:hover {
            background-color: #e0a800;
        }
        
        .btn-danger { 
            background-color: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-info { 
            background-color: #00ffff;
            color: #000;
            font-weight: 700;
            z-index: 500;
        }
        .btn-info:hover {
            background-color: #00aaaa;
            color: #fff;
        }

        .btn-pulse {
            animation: pulse-animation 2s infinite;
        }
        @keyframes pulse-animation {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0); }
        }

        .btn-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .btn-group button {
            flex-grow: 1;
            font-size: 12px;
            padding: 6px 8px;
        }
        
        /*  Style f√ºr Frequenz-Button  */
        #demo-freq {
            width: 100%;
            margin-bottom: 5px;
            font-size: 13px;
        }

        /* NEU: 4x2 Raster f√ºr die Planeten-Buttons */
        #planet-focus-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4 Spalten mit gleicher Breite */
            gap: 5px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }
        
        /* Damit die Buttons im Grid die volle H√∂he/Breite f√ºllen */
        #planet-focus-buttons button {
            width: 100%;
            margin: 0;
        }

        #moon-focus-container {
            display: none; 
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px dashed #555;
            animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        
        #info-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            margin-top: 10px;
            min-height: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        
        #moon-phases-ui {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }
        
        #moon-phases-ui button {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 5px;
            height: 42px; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            line-height: 1;
        }
        
        #moon-phases-ui button:hover {
            background: #444;
        }
        
        #moon-phases-ui button.active {
            background: #4A4A4A; 
            border-color: #ffc107; 
            font-weight: bold;
            box-shadow: 0 0 8px 1px rgba(255, 193, 7, 0.7); 
        }

        #demo-speed-control {
            display: none; 
            margin-top: 10px;
        }

        #info-popup {
            display: none; 
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 990; 
            width: 90%;
            max-width: 400px;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        #info-popup-content {
            width: 100%;
            text-align: left;
        }
        #popup-title {
            margin: 0 0 15px 0;
            font-size: 20px;
            font-weight: 600;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            text-align: center;
            color: #ffc107; 
        }
        #popup-details p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        #popup-details strong {
            color: #fff; 
            font-weight: 600;
            min-width: 140px; 
            display: inline-block;
        }
        #popup-details span {
            color: #ddd;
        }
        #popup-details .fun-fact {
            margin-top: 8px; 
            padding-top: 0; 
            border-top: none; 
            font-style: italic;
            color: #ccc;
        }

        #info-toast-button {
            display: none; 
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 980; 
            background-color: #00ffff;
            color: #000;
            border: 2px solid #000;
            box-shadow: 0 4px 10px rgba(0, 255, 255, 0.3);
            font-size: 14px;
            font-weight: 700;
            font-family: "Courier New", monospace;
            padding: 10px 15px;
        }

        /*  UFO Dialog Styles  */
        #ufo-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 0, 0.95); 
            color: #0f0; 
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
            border: 2px solid #0f0;
            z-index: 991;
            width: 80%;
            max-width: 350px;
            font-family: "Courier New", monospace;
            text-align: center;
        }
        #ufo-dialog h3 {
            margin-top: 0;
            color: #0f0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #ufo-dialog-text {
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
        }
        .ufo-btn-group {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .ufo-btn {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            cursor: pointer;
            font-family: "Courier New", monospace;
            font-weight: bold;
            transition: all 0.2s;
        }
        .ufo-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 15px rgba(31, 152, 31, 0.8);
        }

        /* Styling f√ºr das Alien-Bild */
        #ufo-alien-image {
            width: 100%;          /* Nutze die volle Breite des Dialogs */
            max-width: 150px;     /* Aber nicht breiter als 150px (damit es nicht riesig wird) */
            height: auto;         /* H√∂he passt sich automatisch an */
            border-radius: 8px;   /* Abgerundete Ecken */
            margin-bottom: 15px;  /* Abstand zum Text darunter */
            border: 2px solid #0f0; /* Gr√ºner Rahmen passend zum Theme */
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3); /* Leichter Glow-Effekt */
            
            /* Optional: Animation beim Erscheinen */
            animation: alien-pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes alien-pop {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /*  REALIT√ÑTSCHECK STYLES  */
        hr.separator {
            width: 100%;
            border: 0;
            border-top: 1px dashed #555;
            margin: 5px 0;
        }

        #real-scale-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #555;
        }

        #real-scale-controls #planet-focus-buttons { order: 1; }
        #real-scale-controls #real-scale-sep1 { order: 2; }
        #real-scale-controls #real-dist-btn { order: 3; }
        #real-scale-controls #real-scale-sep2 { order: 4; }
        #real-scale-controls #real-scale-btn { order: 5; }

        #distance-label {
            display: none; 
            position: absolute;
            top: 0;
            left: 0;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-weight: 700;
            font-size: 16px;
            white-space: nowrap;
            pointer-events: none; 
            text-shadow: 
                -1px -1px 2px #000,  
                 1px -1px 2px #000,
                -1px  1px 2px #000,
                 1px  1px 2px #000; 
            z-index: 500; 
        }

        /*  Jahreszeiten-Button-Stile  */
        .btn-spring {
            background-color: #66BB6A; /* Gr√ºn */
            color: white;
        }
        .btn-spring:hover {
            background-color: #4CAF50;
        }
        .btn-summer {
            background-color: #FFA726; /* Hellorange */
            color: #000;
        }
        .btn-summer:hover {
            background-color: #FB8C00;
        }
        .btn-autumn {
            background-color: #8D6E63; /* Braun */
            color: white;
        }
        .btn-autumn:hover {
            background-color: #6D4C41;
        }
        .btn-winter {
            background-color: #E0E0E0; /* Weiss/Hellgrau */
            color: #000;
        }
        .btn-winter:hover {
            background-color: #BDBDBD;
        }
        
        /*  Indikator f√ºr aktive Kn√∂pfe  */
        .btn-focus.active,
        .btn-spring.active,
        .btn-summer.active,
        .btn-autumn.active,
        .btn-winter.active,
        .btn-planet.active,
        .btn-moon.active {
            border: 2px solid #ffc107 !important; /* !important to override default borders */
            box-shadow: 0 0 8px 1px rgba(255, 193, 7, 0.7);
        }
        /*  Ende   */
        /*  Touch-Freundliche Slider  */

        /* 1. Basis-Styling & Hitbox vergr√∂ssern */
        input[type="range"] {
            -webkit-appearance: none; /* Standard-Look entfernen (f√ºr Chrome/Safari) */
            appearance: none;         /* Standard-Look entfernen (allgemein) */
            width: 100%;
            height: 24px;             /* ‚ùó WICHTIG: Erh√∂ht die "Tap-Fl√§che" */
            background: transparent;  /* Eigenen Track-Style definieren wir unten */
            cursor: pointer;
            margin: 8px 0;            /* Etwas mehr vertikaler Abstand */
        }

        /* 2. Fokus-Stil entfernen (optional, aber sauberer) */
        input[type="range"]:focus {
            outline: none;
        }


        /* 3. Die LEISTE (Track) stylen */

        /* WebKit (Chrome, Safari, iOS, Android) */
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: #4a4a4a;
            border-radius: 3px;
            border: 1px solid #333;
        }

        /* Firefox */
        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            background: #4a4a4a;
            border-radius: 3px;
            border: 1px solid #333;
        }


        /* 4. Den DAUMEN (Thumb) stylen - Der wichtigste Teil! */

        /* WebKit (Chrome, Safari, iOS, Android) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            
            height: 30px;  /* ‚ùó Gr√∂sserer Kreis */
            width: 30px;   /* ‚ùó Gr√∂sserer Kreis */
            border-radius: 50%;
            background: #007bff; /* Deine Button-Farbe */
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            
            /* Wichtig: Vertikal zentrieren */
            margin-top: -12px; /* (Track-H√∂he - Daumen-H√∂he) / 2 ... plus R√§nder */ 
        }

        /* Firefox */
        input[type="range"]::-moz-range-thumb {
            height: 20px;  /* ‚ùó Gr√∂sserer Kreis (FF rechnet etwas anders) */
            width: 20px;   /* ‚ùó Gr√∂sserer Kreis */
            border-radius: 50%;
            background: #007bff;
            border: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            
            /* Bei FF ist kein margin-top n√∂tig, wenn die Basis `height` stimmt */
        }

        /* Optional: Ein "Glow"-Effekt, wenn der Slider aktiv ist */
        input[type="range"]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.8);
        }
        input[type="range"]:focus::-moz-range-thumb {
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.8);
        }

        /*  Ende Touch-Freundliche Slider  */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/ImagesGit/loading_screen.webp');
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999; /* √úber allem anderen */
            transition: opacity 0.5s ease-out; /* F√ºr sanftes Ausblenden */
            color: #fff;
            position: relative;
            flex-grow: 1;
        }

        #loading-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Passe die Deckkraft (0.6 = 60%) an, wie es dir gef√§llt */
            background-color: rgba(0, 0, 0, 0.6); 
            z-index: 1; /* Liegt zwischen Hintergrundbild und Inhalt */
        }

        #loading-screen p {
            font-size: 18px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", sans-serif;
            margin-top: 20px;
            margin-bottom: 0;
            position: relative;
            z-index: 2;
        }

        /* Simpler CSS-Spinner */
        

        /*  Ladebalken-Stile  */
        #progress-bar-container {
            width: 80%; /* Breite des Balkens */
            max-width: 300px;
            height: 10px; /* H√∂he des Balkens */
            background-color: #333; /* Hintergrundfarbe (leerer Balken) */
            border: 1px solid #555;
            border-radius: 5px;
            overflow: hidden; /* Stellt sicher, dass der innere Balken abgerundet ist */
            margin-top: 15px; /* Abstand zum Text */
            position: relative;
            z-index: 2;
        }

        #progress-bar {
            width: 0%; /* Startet bei 0% */
            height: 100%;
            background-color: #00ffff; /* F√ºllfarbe (deine Akzentfarbe) */
            border-radius: 5px;
            transition: width 0.3s ease-out; /* F√ºr sanften Fortschritt */
        }

        /* 1. Styles f√ºr den Pfeil */
        #scroll-indicator {
            position: absolute;
            bottom: 0px;
            left: 50%;
            /* Staucht das Dreieck flacher/k√ºrzer */
            transform: translateX(-50%) scaleY(0.6); 
            
            font-size: 20px; 
            font-weight: 900; 
            
            /* Weiss mit 50% Transparenz */
            color: rgba(255, 255, 255, 0.5); 
            
            text-shadow: none; 
            
            
            
            pointer-events: none; 
            transition: opacity 0.3s;
            z-index: 1001;
            display: none; 
        }

        /* --- RAKETEN HUD STYLES --- */
        #launch-hud {
            display: none; /* Standardm√§√üig unsichtbar */
            position: fixed;
            top: 30px;           /* Abstand von oben */
            left: 50%;
            transform: translateX(-50%);
            
            background: rgba(0, 20, 40, 0.85); /* Dunkelblau/Schwarz transparent */
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            
            border-radius: 8px;
            padding: 10px 20px;
            min-width: 280px;
            
            /* Flexbox f√ºr Icon + Text nebeneinander */
            
            align-items: center;
            gap: 15px;
            
            z-index: 2000; /* √úber allem anderen */
            font-family: "Courier New", monospace; /* Technischer Look */
            transition: opacity 0.3s ease;
        }

        /* Das Icon links */
        #hud-icon {
            font-size: 32px;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.5));
        }

        #hud-content {
            flex-grow: 1;
            text-align: left;
        }

        #hud-title {
            font-size: 16px;
            font-weight: bold;
            color: #00ffff; /* Cyan */
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 2px;
        }

        #hud-sub {
            font-size: 13px;
            color: #cccccc;
        }

        /* Animierter Balken unten am Fenster */
        #hud-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: #00ffff;
            width: 0%; /* Wird per JS animiert */
            transition: width 0.2s linear;
            box-shadow: 0 0 10px #00ffff;
        }

        /* Animation f√ºrs Einblenden */
        @keyframes hud-pop {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        
        .hud-visible {
            display: flex !important;
            animation: hud-pop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* 2. WICHTIG: Versteckt Pfeil, Header & Inhalt wenn minimiert (l√∂st auch dein Trennstrich-Problem) */
        #ui-container.minimized #ui-fixed-header,
        #ui-container.minimized #ui-scrollable-content,
        #ui-container.minimized #scroll-indicator {
            display: none !important;
            border: none;
        }


    </style>
</head>
<body>
    <div id="loading-screen">
        <p id="loading-text">Laden...</p>
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
    </div>

    <div id="container"></div>

    <div id="distance-label">0 Mio. km</div>

    <div id="ui-container">
        <button id="fullscreen-btn" title="Vollbild umschalten"></button>
        <button id="toggle-ui" class="btn btn-secondary" title="Men√º verbergen">‚úï</button>

        <div id="ui-fixed-header">
            <div class="control-group" style="margin-top: 25px; margin-bottom: 0;"> <h3>Steuerung</h3>
                <div class="btn-group" style="margin-bottom: 15px;" id="play-group">
                    <button id="rewind-btn" class="btn btn-secondary" title="Zur√ºckspulen"></button>
                    <button id="play-pause-btn" class="btn">Pause</button>
                </div>
                
                <div id="time-controls">
                    <label for="day-slider">Zeitsteuerung (1. Jahr): <span id="current-day-label" style="font-weight: bold; color: #ffc107;">0.0</span></label>
                    <input type="range" id="day-slider" min="0" max="365" value="0" step="0.1">
                    
                    <label for="speed-slider" style="margin-top: 5px;">Geschwindigkeit: <span id="speed-label"></span></label> <input type="range" id="speed-slider" min="0" max="100" value="10" step="1">
                </div>
                
                <label for="darkness-slider" style="margin-top: 5px;">Helligkeit (Nachtseite): <span id="darkness-label">0.04</span></label> <input type="range" id="darkness-slider" min="0" max="0.9" value="0.04" step="0.01">
                </div> 
        </div>
                
        <div id="ui-scrollable-content">
            
            <div class="control-group" id="controls-general-scrolling">
                <div id="comet-controls" style="display: none; margin-top: 15px; border-top: 1px dashed #444; padding-top: 10px;">
                    <button id="follow-comet-btn" class="btn btn-info btn-pulse" style="width: 100%; margin-bottom: 10px;">üî≠ Komet verfolgen!</button>
                    <label class="checkbox-label" style="color: #00ffff;">
                        <input type="checkbox" id="comet-speed-checkbox">
                        Komet-Zeitraffer (3x)
                    </label>
                </div>

                <div id="rocket-controls" style="display: none; margin-top: 10px; border-top: 1px dashed #444; padding-top: 10px;">
                    <button id="launch-rocket-btn" class="btn btn-danger btn-pulse" style="width: 100%; background-color: #b700ff;">üöÄ Raketenstart verf√ºgbar!</button>
                    <div id="rocket-status" style="font-size: 12px; text-align: center; margin-top: 5px; color: #aaa;"></div>
                    <button id="rocket-dismiss-btn" class="btn btn-secondary" style="width: 100%; margin-top: 5px; font-size: 11px; padding: 4px;">‚ùå Kein Interesse</button>
                    <button id="rocket-cam-btn" class="btn btn-warning" style="display: none; width: 100%; margin-top: 8px; font-size: 12px;">üé• Kino-Modus</button>
                    <button id="rocket-abort-btn" class="btn btn-secondary" style="display: none; width: 100%; margin-top: 5px; font-size: 12px; background-color: #555;">‚ùå Mission abbrechen</button>
                </div>

                <div id="visibility-controls">
                    <label class="checkbox-label" style="margin-top: 15px;">
                        <input type="checkbox" id="orbit-checkbox" checked>
                        Erd-/Mondbahn anzeigen
                    </label>
                    <label class="checkbox-label" style="margin-top: 10px;">
                        <input type="checkbox" id="equator-checkbox">
                        √Ñquatorlinie anzeigen
                    </label>
                    <div style="display: flex; gap: 15px; margin-top: 10px;">
                        <label class="checkbox-label" style="flex: 1;">
                            <input type="checkbox" id="planets-visible-checkbox" checked>
                            Planeten
                        </label>
                        <label class="checkbox-label" style="flex: 1;">
                            <input type="checkbox" id="planets-orbit-checkbox" checked>
                            Bahnen
                        </label>
                    </div>
                    <label class="checkbox-label" style="margin-top: 10px;">
                        <input type="checkbox" id="asteroids-checkbox">
                        Asteroideng√ºrtel
                    </label>
                    
                    <label class="checkbox-label" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #444;">
                        <input type="checkbox" id="human-objects-checkbox">
                        Menschl. Objekte anzeigen (ISS)
                    </label>
                    <div id="human-objects-focus-buttons" class="btn-group" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px dashed #555;">
                    </div>
                </div> 
                
                
            <div class="control-group">
                <h3>Kamera-Fokus</h3>
                <div class="btn-group">
                    <button id="focus-system" class="btn btn-focus">Sonnensystem</button>
                    <button id="focus-earth" class="btn btn-focus">Erde</button>
                    <button id="focus-moon" class="btn btn-focus">Mond</button>
                    <button id="focus-ecliptic" class="btn btn-focus">Ekliptik-Sicht</button>
                </div>
                <label class="checkbox-label" style="margin-top: 12px; padding-top: 10px; border-top: 1px dashed #444;">
                        <input type="checkbox" id="ecliptic-plane-checkbox">
                        Ekliptik-Fl√§chen (Erde/Mond) anzeigen
                    </label>
                <div id="planet-focus-buttons" class="btn-group" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #444; display: none;">
                </div>
                <div id="moon-focus-container">
                </div>
            </div>

            <div class="control-group">
                <h3>Ereignisse & Extras</h3>
                <div class="btn-group" id="demo-buttons">
                    <button id="demo-freq" class="btn btn-info">Sonnenfinsternis H√§ufigkeit</button>
                    <button id="demo-sofi" class="btn btn-warning">Sonnenfinsternisschatten</button>
                    <button id="demo-mofi" class="btn btn-warning">Mondfinsternisschatten</button>
                </div>
                
                <div id="freq-demo-controls" class="control-group" style="display: none; margin-bottom: 0; padding-top: 10px; border-top: 1px dashed #555; margin-top: 10px;">
                    <label class="checkbox-label" style="margin-top: 0;">
                        <input type="checkbox" id="real-ratio-checkbox">
                        Reale Gr√∂ssenverh√§ltnisse
                    </label>
                </div>
                
                <div class="btn-group" id="demo-control-buttons" style="display: none; margin-top: 10px;">
                    <button id="end-demo-btn" class="btn btn-danger">Demo beenden</button>
                </div>
                
                <div id="demo-speed-control">
                     <label for="demo-speed-slider" style="margin-top: 10px;">Demo-Geschw.: <span id="demo-speed-label">1.0</span>x</label>
                     <input type="range" id="demo-speed-slider" min="0" max="100" value="50" step="1">
                </div>
                
                <div id="info-box">Mondphase: mond</div>
            </div>

            <div class="control-group" id="moon-phases-group">
                <h3>Mondphasen</h3>
                <div id="moon-phases-ui">
                    <button id="phase-0" data-phase-index="0" class="moon-phase-btn" title="mond">üåë</button>
                    <button id="phase-1" data-phase-index="1" class="moon-phase-btn" title="Zunehmende Sichel">üåí</button>
                    <button id="phase-2" data-phase-index="2" class="moon-phase-btn" title="Zunehmender Halbmond">üåì</button>
                    <button id="phase-3" data-phase-index="3" class="moon-phase-btn" title="Zunehmendes Drittel">üåî</button>
                    <button id="phase-4" data-phase-index="4" class="moon-phase-btn" title="Vollmond">üåï</button>
                    <button id="phase-5" data-phase-index="5" class="moon-phase-btn" title="Abnehmendes Drittel">üåñ</button>
                    <button id="phase-6" data-phase-index="6" class="moon-phase-btn" title="Abnehmender Halbmond">üåó</button>
                    <button id="phase-7" data-phase-index="7" class="moon-phase-btn" title="Abnehmende Sichel">üåò</button>
                </div>
            </div>

            <div class="control-group" id="seasons-group">
                <h3>Jahreszeiten (Europa)</h3>
                <div class="btn-group">
                    <button id="season-spring" class="btn btn-spring">Fr√ºhling</button>
                    <button id="season-summer" class="btn btn-summer">Sommer</button>
                    <button id="season-autumn" class="btn btn-autumn">Herbst</button>
                    <button id="season-winter" class="btn btn-winter">Winter</button>
                </div>
            </div>
            <div class="control-group" id="real-scale-group">
                 <div id="real-scale-controls">
                    <hr class="separator" id="real-scale-sep1" style="display: none;">

                    <button id="real-dist-btn" class="btn btn-secondary" style="width: 100%; margin-top: 5px; display: none;">
                        üöÄ Reale Distanz
                    </button>

                    <hr class="separator" id="real-scale-sep2" style="display: none;">
                    
                    <button id="real-scale-btn" class="btn btn-secondary" style="width: 100%;">
                        üîç Reale Gr√∂ssen
                    </button>
                </div>
            </div>
            
        
    </div> <div id="scroll-indicator">‚ñº</div>
</div>
    <div id="info-popup">
        <div id="info-popup-content">
            <h2 id="popup-title">Titel</h2>
            <div id="popup-details">
                </div>
            <button id="popup-close-btn" class="btn btn-secondary">Schliessen</button>
        </div>
    </div>

    <div id="ufo-dialog">
        <h3>üõ∏ Unbekanntes Flugobjekt</h3>
        <!--Dialog Bild-->
        <img id="ufo-alien-image" src="ImagesGit/Alien/Alien_Nisu.webp" alt="Alien">
        <div id="ufo-dialog-text">Bist du in der Klasse von Herrn Lehmann? Wir sind auf dem Weg zur Erde, um Herrn Maurer zu entf√ºhren. Er hat wichtige Informationen √ºber das Universum, die wir brauchen. Weisst du wo er ist?</div>
        <div class="ufo-btn-group" id="ufo-initial-buttons">
            <button id="ufo-yes-btn" class="ufo-btn">Ja, dort lang! üëâ</button>
            <button id="ufo-no-btn" class="ufo-btn">Keine Ahnung ü§∑‚Äç‚ôÇÔ∏è</button>
        </div>
        <div class="ufo-btn-group" id="ufo-close-group" style="display: none;">
            <button id="ufo-close-btn" class="ufo-btn">Kommunikation beenden</button>
        </div>
    </div>

    <button id="info-toast-button" class="btn btn"></button>

    <!--Launch Hud-->
    <div id="launch-hud">
        <div id="hud-icon">‚è±Ô∏è</div>
        <div id="hud-content">
            <div id="hud-title">SYSTEM CHECK</div>
            <div id="hud-sub">Warte auf Startfreigabe...</div>
        </div>
        <div id="hud-bar"></div>
    </div>

    <script>
        //  Globale Variablen 
        let scene, camera, renderer, controls;
        let sun, earth, moon, moonPivot;
        let earthTiltPivot;

        // Liste f√ºr alle "Nacht-Lichter"
        let nightTimeLights = [];

        // Hilfsfunktion: F√ºgt ein lokales Licht zum Objekt hinzu
        function addFillLight(object3D, intensity, distance, positionOffset = null, minBrightness = 0.0) {
            const light = new THREE.PointLight(0xffffff, intensity, distance);
            
            // Standard-Position (wenn nichts angegeben ist): Leicht √ºber und vor dem Objekt
            if (positionOffset) {
                light.position.copy(positionOffset);
            } else {
                light.position.set(0, 2.0, 1.0); 
            }
            
            light.castShadow = false; 
            
            object3D.add(light);
            
            // Wir speichern wichtige Daten f√ºr die Steuerung
            light.userData.baseIntensity = intensity;   // Die volle St√§rke (Slider Max)
            light.userData.minBrightness = minBrightness; // Das Minimum (f√ºr Astronaut)
            
            nightTimeLights.push(light);
        }

        
        
        //  Globale Variable f√ºr Achsenlinie 
        let earthAxisLine = null;
        
        let earthEquatorLine = null;
        
        let earthOrbitLine, moonOrbitLine;
        let starField;
        
        let otherPlanets = [];
        let otherPlanetControls = []; 
        let otherPlanetOrbits = [];
        let otherMoons = []; 
        let planetsData = [];

        let jupiterMoonShadowUniforms = null;
        let jupiterMoons = [];

        let moonSurfaceObjects = [];

        // --- RAKETEN KONFIGURATION ---
        const ROCKET_FLIGHT_DURATION_SECONDS = 40.0; // Wie lange der Flug dauert (in echten Sekunden)
        const ROCKET_SIZE_SCALE = 1.0; // Gr√∂sse des Modells (√§hnlich wie ISS)
        const ROCKET_PROBABILITY = 0.2; // 30% Chance pro Sitzung, dass sie erscheint
        
        // Rakete Liftoff-Phase H√∂he und Dauer
        const LIFTOFF_DURATION_SECONDS = 9.0; // Die Rakete steigt 12 Sekunden lang nur senkrecht
        const LIFTOFF_HEIGHT = 0.4; // Wie hoch sie dabei kommt (bevor sie in den Orbit kippt)

        let rocketInstance = null; 
        let rocketSpawnAllowed = false; 
        
        // E TEMPLATE VARIABLEN
        let rocketFullTemplate = null;      // 1. Ganze Rakete
        let rocketStage2Template = null;    // 2. Oberstufe
        let debris1Template = null;         // 3. Booster Schrott
        let debris2Template = null;         // 4. Ring Schrott
        let capsuleModelTemplate = null;    // 5. Kapsel


        //Load Screen
        let loadingManager;

        //  F√ºr 3D-Modelle 
        let loaded3DModels = []; // Ein Array, das alle unsere Modelle aufnimmt
        let humanObjectsCheckbox;  
        let cometModelTemplate = null;
        let cometRockTexture;
        let ufoModelTemplate = null;
        let astronautTemplate = null;
        let landerTemplate = null;
        let flagTemplate = null
        let asteroidInstancedMesh = null;


        //Ecliptic-Plane
        let earthEclipticPlane, moonEclipticPlane;
        let eclipticPlaneCheckbox;
        
        
        let planetRingMaterials = []; 

        let isPlaying = true;
        // *** √ÑNDERUNG 2: Globale Variable f√ºr Zur√ºckspulen ***
        let isRewinding = false;
        
        let currentDay = 0;
        let speed = 1.0;
        let cameraFocus = 'system';
        let lastCameraTargetPos = new THREE.Vector3();
        let isDemoActive = false;
        let originalMoonMaterial;
        let moonPhaseButtons = [];

        //  Animations-Variablen f√ºr Realit√§tscheck 
        let isRealScaleActive = false;
        let isRealDistanceActive = false;
        let realityCheckPhase = 'idle'; 

        let flightStartState = { startDist: 0, startMoonDist: 0, progress: 0, duration: 10.0 };
        
        let sunGhost = null;
        let rulerGroup = null; 
        let rulerFadeTimer = 0;
        
        let distanceLabelEl = null;
        let currentDayLabelEl = null;

        let targetSunScale = 1.0;
        let targetEarthDistance; 
        let targetMoonDistance; 
        let currentSunScale = 1.0;
        let currentEarthDistance;
        let currentMoonDistance; 
        // -

        // Demo-spezifische Variablen
        let demoLoopStartDay = 0;
        let demoLoopEndDay = 0;
        let demoLoopSpeed = 0.1; 
        let demoType = ''; 
        let demoShadowBrightness = 0.0; 
        let demoRedOverlay = 0.0; 
        let earthDemoRotationOffset = 0.0;

        //  Frequenz-Demo-Variablen 
        let isFrequencyDemoActive = false;
        let freqDemoControls;
        let realRatioCheckbox;
        let originalSunScale = new THREE.Vector3(1,1,1);
        let originalMoonScale = new THREE.Vector3(1,1,1);
        let freqDemoSunScale;   // Skalierung der Sonne, um zur Mond-Simulation zu passen
        let realRatioSunScale;  // Reale Winkelgr√∂sse (Sonne)
        let realRatioMoonScale; // Reale Winkelgr√∂sse (Mond)
        // 
        
        // Kamera-Animation (Tweening)
        const clock = new THREE.Clock();
        let isCameraTransitioning = false;
        let cameraTransitionProgress = 0.0;
        let cameraTransitionDuration = 1.0;
        let cameraTransitionStartPos = new THREE.Vector3();
        let cameraTransitionStartTarget = new THREE.Vector3();
        let cameraTransitionEndPos = new THREE.Vector3();
        let cameraTransitionEndTarget = new THREE.Vector3();
        let cameraFocusAfterTransition = null;
        let cameraTransitionCallback = null; 

        // Raycasting (Klick-Erkennung)
        let raycaster;
        let mouse;
        let clickableObjects = [];
        
        // Zeitstempel f√ºr iPad-Ghost-Click-Fix 
        let lastTouchTime = 0;
        

        // Interaction handling variables
        let interactionTimeout;
        let userInteractedRecently = false;

        //  Konstanten 
        const SCENE_SCALE = 1.0;
        const SUN_RADIUS = 62.5 * SCENE_SCALE; 
        const EARTH_RADIUS = 2.5 * SCENE_SCALE;
        const MOON_RADIUS = 0.68 * SCENE_SCALE;
        const ERDE_RADIUS_KM = 6371;
        
        const EARTH_DISTANCE = 270 * SCENE_SCALE;
        const MOON_DISTANCE = 15 * SCENE_SCALE;

        const EARTH_TILT_RAD = (23.5 * Math.PI) / 180;
        const MOON_TILT_RAD = (5.1 * Math.PI) / 180; 

        const EARTH_YEAR_DAYS = 365.25;
        const LUNAR_MONTH_DAYS = 29.53; 
        
        const PHASE_OFFSET_DAYS = 0; 

        //  Konstanten f√ºr reale Verh√§ltnisse 
        const REAL_SUN_SCALE_FACTOR = (109 * EARTH_RADIUS) / SUN_RADIUS; 
        const REAL_EARTH_DIST_VALUE = 23400 * EARTH_RADIUS; 
        
        let COMPARE_EARTH_DIST_VALUE = 400 * SCENE_SCALE; 
        
        const REAL_MOON_DIST_VALUE = 60 * EARTH_RADIUS; 
        // --
        
        const RING_SHADOW_SOFTNESS = 10 * SCENE_SCALE;
        
        const PHASE_DAY_MAP = [
            LUNAR_MONTH_DAYS * 0.0  + PHASE_OFFSET_DAYS, 
            LUNAR_MONTH_DAYS * 0.125 + PHASE_OFFSET_DAYS, 
            LUNAR_MONTH_DAYS * 0.25  + PHASE_OFFSET_DAYS, 
            LUNAR_MONTH_DAYS * 0.375 + PHASE_OFFSET_DAYS, 
            LUNAR_MONTH_DAYS * 0.5  + PHASE_OFFSET_DAYS, 
            LUNAR_MONTH_DAYS * 0.625  + PHASE_OFFSET_DAYS, 
            LUNAR_MONTH_DAYS * 0.75  + PHASE_OFFSET_DAYS, 
            LUNAR_MONTH_DAYS * 0.875  + PHASE_OFFSET_DAYS  
        ];

        const COMET_FOCUS_DISTANCE = 20.0;

        let isUserControllingCamera = false;
        let currentSelectedInfo = null;
        let infoToastButton;
        let followCometBtn;
        let cometControls; 

        //  UFO Variablen 
        let ufo;
        let ufoState = 'inactive'; 
        let ufoSpawnTimer = Math.random() * 180 + 120; 
        // UFO Killswitch (>= 3 Begegnungen, kein es Ufo mehr)
        let ufoEncounterCount = 0;
        let ufoWanderTimer = 0;
        let ufoTargetPos = new THREE.Vector3();
        let ufoCurrentTargetObject = null; 
        let ufoDepartureTarget = null; 
        const UFO_SPEED = 100 * SCENE_SCALE; 
        const UFO_SPEED_TO_EARTH = 300 * SCENE_SCALE;
        let ufoLeaveTimer = 0; 
        // --

        // --- FLAT EARTH VARIABLES ---
        let isFlatEarth = false; 
        let isFlagOnMoon = false; // Speichert, ob die Flagge schon steht
        let hasMoonMissionLanded = false;
        let flatAnimPhase = 'idle'; // 'idle', 'flying_to_pos', 'anticipation', 'wobble', 'splat', 'restoring'
        let flatAnimTimer = 0;
        
        //  Komet Variablen und Klasse 
        let comet; 

        // : Kein Timer mehr, der runterz√§hlt, sondern ein fester Zeitpunkt
        let cometSpawnDay = -1; // -1 bedeutet: Noch nicht bestimmt

        // : Wahrscheinlichkeit (z.B. 20% Chance pro Sitzung)
        const COMET_PROBABILITY = 0.2; 

        // : Wann soll er kommen? (Zuf√§lliger Tag in der Zukunft, z.B. zwischen Tag 100 und 500)
        const COMET_MIN_DAY = 100;
        const COMET_MAX_DAY = 500;
        let cometSpawnTimer = THREE.MathUtils.randFloat(600, 1200); 
        const COMET_SPAWN_DIST = 2500 * SCENE_SCALE; 
        const COMET_DESTROY_DIST = 2500 * SCENE_SCALE; 
        const COMET_CAMERA_RESET_DIST = 2400 * SCENE_SCALE; 
        
        const GRAVITY_STRENGTH = 100000 * SCENE_SCALE; 
        const GRAVITY_FACTOR = 0.05; 
        const MIN_PERIHELION_DISTANCE = 110 * SCENE_SCALE; 
        
        let cometTimeScale = 1.0;

        // NEUE FUNKTION: Steuert die Sichtbarkeit der UI w√§hrend des Raketenstarts
        function setLaunchModeUI(isActive) {
            const displayStyle = isActive ? 'none' : ''; 
            
            // 1. Header-Elemente
            const playGroup = document.getElementById('play-group');
            const timeControls = document.getElementById('time-controls');
            if (playGroup) playGroup.style.display = displayStyle;
            if (timeControls) timeControls.style.display = displayStyle;

            // 2. KOMETEN CONTROLS (Wichtig!)
            const cometCtrl = document.getElementById('comet-controls');
            if (cometCtrl) {
                if (isActive) {
                    // Beim Start IMMER ausblenden
                    cometCtrl.style.display = 'none';
                } else {
                    // Beim Beenden NUR einblenden, wenn auch ein Komet da ist!
                    // Wir pr√ºfen, ob das globale 'comet'-Objekt existiert.
                    if (typeof comet !== 'undefined' && comet !== null) {
                        cometCtrl.style.display = 'block';
                    } else {
                        cometCtrl.style.display = 'none';
                    }
                }
            }

            // 3. Sichtbarkeits-Checkboxen
            const visCtrl = document.getElementById('visibility-controls');
            if (visCtrl) visCtrl.style.display = displayStyle;

            // 4. Andere Hauptgruppen
            const focusGroup = document.getElementById('focus-system')?.parentElement?.parentElement; 
            const extrasGroup = document.getElementById('demo-buttons')?.parentElement; 
            const phasesGroup = document.getElementById('moon-phases-group');
            const seasonsGroup = document.getElementById('seasons-group');
            const realScaleGroup = document.getElementById('real-scale-group');

            if (focusGroup) focusGroup.style.display = displayStyle;
            if (extrasGroup) extrasGroup.style.display = displayStyle;
            if (phasesGroup) phasesGroup.style.display = displayStyle;
            if (seasonsGroup) seasonsGroup.style.display = displayStyle;
            if (realScaleGroup) realScaleGroup.style.display = displayStyle;

            const scrollInd = document.getElementById('scroll-indicator');
            if (scrollInd) scrollInd.style.display = displayStyle;
        }

        class Comet {
            constructor(scene) {
                this.scene = scene;
                this.particles = [];
                this.group = new THREE.Group();
                scene.add(this.group);
                
                this.baseSpeed = 8.0 * SCENE_SCALE; 
                this.color = new THREE.Color(0.6, 0.9, 1.0); 

                // SHADER (Unver√§ndert)
                const cometVertexShader = `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    void main() {
                        vUv = uv;
                        vNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
                        vec4 worldPos = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPos.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;

                const cometFragmentShader = `
                    uniform sampler2D map;
                    uniform vec3 uSunPosition;
                    uniform float uNightBrightness; 
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 texColor = texture2D(map, vUv);
                        vec3 lightDir = normalize(uSunPosition - vWorldPosition);
                        float sunLight = max(0.0, dot(vNormal, lightDir));
                        float finalLight = max(sunLight, uNightBrightness);
                        gl_FragColor = vec4(texColor.rgb * finalLight * 1.2, texColor.a);
                    }
                `;

                // 3D-Modell Logik
                if (cometModelTemplate) {
                    this.mesh = cometModelTemplate.clone();
                    
                    const fixedVisualScale = 0.11; 
                    this.mesh.scale.set(fixedVisualScale, fixedVisualScale, fixedVisualScale);
                    this.radius = fixedVisualScale * 0.5; 
                    
                    this.mesh.traverse(child => {
                        if (child.isMesh) {
                            const tex = child.material.map || cometRockTexture;
                            const currentBrightness = parseFloat(document.getElementById('darkness-slider').value);

                            child.material = new THREE.ShaderMaterial({
                                vertexShader: cometVertexShader,
                                fragmentShader: cometFragmentShader,
                                uniforms: {
                                    map: { value: tex },
                                    uSunPosition: { value: new THREE.Vector3(0, 0, 0) },
                                    uNightBrightness: { value: currentBrightness }
                                }
                            });
                            this.material = child.material; 
                        }
                    });
                } else {
                    // Fallback
                    this.radius = 0.02; 
                    const cometGeo = new THREE.DodecahedronGeometry(this.radius, 1);
                    this.material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                    this.mesh = new THREE.Mesh(cometGeo, this.material);
                }

                this.mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                this.group.add(this.mesh);

                // Bounding Box Fix
                const box = new THREE.Box3().setFromObject(this.mesh);
                const size = new THREE.Vector3();
                box.getSize(size);
                const maxDimension = Math.max(size.x, size.y, size.z);
                this.visualRadius = maxDimension / 2;

                // --- STARTPOSITION (√ÑNDERUNG 4: Vertikaler Spawn) ---
                const startAngle = THREE.MathUtils.randFloat(0, Math.PI * 2);
                const startX = Math.cos(startAngle) * COMET_SPAWN_DIST;
                const startZ = Math.sin(startAngle) * COMET_SPAWN_DIST;
                
                // Entweder deutlich OBEN oder deutlich UNTEN spawnen
                // Wir nehmen min. +/- 500 Einheiten, um Planetenbahnen (meist < 100 Y) zu vermeiden
                const spawnSign = Math.random() < 0.5 ? 1 : -1;
                const startY = spawnSign * THREE.MathUtils.randFloat(500 * SCENE_SCALE, 800 * SCENE_SCALE);

                const startPos = new THREE.Vector3(startX, startY, startZ);
                this.group.position.copy(startPos);
                
                // Ziel: Irgendwo in der N√§he der Sonne (Zentrum), aber leicht versetzt
                const centerTargetOffset = 100 * SCENE_SCALE;
                let target = new THREE.Vector3(
                    THREE.MathUtils.randFloat(-centerTargetOffset, centerTargetOffset),
                    THREE.MathUtils.randFloat(-centerTargetOffset, centerTargetOffset),
                    THREE.MathUtils.randFloat(-centerTargetOffset, centerTargetOffset)
                );
                
                const initialDirection = new THREE.Vector3().subVectors(target, startPos).normalize();
                const perpendicularOffset = new THREE.Vector3().crossVectors(startPos, initialDirection).normalize();
                perpendicularOffset.multiplyScalar(MIN_PERIHELION_DISTANCE * THREE.MathUtils.randFloat(1.1, 1.5)); 
                target.add(perpendicularOffset);
                const finalDirection = new THREE.Vector3().subVectors(target, startPos).normalize();
                
                this.velocity = finalDirection.multiplyScalar(this.baseSpeed);

                this.tailGroup = new THREE.Group();
                this.scene.add(this.tailGroup); 
                this.age = 0;
                
                // Komet-Info f√ºr Popup
                const hitboxGeo = new THREE.SphereGeometry(this.radius * 6.0, 8, 8); 
                const hitboxMat = new THREE.MeshBasicMaterial({ 
                    visible: false, // Unsichtbar
                    wireframe: true 
                });
                
                this.hitbox = new THREE.Mesh(hitboxGeo, hitboxMat);
                this.group.add(this.hitbox); // Bewegt sich mit dem Kometen mit

                // 2. Info an die HITBOX h√§ngen (nicht mehr an das Mesh)
                this.hitbox.userData.info = {
                    name: 'Komet 67P (Tschurjumow-Gerassimenko)', type: 'comet', radius_km: `ca. 4,1 √ó 3,3 km`, velocity: `bis zu 135.000 km/h (Perihel)`, umlaufzeit: '6,44 Jahre',
                    funFacts: [
                        'Kometen sind "schmutzige Schneeb√§lle" aus Eis, Staub und Gestein.',
                        'Ihr Schweif entsteht erst in Sonnenn√§he, wenn das Eis verdampft (sublimiert).',
                        'Der Schweif zeigt immer von der Sonne weg (Sonnenwind).'
                    ]
                };

                // 3. Nur die Hitbox klickbar machen
                clickableObjects.push(this.hitbox);
            }

            update(deltaTime) {
                const cometDelta = deltaTime * cometTimeScale;
                const sunPos = new THREE.Vector3(0,0,0);
                const toSun = new THREE.Vector3().subVectors(sunPos, this.group.position);
                const distanceSq = toSun.lengthSq();
                const distance = Math.sqrt(distanceSq);
                
                // Gravitation
                const safeDistanceSq = Math.max(distanceSq, (SUN_RADIUS * 2) * (SUN_RADIUS * 2));
                let acceleration = toSun.normalize().multiplyScalar(GRAVITY_STRENGTH / safeDistanceSq);
                acceleration.multiplyScalar(GRAVITY_FACTOR); 
                this.velocity.add(acceleration.multiplyScalar(cometDelta));
                this.group.position.add(this.velocity.clone().multiplyScalar(cometDelta));

                this.mesh.rotation.x += cometDelta * 0.1; 
                this.mesh.rotation.y += cometDelta * 0.15;

                if (this.material && this.material.uniforms) {
                    const sliderVal = parseFloat(document.getElementById('darkness-slider').value);
                    this.material.uniforms.uNightBrightness.value = sliderVal;
                }

                // --- SCHWEIF LOGIK ANPASSUNG (√ÑNDERUNG 3) ---
                
                // Start: Au√üerhalb von Neptun (Neptun ~ 1980). Start bei 2300.
                const activeDist = 2300 * SCENE_SCALE; 
                
                // Berechne Basis-Intensit√§t (0.0 bis 1.0)
                let rawIntensity = Math.max(0, 1.0 - (distance / activeDist)); 
                
                // Intensity Curve: Lineares Wachstum, damit er drau√üen schon leicht sichtbar ist
                const intensity = rawIntensity; 

                this.generateTail(distance, intensity, cometDelta); 
                this.updateTail(cometDelta);
                
                const isMovingAway = this.group.position.dot(this.velocity) > 0;
                if (distance > COMET_CAMERA_RESET_DIST && isMovingAway) {
                    if (cameraFocus === this.mesh) setFocus(sun, 3.0);
                    if (cometControls) cometControls.style.display = 'none';
                }
                
                if (distance > COMET_DESTROY_DIST && isMovingAway) {
                    this.destroy();
                    return true; 
                }
                this.age += cometDelta;
                return false; 
            }
            
            destroy() {
                if (cameraFocus === this.mesh) setFocus(sun, 3.0);
                if (cometControls) cometControls.style.display = 'none';

                this.particles.forEach(p => {
                    this.tailGroup.remove(p.mesh);
                    if(p.mesh.geometry) p.mesh.geometry.dispose();
                    if(p.mesh.material) p.mesh.material.dispose();
                });
                this.particles = [];
                
                this.group.remove(this.mesh);
                if (this.hitbox) {
                    this.group.remove(this.hitbox);
                    this.hitbox.geometry.dispose();
                    this.hitbox.material.dispose();
                }
                this.scene.remove(this.group);
                this.scene.remove(this.tailGroup); 
                
                if (this.mesh) {
                    this.mesh.traverse((child) => {
                        if (child.isMesh) {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                                else child.material.dispose();
                            }
                        }
                    });
                }

                const index = clickableObjects.indexOf(this.hitbox); 
                if (index > -1) clickableObjects.splice(index, 1);
            }
            
            generateTail(sunDistance, intensity, cometDelta) {
                // Erscheint jetzt viel fr√ºher (schon bei kleinster Intensit√§t)
                if (intensity <= 0.0001) return;

                // Mehr Partikel: Basisrate erh√∂ht
                const spawnChance = (intensity + 0.2) * cometTimeScale; 
                
                // √ÑNDERUNG 1: Viel mehr Partikel bei hoher Intensit√§t
                // Bei maximaler N√§he (intensity=1) bis zu 5 Loops pro Frame
                let loopCount = Math.ceil(intensity * 5.0); 
                // Mindestens 1 Versuch, wenn √ºberhaupt sichtbar
                if (loopCount < 1) loopCount = 1;

                for(let k=0; k<loopCount; k++) {
                    // Je weiter weg, desto seltener spawnen sie (um Ressourcen zu sparen, wenn er weit weg ist)
                    if (Math.random() > spawnChance) continue; 

                    // Spawn-Bereich verkleinert, damit der Strahl "fokussierter" wirkt
                    const spawnOffset = new THREE.Vector3(
                        THREE.MathUtils.randFloat(-0.5, 0.5),
                        THREE.MathUtils.randFloat(-0.5, 0.5),
                        THREE.MathUtils.randFloat(-0.5, 0.5)
                    ).normalize().multiplyScalar(this.radius * 1.2);

                    const spawnPos = this.group.position.clone().add(spawnOffset);

                    // √ÑNDERUNG 1: Viel kleiner (0.15 bis 0.4 statt 0.5 bis 1.2)
                    const particleSize = THREE.MathUtils.randFloat(0.08, 0.2) * SCENE_SCALE; 

                    const particleMat = new THREE.MeshBasicMaterial({ 
                        color: this.color.clone().lerp(new THREE.Color(0xffffff), 0.4), 
                        transparent: true, 
                        opacity: intensity * 0.9, // Etwas transparenter am Start
                        side: THREE.DoubleSide,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending 
                    });
                    
                    const particleMesh = new THREE.Mesh(new THREE.PlaneGeometry(particleSize, particleSize), particleMat);
                    particleMesh.position.copy(spawnPos);
                    particleMesh.lookAt(camera.position);
                    
                    // √ÑNDERUNG 2: Vektorberechnung - Schweif folgt dem Kometen
                    const fromSun = this.group.position.clone().normalize(); 
                    const oppositeVelocity = this.velocity.clone().normalize().negate(); 
                    
                    const tailDir = new THREE.Vector3().addVectors(
                        oppositeVelocity.multiplyScalar(1.0), // 100% Einfluss der Flugbahn (bleibt hinten)
                        fromSun.multiplyScalar(0.5)           // Nur 30% Sonnenwind (lenkt leicht ab)
                    ).normalize();

                    // Weniger Streuung f√ºr einen strafferen Schweif
                    tailDir.x += THREE.MathUtils.randFloat(-0.1, 0.1); 
                    tailDir.y += THREE.MathUtils.randFloat(-0.1, 0.1);
                    tailDir.z += THREE.MathUtils.randFloat(-0.1, 0.1);

                    this.particles.push({
                        mesh: particleMesh,
                        velocity: tailDir.multiplyScalar(THREE.MathUtils.randFloat(10 * SCENE_SCALE, 20 * SCENE_SCALE)),
                        drift: new THREE.Vector3( 
                            THREE.MathUtils.randFloat(-0.2, 0.2),
                            THREE.MathUtils.randFloat(-0.2, 0.2),
                            THREE.MathUtils.randFloat(-0.2, 0.2)
                        ).multiplyScalar(2.0 * SCENE_SCALE), 
                        // √ÑNDERUNG 1: L√§nger leben (4.0 bis 7.0 Sekunden)
                        lifetime: THREE.MathUtils.randFloat(6.0, 10.0), 
                        age: 0,
                        initialOpacity: particleMat.opacity
                    });
                    this.tailGroup.add(particleMesh);
                }
            }

            updateTail(cometDelta) {
                const newParticles = [];
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    
                    p.velocity.add(p.drift.clone().multiplyScalar(cometDelta * 0.1));
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(cometDelta));
                    p.mesh.lookAt(camera.position);

                    p.age += cometDelta;
                    const lifeRatio = p.age / p.lifetime;
                    
                    if (lifeRatio >= 1.0) {
                        this.tailGroup.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                    } else {
                        p.mesh.material.opacity = p.initialOpacity * (1.0 - lifeRatio);
                        // Weniger Wachstum, damit sie klein bleiben
                        const scale = 1.0 + (lifeRatio * 1.5);
                        p.mesh.scale.set(scale, scale, scale); 
                        newParticles.push(p);
                    }
                }
                this.particles = newParticles;
            }
        }
        
        // RAKETEN-KLASSE
        // RAKETEN-KLASSE (Final: Wackeln nur am Modell & Zielsuch-Landung)
        // RAKETEN-KLASSE (Final V3: Kamera-Stabilisierung & Korrekte Flugbahn)
        class Rocket {
            constructor(scene) {
                this.scene = scene;
                this.state = 'ready'; 
                this.timer = 0;
                
                // --- EINSTELLUNGEN ---
                this.TOTAL_FLIGHT_TIME = 40.0; 
                this.launchSpeed = 0.5;       
                this.moonCruiseSpeed = 1.0;   
                
                this.VERTICAL_PHASE_END = 0.10; 
                this.TRANS_LUNAR_INJECTION_START = 0.75; 

                this.VERTICAL_HEIGHT_TARGET = 0.3 * SCENE_SCALE; 
                this.ORBIT_HEIGHT_ADD = 2.5 * SCENE_SCALE; 
                this.ORBIT_ROTATIONS = -630 * (Math.PI / 180); 
                
                this.rawProgress = 0; 
                
                this.startRelPos = new THREE.Vector3(); 
                this.startAngle = 0;
                this.startRadius = 0;
                this.startY = 0; 
                
                this.hasStaged1 = false; 
                this.hasStaged2 = false; 

                this.isOnboardCamera = false;  
                this.camButtonVisible = false; 
                
                // Animations-Variablen f√ºr die Kamerafahrt
                this.camCurrentZ = -2.5;   // Startposition (hinten)
                this.camCurrentDist = 2.0; // Startabstand (vom Rumpf)

                this.camCurrentHeight = 0.3; // Start: Leicht √ºber der Rakete
                this.camCurrentLook = 0.0;   // Start: Blick genau auf die Rakete

                // ---  Kamera-Variablen ---
                this.isOnboardCamera = false;  // Ist die Kamera gerade aktiv?
                this.camButtonVisible = false; // Wurde der Button schon gezeigt?
                // -----------------------------

                this.group = new THREE.Group();
                this.group.userData.isRocket = true; 
                this.effScale = 0.0030; 
                
                this.group.userData.info = {
                    name: 'Apollo Mission (Saturn V)', type: 'rocket', radius_km: '110,6 m', velocity: 'max. 39.000 km/h',
                    funFacts: [
                        'Mit 110 Metern H√∂he √ºberragt sie die Freiheitsstatue und ist die gr√∂√üte jemals geflogene Rakete.',
                        'Die Triebwerke der ersten Stufe verbrauchten pro Sekunde 13 Tonnen Treibstoff ‚Äì so viel wie ein Pool voll Benzin.',
                        'Sie bestand aus √ºber 3 Millionen Einzelteilen. Selbst bei 99,9% Zuverl√§ssigkeit h√§tte es noch 3.000 Fehler gegeben.',
                        'Der Start war so laut, dass er als k√ºnstliches Erdbeben registriert wurde und Beton zum Schmelzen brachte.'
                    ]
                };
                clickableObjects.push(this.group);

                this.smokeParticles = [];
                this.smokeTexture = this.createSmokeTexture();
                this.smokeGroup = new THREE.Group();
                this.scene.add(this.smokeGroup); 

                // ... (Hier folgt dein bestehender Modell-Aufbau Code: shakerContainer, meshCapsule etc.) ...
                // ... (Diesen Teil bitte aus deinem alten Code behalten, er √§ndert sich nicht) ...
                
                // 1. Container f√ºr Wackeln
                this.shakerContainer = new THREE.Group();
                this.group.add(this.shakerContainer);
                // 2. Container f√ºr Kamera-Anker (Stabil)
                this.meshCapsule = new THREE.Group(); 
                this.group.add(this.meshCapsule); 
                // 3. Container f√ºr Optik
                this.visualCapsule = new THREE.Group();
                this.meshCapsule.add(this.visualCapsule);

                this.meshFull = new THREE.Group();
                this.shakerContainer.add(this.meshFull); 
                this.meshStage2 = new THREE.Group();
                this.shakerContainer.add(this.meshStage2);
                
                this.debrisBooster = new THREE.Group();
                this.group.add(this.debrisBooster); 
                this.debrisStage2 = new THREE.Group();
                this.group.add(this.debrisStage2); 
                
                this.meshFull.visible = true;       
                this.meshStage2.visible = false;
                this.debrisBooster.visible = false;
                this.debrisStage2.visible = false;
                this.meshCapsule.visible = false; 

                // Hilfsfunktion zum Laden der Templates (wie gehabt)
                const setupModel = (template, container) => {
                    if (template) {
                        const m = template.clone();
                        m.rotation.x = Math.PI / 2; 
                        container.add(m);
                    }
                };
                
                // Modelle einf√ºgen (Templates m√ºssen global verf√ºgbar sein)
                if(typeof rocketFullTemplate !== 'undefined') setupModel(rocketFullTemplate, this.meshFull); 
                if(typeof rocketStage2Template !== 'undefined') setupModel(rocketStage2Template, this.meshStage2); 
                if(typeof debris1Template !== 'undefined') setupModel(debris1Template, this.debrisBooster); 
                if(typeof debris2Template !== 'undefined') setupModel(debris2Template, this.debrisStage2); 
                if(typeof capsuleModelTemplate !== 'undefined') setupModel(capsuleModelTemplate, this.visualCapsule);

                this.meshCapsule.position.z = 0.1; 

                // Lichter (wie gehabt)
                this.engineLight = new THREE.PointLight(0xffffff, 2.0, 100);
                this.engineLight.position.set(5, 10, 5); 
                this.group.add(this.engineLight);
                
                const glowTexture = this.createSmokeTexture();
                const mat = new THREE.SpriteMaterial({ map: glowTexture, color: 0xffaa00, blending: THREE.AdditiveBlending, depthWrite: false });
                
                this.engineGlow = new THREE.Sprite(mat);
                const fireSize = this.effScale * 20.0; 
                this.engineGlow.scale.set(fireSize, fireSize, 1);
                this.engineGlow.position.z = -0.005; 
                this.meshFull.add(this.engineGlow); 

                this.engineGlow2 = this.engineGlow.clone();
                this.engineGlow2.position.z = 0.06; 
                this.engineGlow2.scale.set(fireSize * 0.9, fireSize * 0.9, 1);
                this.meshStage2.add(this.engineGlow2);

                this.capsuleEngine = this.engineGlow.clone();
                this.capsuleEngine.scale.set(fireSize * 0.2, fireSize * 0.2, 1);
                this.visualCapsule.add(this.capsuleEngine);

                // --- KINO-KAMERA DATEN (Bereinigt & Gegl√§ttet) ---
                this.cinematicKeyframes = [
                    // RUHIGER START (0% - 9%)
                    { p: 0.001, h: 0.05, d: -8.79, z: 0.38, l: 0.1 },
                    { p: 0.020, h: 0.05, d: -8.44, z: 1.36, l: 0.1 },
                    { p: 0.040, h: 0.05, d: -8.44, z: 1.36, l: 0.1 },
                    { p: 0.060, h: 0.05, d: -8.44, z: 1.36, l: 0.1 },
                    { p: 0.080, h: 0.05, d: -8.44, z: 1.36, l: 0.1 },
                    
                    // DER SCHWUNG (9% - 15%) - Hier habe ich die Dichte massiv erh√∂ht!
                    { p: 0.091, h: 0.08, d: -8.44, z: 1.36, l: 0.1 },
                    { p: 0.093, h: 0.47, d: -8.43, z: 1.36, l: 0.1 },
                    { p: 0.095, h: 1.27, d: -8.35, z: 1.36, l: 0.1 },
                    { p: 0.097, h: 2.37, d: -8.02, z: 1.54, l: 0.1 },
                    { p: 0.099, h: 3.52, d: -7.34, z: 2.04, l: 0.1 },
                    { p: 0.101, h: 4.95, d: -6.09, z: 2.58, l: 0.1 },
                    { p: 0.103, h: 6.54, d: -4.30, z: 2.62, l: 0.1 },
                    { p: 0.105, h: 7.54, d: -2.64, z: 2.32, l: 0.1 },
                    { p: 0.107, h: 8.23, d: -1.14, z: 1.67, l: 0.1 },
                    { p: 0.109, h: 8.72, d: 0.30, z: 0.55, l: 0.1 },
                    { p: 0.111, h: 8.93, d: 1.31, z: -0.90, l: 0.1 },
                    { p: 0.113, h: 8.88, d: 1.93, z: -2.26, l: 0.1 },
                    { p: 0.115, h: 8.44, d: 2.80, z: -3.90, l: 0.1 },
                    { p: 0.117, h: 7.71, d: 3.28, z: -5.52, l: 0.1 },
                    { p: 0.119, h: 6.91, d: 3.26, z: -6.93, l: 0.1 },
                    { p: 0.121, h: 5.57, d: 2.97, z: -8.55, l: 0.1 },
                    { p: 0.123, h: 4.43, d: 2.67, z: -9.48, l: 0.1 },
                    { p: 0.125, h: 3.37, d: 1.76, z: -10.27, l: 0.1 },
                    { p: 0.127, h: 2.43, d: 0.30, z: -10.76, l: 0.1 },
                    { p: 0.130, h: 1.79, d: -1.06, z: -10.86, l: 0.1 },
                    { p: 0.135, h: 1.04, d: -2.35, z: -10.73, l: 0.1 },
                    { p: 0.140, h: 0.12, d: -2.85, z: -10.64, l: 0.1 },
                    
                    // BOOSTER ABWURF & √úBERGANG (15% - 20%)
                    { p: 0.145, h: -0.73, d: -3.32, z: -10.44, l: 0.1 },
                    { p: 0.150, h: -1.10, d: -3.74, z: -10.22, l: 0.1 },
                    { p: 0.155, h: -1.09, d: -3.82, z: -9.18, l: 0.1 },
                    { p: 0.160, h: -0.85, d: -3.08, z: -7.12, l: 0.1 },
                    { p: 0.165, h: -0.67, d: -2.47, z: -5.63, l: 0.1 },
                    { p: 0.170, h: -0.70, d: -2.66, z: -5.48, l: 0.1 },
                    { p: 0.175, h: -0.69, d: -2.67, z: -5.18, l: 0.1 },
                    { p: 0.180, h: -0.72, d: -2.83, z: -5.03, l: 0.1 },
                    { p: 0.185, h: -0.74, d: -2.96, z: -4.90, l: 0.1 },
                    { p: 0.190, h: -0.76, d: -3.11, z: -4.73, l: 0.1 },
                    { p: 0.195, h: -0.83, d: -3.24, z: -4.55, l: 0.1 },
                    { p: 0.200, h: -1.01, d: -4.15, z: -4.90, l: 0.1 },
                    { p: 0.214, h: -1.86, d: -6.07, z: -5.80, l: 0.1 },
                    { p: 0.229, h: -2.36, d: -7.97, z: -5.67, l: 0.1 },
                    { p: 0.245, h: -2.42, d: -8.47, z: -4.22, l: 0.1 },
                    { p: 0.260, h: -2.42, d: -8.73, z: -2.74, l: 0.1 },
                    { p: 0.275, h: -2.38, d: -8.73, z: -1.11, l: 0.1 },
                    { p: 0.291, h: -2.25, d: -8.78, z: -1.31, l: 0.1 },
                    { p: 0.306, h: -0.90, d: -6.76, z: -7.96, l: 0.1 },
                    { p: 0.321, h: 0.04, d: -2.96, z: -10.53, l: 0.1 },
                    { p: 0.336, h: 0.13, d: -2.88, z: -10.55, l: 0.1 },
                    { p: 0.352, h: 0.00, d: -3.65, z: -10.23, l: 0.1 },
                    { p: 0.367, h: -0.20, d: -4.62, z: -9.72, l: 0.1 },
                    { p: 0.382, h: -0.56, d: -6.23, z: -8.48, l: 0.1 },
                    { p: 0.397, h: -0.82, d: -7.77, z: -6.50, l: 0.1 },
                    { p: 0.413, h: -0.96, d: -8.75, z: -4.10, l: 0.1 },
                    { p: 0.428, h: -1.26, d: -8.97, z: -2.54, l: 0.1 },
                    { p: 0.443, h: -1.64, d: -10.07, z: -4.68, l: 0.1 },
                    { p: 0.458, h: -1.95, d: -9.89, z: -5.07, l: 0.1 },
                    { p: 0.475, h: -1.63, d: -8.93, z: -7.25, l: 0.1 },
                    { p: 0.490, h: -1.34, d: -8.14, z: -8.42, l: 0.1 },

                    // --- STATISCHER HOLD ---
                    { p: 0.650, h: -1.34, d: -8.14, z: -8.42, l: 0.1 },

                    // --- ACTION START (Kapsel & Landung) ---
                    // --- E ACTION (Kapsel & Landung) ---
                    { p: 0.651, h: -1.46, d: -8.40, z: -4.68, l: 0.1 },
                    { p: 0.667, h: -1.47, d: -8.47, z: -4.45, l: 0.1 },
                    { p: 0.683, h: -1.06, d: -8.67, z: -4.01, l: 0.1 },
                    { p: 0.699, h: -1.04, d: -8.99, z: -1.12, l: 0.1 },
                    { p: 0.715, h: -0.19, d: -8.17, z: -5.49, l: 0.1 },
                    { p: 0.731, h: 0.18, d: -7.12, z: -7.21, l: 0.1 },
                    { p: 0.746, h: 0.60, d: -5.82, z: -8.54, l: 0.1 },
                    { p: 0.761, h: 1.60, d: -3.37, z: -10.07, l: 0.1 },
                    { p: 0.776, h: 1.23, d: -2.07, z: -10.56, l: 0.1 },
                    { p: 0.791, h: 1.33, d: -1.67, z: -10.66, l: 0.1 },
                    { p: 0.806, h: 1.32, d: -1.95, z: -10.62, l: 0.1 },
                    { p: 0.822, h: 0.38, d: -3.30, z: -7.27, l: 0.1 },
                    { p: 0.837, h: 0.14, d: -2.76, z: -5.06, l: 0.1 },
                    { p: 0.852, h: -0.21, d: -4.13, z: -2.66, l: 0.1 },
                    { p: 0.867, h: 0.04, d: 0.52, z: 2.26, l: 0.1 },
                    { p: 0.882, h: 0.00, d: 4.43, z: 1.71, l: 0.1 },
                    { p: 0.897, h: 0.47, d: 6.26, z: 1.99, l: 0.1 },
                    { p: 0.912, h: 0.13, d: 5.78, z: 2.69, l: 0.1 },
                    { p: 0.927, h: 0.27, d: 0.40, z: 3.20, l: 0.1 },
                    { p: 0.943, h: 0.07, d: 0.07, z: 1.84, l: 0.1 },
                    { p: 0.958, h: 0.10, d: 0.29, z: 1.82, l: 0.1 },
                    { p: 0.999, h: -0.08, d: 5.89, z: 33.83, l: 0.1 },
                    { p: 0.999, h: -0.08, d: 5.89, z: 33.83, l: 0.1 },
                    { p: 1.000, h: -0.08, d: 6.20, z: 35.71, l: 0.1 },
                ];

                scene.add(this.group);

                // TRICK: Shader "Vorw√§rmen" (Pre-Compile)
                // Wir machen kurz alles sichtbar, damit die GPU es berechnet,
                // aber skalieren es auf 0, damit man es nicht sieht.
                this.meshStage2.visible = true;
                this.debrisBooster.visible = true;
                this.debrisStage2.visible = true;
                this.meshCapsule.visible = true;
                
                // Einmal rendern erzwingen (passiert im n√§chsten Frame automatisch)
                // Wir verstecken sie sofort wieder im update() beim allerersten Aufruf.
                this.needsReset = true;
            }

            // ... (createSmokeTexture und spawnSmoke und updateSmoke bleiben unver√§ndert) ...
            createSmokeTexture() {
                // 1. Aufl√∂sung drastisch erh√∂hen (von 64 auf 512 f√ºr Retina-Displays)
                const size = 512; 
                const canvas = document.createElement('canvas');
                canvas.width = size; 
                canvas.height = size;
                
                const context = canvas.getContext('2d');
                const center = size / 2;
                
                // 2. Verlauf weicher zeichnen
                const gradient = context.createRadialGradient(center, center, 0, center, center, center);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');  // Kern: Wei√ü
                gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.8)'); // Mitte: Stark
                gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.2)'); // Rand: Weich
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');        // Ende: Transparent
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, size, size);
                
                const texture = new THREE.CanvasTexture(canvas);
                
                // 3. WICHTIG: Mipmaps ausschalten!
                // Das verhindert, dass das iPad die Textur "kaputt komprimiert".
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.generateMipmaps = false; 
                
                return texture;
            }

            spawnSmoke(isSpace) {
                // (Dein bestehender Code hier)
                let sourcePos = new THREE.Vector3();
                let activeGlow = null;
                if (this.meshFull.visible) activeGlow = this.engineGlow;
                else if (this.meshStage2.visible) activeGlow = this.engineGlow2;
                else if (this.meshCapsule.visible) activeGlow = this.capsuleEngine;
                if (!activeGlow) return;
                activeGlow.getWorldPosition(sourcePos);
                const material = new THREE.SpriteMaterial({ 
                    map: this.smokeTexture, 
                    color: isSpace ? new THREE.Color(0xdddddd) : new THREE.Color(0x555555),
                    transparent: true, opacity: isSpace ? 0.15 : 0.6, depthWrite: false 
                });
                const particle = new THREE.Sprite(material);
                particle.position.copy(sourcePos);
                const spread = this.effScale * (isSpace ? 0.1 : 0.5); 
                particle.position.add(new THREE.Vector3((Math.random()-0.5)*spread, (Math.random()-0.5)*spread, (Math.random()-0.5)*spread));
                let baseSize = isSpace ? 1.5 : 6.0; 
                let size = baseSize * this.effScale; 
                particle.scale.set(size, size, 1);
                this.smokeGroup.add(particle);
                this.smokeParticles.push({
                    mesh: particle, age: 0, lifetime: isSpace ? 0.5 : 3.0,
                    growth: isSpace ? (0.1 * this.effScale) : (4.0 * this.effScale), 
                    velocity: new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).multiplyScalar(0.01 * SCENE_SCALE)
                });
            }

            updateSmoke(deltaTime) {
               // (Dein bestehender Code hier)
               for (let i = this.smokeParticles.length - 1; i >= 0; i--) {
                    const p = this.smokeParticles[i];
                    p.age += deltaTime;
                    if (p.age >= p.lifetime) {
                        this.smokeGroup.remove(p.mesh);
                        p.mesh.material.dispose();
                        this.smokeParticles.splice(i, 1);
                        continue;
                    }
                    p.mesh.material.opacity *= 0.95; 
                    const currentScale = p.mesh.scale.x + (p.growth * deltaTime);
                    p.mesh.scale.set(currentScale, currentScale, 1);
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(deltaTime));
                }
            }

            launch() {
                if (this.state !== 'ready') return;

                // --- HUD INITIALISIEREN ---
                updateLaunchHUD(true, "SEQUENZ START", "Kamera-Positionierung...", "üé•", 0);

                // --- UI AUFR√ÑUMEN & HELLIGKEIT SETZEN ---
                setLaunchModeUI(true); // Alles ausblenden ausser Rakete & Helligkeit

                // In Rocket.launch():
                const dismissBtn = document.getElementById('rocket-dismiss-btn');
                if (dismissBtn) dismissBtn.style.display = 'none'; // Verstecken beim Start
                //  Abbruch-Button anzeigen
                const abortBtn = document.getElementById('rocket-abort-btn');
                if(abortBtn) abortBtn.style.display = 'block';

                // Helligkeit auf 0.10 setzen
                const dSlider = document.getElementById('darkness-slider');
                const dLabel = document.getElementById('darkness-label');
                if (dSlider) {
                    dSlider.value = 0.10;
                    dSlider.dispatchEvent(new Event('input')); // Trigger f√ºr Shader-Update
                    if (dLabel) dLabel.textContent = "0.10";
                }

                // --- UI AUTOMATISCH MINIMIEREN ---
                const uiContainer = document.getElementById('ui-container');
                const toggleBtn = document.getElementById('toggle-ui');
                if (uiContainer && toggleBtn) {
                    uiContainer.classList.add('minimized');
                    toggleBtn.textContent = '‚ò∞'; // Icon √§ndern
                    toggleBtn.title = 'Men√º anzeigen';
                }

                // 1. Positionierung der Rakete initialisieren
                currentDay = 0.8; 
                const daySlider = document.getElementById('day-slider');
                if (daySlider) { daySlider.value = currentDay; }
                updatePositions(currentDay); 
                this.updatePositionOnEarth();

                // UI: Slider zur√ºcksetzen
                const sSlider = document.getElementById('speed-slider');
                if (sSlider) { sSlider.value = 1; sSlider.dispatchEvent(new Event('input')); }

                // --- E KAMERA LOGIK START ---
                
                // 2. Deine gew√ºnschten Start-Koordinaten
                // { p: 0.001, h: 0.05, d: -8.79, z: 0.38, l: 0.1 }
                const startH = 0.0;
                const startD = -8.79;
                const startZ = -1.5;
                const startL = 0.1;

                
                // 3. Wir berechnen die Welt-Position f√ºr diese Koordinaten exakt so wie im update()-Loop
                // Damit die Kamera EXAKT dort landet, wo die Animation beginnt.
                this.group.updateMatrixWorld(); // Sicherstellen, dass die Matrix aktuell ist
                
                const factor = 15 * SCENE_SCALE * this.effScale * 1.1;
                
                // Vektor-Logik aus deiner update-Funktion: (h, -d, -z)
                const idealOffset = new THREE.Vector3(startH, -startD, -startZ).multiplyScalar(factor); 
                const idealCamPos = idealOffset.applyMatrix4(this.group.matrixWorld);

                // Blick-Ziel berechnen
                const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.group.quaternion).normalize();
                const idealTarget = this.group.position.clone().add(forwardDir.multiplyScalar(startL * SCENE_SCALE));

                // 4. Alles ausblenden f√ºr den Flug
                otherPlanetOrbits.forEach(orbit => orbit.visible = false);
                if (earthOrbitLine) earthOrbitLine.visible = false;
                if (moonOrbitLine) moonOrbitLine.visible = false;
                if (asteroidInstancedMesh) asteroidInstancedMesh.visible = false;
                
                // 5. SANFTER FLUG ZUR STARTRAMPE (Dauer: 3.0 Sekunden)
                // Wir √ºbergeben einen Callback (die Funktion am Ende), die erst feuert, wenn die Kamera da ist.
                flyTo(idealCamPos, idealTarget, 3.0, null, () => {
                    
                    // --- DIESER CODE L√ÑUFT ERST NACH DEM KAMERAFLUG ---
                    
                    this.state = 'countdown';
                    this.timer = 5.0; 

                    // Jetzt schalten wir den Kino-Modus scharf
                    this.isOnboardCamera = true; 
                    controls.enabled = false;

                    // Button UI aktualisieren
                    const camBtn = document.getElementById('rocket-cam-btn');
                    if(camBtn) camBtn.textContent = "üîÑ Freie Ansicht";
                    
                    // Raketen-Daten initialisieren
                    const earthPos = new THREE.Vector3(); earth.getWorldPosition(earthPos);
                    this.startRelPos.subVectors(this.group.position, earthPos);
                    this.startY = this.startRelPos.y;
                    this.startAngle = Math.atan2(this.startRelPos.z, this.startRelPos.x);
                    this.startRadius = Math.hypot(this.startRelPos.x, this.startRelPos.z); 

                    // Fokus "Dummy" setzen, damit die OrbitControls nicht verwirrt sind
                    cameraFocus = this.group; 
                });
                // --- E KAMERA LOGIK ENDE ---
            }
            
            // ... (updatePositionOnEarth und calculateTrajectory bleiben unver√§ndert) ...
            updatePositionOnEarth() {
                if (!earth || !sun) return;
                const earthPos = new THREE.Vector3(); earth.getWorldPosition(earthPos);
                const sunPos = new THREE.Vector3(); sun.getWorldPosition(sunPos);
                const dir = new THREE.Vector3().subVectors(sunPos, earthPos).normalize();
                dir.y += 0.3; dir.normalize(); 
                const finalPos = earthPos.clone().add(dir.multiplyScalar(EARTH_RADIUS));
                this.group.position.copy(finalPos);
                this.group.lookAt(finalPos.clone().add(dir));
            }

            calculateTrajectory(p) {
                 // (Dein bestehender Code, exakt wie vorher)
                 const earthPos = new THREE.Vector3(); earth.getWorldPosition(earthPos);
                if (p < this.VERTICAL_PHASE_END) {
                    const localP = p / this.VERTICAL_PHASE_END;
                    const riseP = localP * localP; 
                    const currentR = this.startRadius + (this.VERTICAL_HEIGHT_TARGET * riseP * 0.5);
                    const currentAngle = this.startAngle; 
                    const x = Math.cos(currentAngle) * currentR;
                    const z = Math.sin(currentAngle) * currentR;
                    return new THREE.Vector3(x, this.startY, z).add(earthPos);
                } else if (p < this.TRANS_LUNAR_INJECTION_START) {
                    const sectionDuration = this.TRANS_LUNAR_INJECTION_START - this.VERTICAL_PHASE_END;
                    const localP = (p - this.VERTICAL_PHASE_END) / sectionDuration;
                    const startR = this.startRadius + (this.VERTICAL_HEIGHT_TARGET * 0.5);
                    const endR = this.startRadius + this.ORBIT_HEIGHT_ADD;
                    const currentR = THREE.MathUtils.lerp(startR, endR, Math.sin(localP * Math.PI / 2));
                    const orbitEndAngle = this.startAngle + this.ORBIT_ROTATIONS;
                    const angleP = 1.0 - Math.cos((localP * Math.PI) / 2); 
                    const currentAngle = THREE.MathUtils.lerp(this.startAngle, orbitEndAngle, angleP);
                    const x = Math.cos(currentAngle) * currentR;
                    const z = Math.sin(currentAngle) * currentR;
                    return new THREE.Vector3(x, this.startY, z).add(earthPos);
                } else {
                    const sectionDuration = 1.0 - this.TRANS_LUNAR_INJECTION_START;
                    const localP = (p - this.TRANS_LUNAR_INJECTION_START) / sectionDuration;
                    const orbitEndAngle = this.startAngle + this.ORBIT_ROTATIONS;
                    const orbitR = this.startRadius + this.ORBIT_HEIGHT_ADD;
                    const startVec = new THREE.Vector3(
                        Math.cos(orbitEndAngle) * orbitR, 
                        this.startY, 
                        Math.sin(orbitEndAngle) * orbitR
                    ).add(earthPos);
                    const moonPos = new THREE.Vector3(); 
                    moon.getWorldPosition(moonPos);
                    const vecEarthToMoon = new THREE.Vector3().subVectors(moonPos, earthPos).normalize();
                    const targetPos = earthPos.clone().add(vecEarthToMoon.multiplyScalar(moonPos.distanceTo(earthPos) - (MOON_RADIUS * 1.05))); 
                    const pos = new THREE.Vector3().lerpVectors(startVec, targetPos, localP);
                    const curveIntensity = 5.0 * SCENE_SCALE * Math.sin(localP * Math.PI); 
                    const flightDir = new THREE.Vector3().subVectors(targetPos, startVec).normalize();
                    const up = new THREE.Vector3(0, 1, 0);
                    const side = new THREE.Vector3().crossVectors(flightDir, up).normalize();
                    pos.add(side.multiplyScalar(curveIntensity));
                    return pos;
                }
            }

            // ---  Funktion zum Umschalten der Kamera ---
            // ---  Funktion zum Umschalten der Kamera ---
            toggleOnboardCamera() {
                this.isOnboardCamera = !this.isOnboardCamera;
                const btn = document.getElementById('rocket-cam-btn');
                
                if (this.isOnboardCamera) {
                    // Modus AN: Button Text √§ndern
                    if(btn) btn.textContent = "üîÑ Zur√ºck zur freien Ansicht";
                    // Benutzersteuerung deaktivieren
                    controls.enabled = false;
                } else {
                    // Modus AUS: Button Text √§ndern
                    if(btn) btn.textContent = "üé• Kino-Modus";
                    // Benutzersteuerung wieder an
                    controls.enabled = true;
                    
                    // Fokus zur√ºcksetzen auf Rakete
                    setFocus(this.group, 0); 

                    // --- FIX: Bahnen SOFORT wieder ausblenden ---
                    // Weil setFocus() sie automatisch einschaltet, m√ºssen wir sie hier
                    // zwingend wieder verstecken, solange die Rakete fliegt.
                    otherPlanetOrbits.forEach(orbit => orbit.visible = false);
                    if (earthOrbitLine) earthOrbitLine.visible = false;
                    if (moonOrbitLine) moonOrbitLine.visible = false;
                    if (asteroidInstancedMesh) asteroidInstancedMesh.visible = false;
                    // --------------------------------------------
                }
            }
            // -----------------------------------------------

            update(deltaTime) {

                if (this.needsReset) {
                    this.meshStage2.visible = false;
                    this.debrisBooster.visible = false;
                    this.debrisStage2.visible = false;
                    this.meshCapsule.visible = false;
                    this.needsReset = false;
                }
                
                this.updateSmoke(deltaTime);

                if (this.state === 'ready') { return false; }
                
                // Countdown...
                if (this.state === 'countdown') {
                    this.timer -= deltaTime;

                    //HUD countdown
                    // Wir zeigen T- Minus an
                    updateLaunchHUD(true, "T-MINUS", `T- ${this.timer.toFixed(1)} Sekunden`, "‚è±Ô∏è", (1.0 - (this.timer/5.0))*100);
                    
                    // (Wackeln Logik hier...)
                    if (this.timer < 2.0 && this.timer > 0) {
                        const intensity = (2.0 - this.timer) * 0.002 * SCENE_SCALE; 
                        const x = (Math.random() - 0.5) * intensity;
                        const y = (Math.random() - 0.5) * intensity;
                        const z = (Math.random() - 0.5) * intensity;
                        this.shakerContainer.position.set(x, y, z);
                        this.visualCapsule.position.set(x, y, z); 
                    } else {
                        this.shakerContainer.position.set(0, 0, 0);
                        this.visualCapsule.position.set(0, 0, 0);
                    }
                    const statusEl = document.getElementById('rocket-status');
                    if (statusEl) statusEl.textContent = `T- ${this.timer.toFixed(1)} s`;
                    if (this.timer < 1.5) { this.spawnSmoke(false); }
                    if (this.timer <= 0) {
                        this.state = 'flying';
                        if (statusEl) statusEl.textContent = "LIFTOFF!";
                    }
                    return false;
                }

                if (this.state === 'flying') {
                    // ... (Wackel-Logik und Speed-Logik bleiben gleich) ...
                    // Kopiere bitte deine vorhandene Logik f√ºr "wobbleEnd" und "currentSpeedFactor" hier hin.
                    const wobbleEnd = 0.25; 
                    if (this.rawProgress < wobbleEnd) {
                        const fade = 1.0 - (this.rawProgress / wobbleEnd);
                        const intensity = 0.002 * SCENE_SCALE * fade;
                        const x = (Math.random() - 0.5) * intensity;
                        const y = (Math.random() - 0.5) * intensity;
                        const z = (Math.random() - 0.5) * intensity;
                        this.shakerContainer.position.set(x, y, z);
                        this.visualCapsule.position.set(x, y, z);
                    } else {
                        this.shakerContainer.position.set(0, 0, 0);
                        this.visualCapsule.position.set(0, 0, 0);
                    }

                    let currentSpeedFactor = this.launchSpeed;
                    const accelStart = 0.30; 
                    const accelEnd = this.TRANS_LUNAR_INJECTION_START;
                    
                    if (this.rawProgress >= accelEnd) {
                        // Phase: Flug zum Mond (Coast Phase)
                        currentSpeedFactor = this.moonCruiseSpeed;

                        // ---  Abbrems-Man√∂ver (Landeanflug verl√§ngern) ---
                        // Wir definieren, wann die "letzte Phase" beginnt (hier ab 85%)
                        const landingPhaseStart = 0.70; 

                        if (this.rawProgress > landingPhaseStart) {
                            // Berechne, wie weit wir in der Landung sind (0.0 bis 1.0)
                            const t = (this.rawProgress - landingPhaseStart) / (1.0 - landingPhaseStart);
                            
                            // Wir bremsen sanft von voller Geschwindigkeit (moonCruiseSpeed)
                            // auf sehr langsame 5% (0.05) herunter.
                            // Je kleiner die zweite Zahl, desto l√§nger dauert das Ende.
                            currentSpeedFactor = THREE.MathUtils.lerp(this.moonCruiseSpeed, this.moonCruiseSpeed * 0.05, t);
                        }
                        // -----------------------------------------------------

                    } else if (this.rawProgress > accelStart) {
                        // (Dein bestehender Beschleunigungs-Code mit Cubic Ease Out)
                        let t = (this.rawProgress - accelStart) / (accelEnd - accelStart);
                        t = 1.0 - Math.pow(1.0 - t, 3); 
                        currentSpeedFactor = this.launchSpeed + (this.moonCruiseSpeed - this.launchSpeed) * t;
                    }
                    
                    this.rawProgress += (deltaTime / this.TOTAL_FLIGHT_TIME) * currentSpeedFactor;

                    // HUD updates
                    const pct = this.rawProgress * 100;
                    
                    // Nur Text updaten, wenn kein spezielles Event ist (um Flackern zu vermeiden, einfache Logik)
                    // Wir definieren Events anhand des Fortschritts (p)
                    const p = this.rawProgress;

                    if (p < 0.15) {
                        // Startphase (Geht von 0.0 bis 0.15)
                        // Wir rechnen das auf 0-100% f√ºr diese Phase um
                        const phasePercent = (p / 0.15) * 100;
                        
                        // Nutzung von phasePercent statt pct f√ºr Text und Balken
                        updateLaunchHUD(true, "MAXIMALER SCHUB", `H√∂he gewinnen... (${phasePercent.toFixed(0)}%)`, "üî•", phasePercent);
                    } 
                    else if (p >= 0.15 && p < 0.18) {
                        // Stufe 1 Trennung (Kurz anzeigen)
                        updateLaunchHUD(true, "STUFENTRENNUNG", "Booster abgeworfen", "‚õìÔ∏è‚Äçüí•", 100);
                    }
                    else if (p >= 0.18 && p < 0.40) {
                        // Orbit Phase
                        updateLaunchHUD(true, "ORBIT ERREICHT", "Parkbahn um die Erde", "üåç", pct);
                    }
                    else if (p >= 0.40 && p < 0.75) {
                        // TLI (Trans Lunar Injection) - Flug zum Mond
                        updateLaunchHUD(true, "TLI MAN√ñVER", "Reise zum Mond l√§uft", "üåå", pct);
                    }
                    else if (p >= 0.75 && p < 0.80) {
                        // Stufe 2 Trennung / Kapsel
                        updateLaunchHUD(true, "KAPSEL SEPARATION", "Landeanflug initiiert", "üõ∞Ô∏è", pct);
                    }
                    else if (p >= 0.80) {
                        // Landung
                        updateLaunchHUD(true, "LANDESSEQUENZ", "Bremsman√∂ver aktiv", "üåñ", pct);
                    }
                    // -------------------------------------------

                    if (this.rawProgress >= 1.0) { this.finish(); return true; }


                    const newPos = this.calculateTrajectory(p);
                    this.group.position.copy(newPos);
                    
                    const futureP = Math.min(1.0, p + 0.01); 
                    const lookTarget = this.calculateTrajectory(futureP);
                    
                    const dummy = new THREE.Object3D();
                    dummy.position.copy(this.group.position);

                    // --- FIX: Ausrichtung parallel zur Erdoberfl√§che ---
                    
                    // 1. Wir holen uns die Position der Erde
                    const earthPos = new THREE.Vector3();
                    earth.getWorldPosition(earthPos);

                    // 2. Wir berechnen den Vektor vom Erdmittelpunkt zur Rakete (Das ist "Oben")
                    const upVector = new THREE.Vector3().subVectors(this.group.position, earthPos).normalize();

                    // 3. Wir zwingen das Dummy-Objekt, diesen Vektor als "Oben" zu nutzen
                    dummy.up.copy(upVector);

                    // 4. Jetzt schauen wir zum Ziel. Three.js berechnet die Rotation nun so,
                    // dass die Nase zum Ziel zeigt, aber der "Bauch" zur Erde.
                    dummy.lookAt(lookTarget);
                    
                    // ---------------------------------------------------

                    this.group.quaternion.slerp(dummy.quaternion, 0.1); 

                    // ---  Button einblenden, wenn Orbit erreicht (VERTICAL_PHASE_END) ---
                    if (p > this.VERTICAL_PHASE_END && !this.camButtonVisible) {
                        this.camButtonVisible = true;
                        const btn = document.getElementById('rocket-cam-btn');
                        if(btn) btn.style.display = 'block';

                        // Automatisch in die Bordkamera schalten!
                        
                        //Auto Boardkamera
                        //if (!this.isOnboardCamera) {
                        //    this.toggleOnboardCamera();
                        //}
                    }

                    // --- KINO-MODUS (Wiedergabe der Aufnahme) ---
                    if (this.isOnboardCamera) {
                        
                        const prog = this.rawProgress;
                        const frames = this.cinematicKeyframes;
                        
                        // 1. Die passenden Keyframes finden (Davor und Danach)
                        let nextIdx = frames.findIndex(k => k.p >= prog);
                        
                        // Sicherheits-Checks
                        if (nextIdx === -1) nextIdx = frames.length - 1; 
                        let prevIdx = Math.max(0, nextIdx - 1);

                        const prevKey = frames[prevIdx];
                        const nextKey = frames[nextIdx];

                        // 2. Wie weit sind wir zwischen den beiden Punkten? (0.0 bis 1.0)
                        let localT = 0;
                        const range = nextKey.p - prevKey.p;
                        if (range > 0.00001) {
                            localT = (prog - prevKey.p) / range;
                        }

                        // 3. Smoothing: Macht Ecken rund
                        localT = THREE.MathUtils.smoothstep(localT, 0.0, 1.0);

                        // 4. Interpolation (Zwischenwerte berechnen)
                        const currentH = THREE.MathUtils.lerp(prevKey.h, nextKey.h, localT);
                        const currentD = THREE.MathUtils.lerp(prevKey.d, nextKey.d, localT);
                        const currentZ = THREE.MathUtils.lerp(prevKey.z, nextKey.z, localT);
                        const currentL = THREE.MathUtils.lerp(prevKey.l, nextKey.l, localT);

                        // 5. Anwendung auf die Kamera
                        // ZIEL-POSITION BERECHNEN (Wo die Kamera sein SOLL)
                        const factor = 15 * SCENE_SCALE * this.effScale * 1.1;
                        const idealOffset = new THREE.Vector3(currentH, -currentD, -currentZ).multiplyScalar(factor); 
                        const idealCamPos = idealOffset.applyMatrix4(this.group.matrixWorld);

                        // ZIEL-BLICKPUNKT BERECHNEN (Wohin sie schauen SOLL)
                        const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.group.quaternion).normalize();
                        const idealTarget = this.group.position.clone();
                        idealTarget.add(forwardDir.multiplyScalar(currentL * SCENE_SCALE));

                        // 7. D√ÑMPFUNG (Das "Smooth"-Geheimnis)
                        // Statt die Position hart zu setzen (copy), n√§hern wir uns ihr an (lerp).
                        const smoothness = deltaTime * 0.75; 

                        camera.position.lerp(idealCamPos, smoothness);
                        controls.target.lerp(idealTarget, smoothness);
                        
                        // Wichtig: Nach dem Bewegen die Kamera  ausrichten
                        camera.lookAt(controls.target);
                    }
                    
                    

                    // Stufentrennung 
                    const STAGE_1_POINT = 0.15; 
                    if (p > STAGE_1_POINT && !this.hasStaged1) {
                        this.hasStaged1 = true;
                        this.meshFull.visible = false;
                        this.meshStage2.visible = true;
                        this.debrisBooster.visible = true; 
                        for(let k=0; k<5; k++) this.spawnSmoke(false);
                        if (document.getElementById('rocket-status')) document.getElementById('rocket-status').textContent = "Stufentrennung 1 (Booster)";
                    }
                    const STAGE_2_POINT = this.TRANS_LUNAR_INJECTION_START;
                    if (p > STAGE_2_POINT && !this.hasStaged2) {
                        this.hasStaged2 = true;
                        this.meshStage2.visible = false;
                        this.meshCapsule.visible = true;
                        this.debrisStage2.visible = true; 
                        for(let k=0; k<8; k++) this.spawnSmoke(true);
                        if (document.getElementById('rocket-status')) document.getElementById('rocket-status').textContent = "TLI - Kapsel separiert";
                    }
                    // ... (Debris Animation Code wie gehabt) ...
                     if (this.debrisBooster.visible) {
                        this.debrisBooster.position.z -= deltaTime * 0.5 * SCENE_SCALE;
                        this.debrisBooster.rotation.x += deltaTime;
                        this.debrisBooster.scale.multiplyScalar(0.98); 
                        if (this.debrisBooster.scale.x < 0.001) this.debrisBooster.visible = false;
                    }
                    if (this.debrisStage2.visible) {
                        this.debrisStage2.position.z -= deltaTime * 0.3 * SCENE_SCALE;
                        this.debrisStage2.rotation.z += deltaTime * 0.5;
                        this.debrisStage2.scale.multiplyScalar(0.99);
                        if (this.debrisStage2.scale.x < 0.001) this.debrisStage2.visible = false;
                    }
                    // Status Text Update (bleibt gleich)
                    const statusEl = document.getElementById('rocket-status');
                    if (statusEl && !this.hasStaged1 && p < STAGE_1_POINT) {
                        if (p < this.VERTICAL_PHASE_END) statusEl.textContent = `Vertikaler Aufstieg... ${(p/this.VERTICAL_PHASE_END*100).toFixed(0)}%`;
                        else statusEl.textContent = "Gravity Turn (Neigung)...";
                    }
                    if (p < 0.2 || (p > this.TRANS_LUNAR_INJECTION_START && p < 0.6)) {
                         this.spawnSmoke(p > 0.2);
                    }
                }

            // --- RECORDER V3 (Mit automatischem Orbit-Hold) ---
            // Nur aktiv, wenn du "Freie Ansicht" hast (also manuell fliegst)
            if (!this.isOnboardCamera && this.state === 'flying') {
                
                if (!this.debugTimer) this.debugTimer = 0;
                this.debugTimer += deltaTime;

                // Aufnahme-Frequenz
                if (this.debugTimer > 0.15) {
                    this.debugTimer = 0;

                    // === HOLD ZONE DEFINIEREN ===
                    // Start: Kurz nach Booster-Abwurf (0.15) -> wir nehmen 0.20
                    // Ende: Kurz vor Mond-Schuss (0.75) -> wir nehmen 0.70
                    const holdStart = 0.50;
                    const holdEnd = 0.65;

                    // Wenn wir in der Hold-Zone sind -> NICHTS TUN
                    if (this.rawProgress > holdStart && this.rawProgress < holdEnd) {
                        if (!this.hasLoggedHold) {
                            console.log(`// --- HOLD START (Kamera friert ein) ---`);
                            this.hasLoggedHold = true;
                        }
                        return; 
                    }
                    
                    if (this.rawProgress >= holdEnd) {
                        if (this.hasLoggedHold) {
                            console.log(`// --- HOLD ENDE (Action!) ---`);
                            this.hasLoggedHold = false;
                        }
                    }

                    // --- WERTE BERECHNEN ---
                    const factor = 15 * SCENE_SCALE * this.effScale * 1.1;

                    let localPos = camera.position.clone().sub(this.group.position);
                    localPos.applyQuaternion(this.group.quaternion.clone().invert());

                    const h = (localPos.x / factor).toFixed(2);
                    const d = (-(localPos.y / factor)).toFixed(2);
                    const z = (-(localPos.z / factor)).toFixed(2);

                    let localTarget = controls.target.clone().sub(this.group.position);
                    localTarget.applyQuaternion(this.group.quaternion.clone().invert());
                    const l = (localTarget.z / SCENE_SCALE).toFixed(1);
                    
                    const prog = this.rawProgress.toFixed(3);

                    console.log(`{ p: ${prog}, h: ${h}, d: ${d}, z: ${z}, l: ${l} },`);
                }
            }
                return false;
            }

            finish() {
                this.state = 'landed';
                hasMoonMissionLanded = true;

                if (typeof moonSurfaceObjects !== 'undefined') {
                    moonSurfaceObjects.forEach(obj => {
                        obj.visible = true; // Tadaaa! Sie sind da.
                    });
                }

                // --- NEU: ERFOLGSMELDUNG ---
                updateLaunchHUD(true, "THE EAGLE HAS LANDED", "Mission erfolgreich beendet.", "ü¶Ö", 100);
                
                // Nach 5 Sekunden ausblenden
                setTimeout(() => updateLaunchHUD(false), 6000);
                // ---------------------------

                document.getElementById('rocket-status').textContent = "Mondlandung erfolgreich.";
                const index = clickableObjects.indexOf(this.group); 
                if (index > -1) clickableObjects.splice(index, 1);
                // Bevor du remove machst:
                disposeObject(this.group);       // <--- NEU: Speicher freigeben
                disposeObject(this.smokeGroup);  // <--- NEU: Auch den Rauch l√∂schen
                this.scene.remove(this.group); 
                this.scene.remove(this.smokeGroup);
                
                rocketSpawnAllowed = false;
                // --- UI WIEDERHERSTELLEN ---
                setLaunchModeUI(false); // Alle anderen Men√ºs wieder anzeigen

                document.getElementById('rocket-controls').style.display = 'none';
                
                //  Abbruch-Button verstecken
                const abortBtn = document.getElementById('rocket-abort-btn');
                if(abortBtn) abortBtn.style.display = 'none';

                // --- UI WIEDER AUFKLAPPEN ---
                const uiContainer = document.getElementById('ui-container');
                const toggleBtn = document.getElementById('toggle-ui');
                if (uiContainer && toggleBtn) {
                    uiContainer.classList.remove('minimized');
                    toggleBtn.textContent = '‚úï'; // Icon zur√ºcksetzen
                    toggleBtn.title = 'Men√º verbergen';
                }

                // ---  Kamera Button verstecken & Kamera Reset ---
                const btn = document.getElementById('rocket-cam-btn');
                if(btn) {
                    btn.style.display = 'none';
                    btn.textContent = "üé• Bordkamera aktivieren"; // Reset Text
                }
                this.isOnboardCamera = false;
                controls.enabled = true; 
                // ---------------------------------------------------
                
                setFocus(moon, 2.0); 

                // (Wiederherstellungslogik f√ºr Checkboxen wie im vorherigen Schritt...)
                const planetsOrbitCb = document.getElementById('planets-orbit-checkbox');
                const showPlanetsOrbit = planetsOrbitCb ? planetsOrbitCb.checked : true;
                otherPlanetOrbits.forEach(orbit => orbit.visible = showPlanetsOrbit);
                const earthOrbitCb = document.getElementById('orbit-checkbox');
                const showEarthOrbit = earthOrbitCb ? earthOrbitCb.checked : true;
                if (earthOrbitLine) earthOrbitLine.visible = showEarthOrbit;
                if (moonOrbitLine) moonOrbitLine.visible = showEarthOrbit;
                const asteroidsCb = document.getElementById('asteroids-checkbox');
                const showAsteroids = asteroidsCb ? asteroidsCb.checked : false; 
                if (asteroidInstancedMesh) asteroidInstancedMesh.visible = showAsteroids;
            }

            abort() {

                // --- NEU: HUD AUSBLENDEN ---
                updateLaunchHUD(true, "SYSTEM CHECK", "Warte auf Startfreigabe...", "‚è±Ô∏è", 0);
                // ---------------------------

                // 1. Status setzen
                this.state = 'aborted';
                hasMoonMissionLanded = false;
    
                // Objekte wieder verstecken!
                if (typeof moonSurfaceObjects !== 'undefined') {
                    moonSurfaceObjects.forEach(obj => {
                        obj.visible = false;
                    });
                }
                document.getElementById('rocket-status').textContent = "Mission abgebrochen.";

                // 2. Objekte entfernen
                const index = clickableObjects.indexOf(this.group); 
                if (index > -1) clickableObjects.splice(index, 1);
                // Bevor du remove machst:
                disposeObject(this.group);       // <--- NEU: Speicher freigeben
                disposeObject(this.smokeGroup);  // <--- NEU: Auch den Rauch l√∂schen
                this.scene.remove(this.group); 
                this.scene.remove(this.smokeGroup);

                // In Rocket.finish() und Rocket.abort():
                const dismissBtn = document.getElementById('rocket-dismiss-btn');
                if (dismissBtn) dismissBtn.style.display = 'block'; // Wieder da f√ºr n√§chstes Mal

                // 3. UI Wiederherstellen (Ganz wichtig!)
                setLaunchModeUI(false); 

                // 4. Raketen-UI zur√ºcksetzen
                const launchBtn = document.getElementById('launch-rocket-btn');
                if (launchBtn) {
                    launchBtn.disabled = false;
                    launchBtn.textContent = "üöÄ Raketenstart verf√ºgbar!";
                    launchBtn.classList.add('btn-pulse');
                }
                
                const abortBtn = document.getElementById('rocket-abort-btn');
                if (abortBtn) abortBtn.style.display = 'none';

                const camBtn = document.getElementById('rocket-cam-btn');
                if(camBtn) {
                    camBtn.style.display = 'none';
                    camBtn.textContent = "üé• Bordkamera aktivieren";
                }

                // 5. Kamera zur√ºcksetzen
                this.isOnboardCamera = false;
                controls.enabled = true; 
                
                // Fokus zur√ºck zur Erde (oder Sonne), damit man nicht im Leeren h√§ngt
                setFocus(earth, 1.5); 

                // 6. Bahnen wieder anzeigen (gleiche Logik wie bei finish)
                const planetsOrbitCb = document.getElementById('planets-orbit-checkbox');
                const showPlanetsOrbit = planetsOrbitCb ? planetsOrbitCb.checked : true;
                otherPlanetOrbits.forEach(orbit => orbit.visible = showPlanetsOrbit);
                
                const earthOrbitCb = document.getElementById('orbit-checkbox');
                const showEarthOrbit = earthOrbitCb ? earthOrbitCb.checked : true;
                if (earthOrbitLine) earthOrbitLine.visible = showEarthOrbit;
                if (moonOrbitLine) moonOrbitLine.visible = showEarthOrbit;
                
                const asteroidsCb = document.getElementById('asteroids-checkbox');
                if (asteroidInstancedMesh) asteroidInstancedMesh.visible = (asteroidsCb && asteroidsCb.checked);
            }


        }
        
        //  DOM-Elemente 
        const container = document.getElementById('container');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const speedSlider = document.getElementById('speed-slider');
        const orbitCheckbox = document.getElementById('orbit-checkbox');
        const infoBox = document.getElementById('info-box');
        
        const planetsVisibleCheckbox = document.getElementById('planets-visible-checkbox');
        const planetsOrbitCheckbox = document.getElementById('planets-orbit-checkbox');
        const planetFocusContainer = document.getElementById('planet-focus-buttons');

        const darknessSlider = document.getElementById('darkness-slider');
        const darknessLabel = document.getElementById('darkness-label');

        const demoButtons = document.getElementById('demo-buttons');
        const demoControlButtons = document.getElementById('demo-control-buttons');
        const endDemoBtn = document.getElementById('end-demo-btn');
        const demoSpeedControl = document.getElementById('demo-speed-control');
        const demoSpeedSlider = document.getElementById('demo-speed-slider');
        const demoSpeedLabel = document.getElementById('demo-speed-label');
        
        const earthVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            void main() {
                vUv = uv;
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const earthFragmentShader = `
            uniform sampler2D dayTexture;
            uniform sampler2D nightTexture; 
            uniform bool uHasNightTexture;
            uniform vec3 uSunPosition;
            uniform vec3 uObjectWorldPosition;
            uniform float uNightBrightness;
            uniform bool uSofiDemoActive;
            uniform vec3 uMoonPosition;
            uniform float uMoonRadius;
            uniform float uSunRadius;
            /*   F√úR JUPITERMONDE  */
            uniform bool uCastMoonShadows;
            uniform vec3 uMoonPositions[4]; /* Array f√ºr 4 Mondpositionen */
            uniform float uMoonRadii[4];   /* Array f√ºr 4 Mondradien */
            /*  ENDE   */
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            float calculateMoonShadowIntensity(vec3 pixelPos, vec3 moonPos, float moonRadius, vec3 sunPos, float sunRadius) {
                vec3 sunToMoon = moonPos - sunPos;
                vec3 shadowAxis = normalize(sunToMoon);
                vec3 sunToPixel = pixelPos - sunPos;
                float depthInShadow = dot(sunToPixel, shadowAxis);
                if (depthInShadow < 0.0) return 1.0; 
                vec3 closestPointOnAxis = sunPos + shadowAxis * depthInShadow;
                float pixelDistanceToAxis = distance(pixelPos, closestPointOnAxis);
                float umbraRadius = moonRadius * 0.1;
                float penumbraRadius = moonRadius * 1.0; 
                if (pixelDistanceToAxis > penumbraRadius) return 1.0;
                if (pixelDistanceToAxis < umbraRadius) return 0.0;
                float progress = (pixelDistanceToAxis - umbraRadius) / (penumbraRadius - umbraRadius);
                return mix(0.4, 0.9, progress);
            }
            void main() {
                vec3 objectToSun = normalize(uSunPosition - uObjectWorldPosition);
                vec3 objectToFragment = normalize(vWorldPosition - uObjectWorldPosition);
                float intensity = (dot(objectToFragment, objectToSun) + 1.0) / 2.0;
                
                float nightBrightness = uNightBrightness; // Slider-Wert 0.0 bis 0.9
                float lightMix = smoothstep(0.48, 0.59, intensity);
                vec4 dayColor = texture2D(dayTexture, vUv);
                
                /*  HIER STARTET DIE √ÑNDERUNG  */
                
                vec4 finalColor; // Deklaration vorziehen

                if (uHasNightTexture) {
                    // 1. () Tag/Nacht-√úbergang nur f√ºr LICHTER (Nur f√ºr Erde)
                    float lightsFade = smoothstep(0.43, 0.53, intensity); // 0.0 = Lichter an, 1.0 = Lichter aus

                    // 3. Texturen laden
                    vec4 nightMapColor = texture2D(nightTexture, vUv);

                    // 4. Hintergrund (Land/Meer) berechnen
                    vec4 ambientBackground = dayColor * nightBrightness; 

                    // 5. () Lichter berechnen (mit Slider UND hartem Fade)
                    float lightIntensity = 1.0 - nightBrightness;
                    vec4 cityLights = nightMapColor * lightIntensity * (1.0 - lightsFade);

                    // 6. Lichter-Maske (f√ºr "echt schwarz")
                    float lightMask = smoothstep(0.1, 0.3, nightMapColor.r);

                    // 7. Nacht-Textur zusammensetzen
                    vec4 nightColor = mix(ambientBackground, cityLights, lightMask);
                    
                    // 8. Die fertige Nachtfarbe mit der Tagfarbe mischen
                    finalColor = mix(nightColor, dayColor, lightMix);
                    
                } else {
                    // EINFACHE LOGIK F√úR ALLE ANDEREN PLANETEN
                    // (keine Lichter, nur Abdunkeln)
                    vec4 nightColor = dayColor * nightBrightness;
                    finalColor = mix(nightColor, dayColor, lightMix);
                }
                
                /*  HIER ENDET DIE √ÑNDERUNG  */

            
                
                // 9. (Unver√§ndert) Sonnenfinsternis-Schatten
                if (uSofiDemoActive) {
                    if (intensity > 0.01) { 
                        float moonShadowIntensity = calculateMoonShadowIntensity(vWorldPosition, uMoonPosition, uMoonRadius, uSunPosition, uSunRadius);
                        finalColor.rgb *= moonShadowIntensity;
                    }
                }

                /*  Jupitermond-Schatten  */
                if (uCastMoonShadows) {
                    float moonShadowIntensity = 1.0;
                    
                    /* Wende den Schatten f√ºr jeden der 4 Monde an */
                    for(int i = 0; i < 4; i++) {
                        if (uMoonRadii[i] > 0.0) {
                            
                            /*  KORREKTUR 2: Korrekte Tiefenberechnung  */
                            vec3 sunToMoon = uMoonPositions[i] - uSunPosition;
                            float moonDepth = length(sunToMoon);      // : Echte Distanz Sonne -> Mond
                            vec3 shadowAxis = sunToMoon / moonDepth;  // : Normalisieren √ºber Distanz
                            
                            vec3 sunToPixel = vWorldPosition - uSunPosition;
                            float pixelDepth = dot(sunToPixel, shadowAxis); // : Echte Distanz Sonne -> Pixel (projiziert)
                            
                            /* * ALT WAR: if (depthInShadow > 0.0) { ... } 
                             * (depthInShadow war pixelDepth, aber der Check war falsch)
                             */
                            
                            // : Pr√ºfen, ob der Pixel HINTER dem Mond ist (Sonne -> Mond -> Pixel)
                            if (pixelDepth > moonDepth) { 
                            
                                // ALT WAR: vec3 closestPointOnAxis = uSunPosition + shadowAxis * depthInShadow;
                                vec3 closestPointOnAxis = uSunPosition + shadowAxis * pixelDepth; // : pixelDepth verwenden
                                float pixelDistanceToAxis = distance(vWorldPosition, closestPointOnAxis);
                                
                                /*  KORREKTUR 1: Sch√§rfere Schatten  */
                                // Wir setzen Umbra und Penumbra fast gleich f√ºr eine harte Kante
                                float umbraRadius = uMoonRadii[i] * 0.9;    // WAR: 0.4
                                float penumbraRadius = uMoonRadii[i] * 1.1; // WAR: 2.0 

                                if (pixelDistanceToAxis < penumbraRadius) {
                                    if (pixelDistanceToAxis < umbraRadius) {
                                        // Wir machen den Kernschatten auch dunkler
                                        moonShadowIntensity *= 0.3; // WAR: 0.6 
                                    } else {
                                        float progress = (pixelDistanceToAxis - umbraRadius) / (penumbraRadius - umbraRadius);
                                        moonShadowIntensity *= mix(0.3, 1.0, progress); // WAR: 0.6
                                    }
                                }
                            }
                            /*  ENDE KORREKTUR 2  */
                        }
                    }
                    
                    /* Schatten nur auf der Tagseite anwenden */
                    if (intensity > 0.48) { /* 0.48 ist der Start der "lightMix" */
                         finalColor.rgb *= moonShadowIntensity;
                    }
                }
                /*  ENDE   */

                gl_FragColor = finalColor;
            }
        `;

        // NEU: Vertex Shader f√ºr Objekte auf der Oberfl√§che
        const surfaceObjectVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;
            void main() {
                vUv = uv;
                // Normale in Weltkoordinaten umrechnen (wichtig f√ºr Lichtberechnung bei Rotation)
                vNormal = normalize(mat3(modelMatrix) * normal);
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPos.xyz;
                gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
        `;

        // NEU: Fragment Shader (Repariert f√ºr Lander & Slider)
        const surfaceObjectFragmentShader = `
            uniform sampler2D map;
            uniform vec3 uColor;
            uniform bool uHasTexture;
            uniform vec3 uSunPosition;
            uniform vec3 uMoonCenter;        // NEU: Position des Mond-Mittelpunkts
            uniform float uNightBrightness;  // Slider Wert
            uniform float uDirectSunIntensity;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;

            void main() {
                // 1. Textur oder Farbe laden
                vec4 texColor = vec4(1.0, 1.0, 1.0, 1.0);
                if (uHasTexture) {
                    texColor = texture2D(map, vUv);
                }
                vec3 baseColor = texColor.rgb * uColor;

                // 2. Wo ist die Sonne?
                vec3 sunDir = normalize(uSunPosition - vWorldPosition);

                // 3. GLOBALE TAG/NACHT ERKENNUNG
                // Wir berechnen den Vektor vom Mond-Kern zur Oberfl√§che (das ist "Oben")
                vec3 surfaceUp = normalize(vWorldPosition - uMoonCenter);
                
                // Zeigt der Boden an dieser Stelle zur Sonne? (1 = Mittag, 0 = D√§mmerung, -1 = Mitternacht)
                float globalDayFactor = dot(surfaceUp, sunDir);
                
                // Weicher √úbergang (Terminator), damit es nicht flackert
                // 0.0 bis 1.0 (0 = Nachtseite, 1 = Tagseite)
                float isDaySide = smoothstep(-0.2, 0.2, globalDayFactor);

                // 4. LICHT BERECHNUNG
                
                // A) Direktes Sonnenlicht (Sorgt f√ºr 3D-Effekt und Schattenwurf des Objekts selbst)
                float directLight = max(0.0, dot(vNormal, sunDir));

                // B) Umgebungslicht (Ambient)
                // Wenn Tag: Helles Ambient (0.6), damit man auch im Schatten was sieht.
                // Wenn Nacht: Dunkles Ambient (Slider-Wert), damit es ganz schwarz werden kann.
                float ambientIntensity = mix(uNightBrightness, 0.6, isDaySide);

                // Gesamthelligkeit = Ambient + (Direktes Licht * Boost * Tag-Faktor)
                float totalLight = ambientIntensity + (directLight * uDirectSunIntensity * isDaySide);

                gl_FragColor = vec4(baseColor * totalLight, texColor.a);
            }
        `;

        

        // UPDATE: Generic Ring Fragment Shader
        const ringFragmentShader = `
            uniform sampler2D ringTexture;
            uniform vec3 uSunPosition;
            uniform vec3 uRingParentPosition; // Genericized from uSaturnPosition
            uniform float uRingParentRadius;  // Genericized from uSaturnRadius
            uniform float uNightBrightness;
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            float getShadow(vec3 fragPos, vec3 shadowCasterPos, float casterRadius, vec3 sunPos) {
                vec3 sunToCaster = normalize(shadowCasterPos - sunPos);
                vec3 casterToFrag = fragPos - shadowCasterPos;
                float distOnAxis = dot(casterToFrag, sunToCaster);
                if (distOnAxis < 0.0) return 1.0;
                vec3 closestPointOnAxis = shadowCasterPos + sunToCaster * distOnAxis;
                float distToAxis = distance(fragPos, closestPointOnAxis);
                return smoothstep(casterRadius * 0.9, casterRadius * 1.1, distToAxis);
            }
            void main() {
                vec4 texColor = texture2D(ringTexture, vUv);
                float shadowIntensity = getShadow(vWorldPosition, uRingParentPosition, uRingParentRadius, uSunPosition);
                vec4 nightColor = vec4(texColor.rgb * uNightBrightness, texColor.a);
                gl_FragColor = mix(nightColor, texColor, shadowIntensity);
                gl_FragColor.a *= texColor.a;
            }
        `;

        // UPDATE: Generic Planet Fragment Shader with Ring Shadows
        const planetWithRingFragmentShader = `
            uniform sampler2D dayTexture;
            uniform vec3 uSunPosition;
            uniform vec3 uObjectWorldPosition; 
            uniform float uNightBrightness;
            uniform vec3 uRingNormal;
            uniform float uRingInnerRadius;
            uniform float uRingOuterRadius;
            uniform float uRingShadowSoftness;
            uniform float uShadowTransparency;
            const float uShadowIntensityFactor = 0.85;
            varying vec2 vUv;
            varying vec3 vWorldPosition; 
            float calculateRingShadow(vec3 fragPos, vec3 sunPos, vec3 planetPos, vec3 ringNormal, float innerR, float outerR, float softness) {
                vec3 lightDir = normalize(sunPos - fragPos);
                float denom = dot(lightDir, ringNormal);
                if (abs(denom) < 0.0001) return 0.0; 
                float t = dot(planetPos - fragPos, ringNormal) / denom;
                if (t < 0.0) return 0.0; 
                vec3 intersectPos = fragPos + t * lightDir;
                float distToCenter = distance(intersectPos, planetPos);
                float shadow = smoothstep(innerR - softness, innerR, distToCenter) * (1.0 - smoothstep(outerR, outerR + softness, distToCenter));
                return clamp(shadow, 0.0, 1.0);
            }
            void main() {
                vec3 objectToSun = normalize(uSunPosition - uObjectWorldPosition);
                vec3 objectToFragment = normalize(vWorldPosition - uObjectWorldPosition);
                float intensity = (dot(objectToFragment, objectToSun) + 1.0) / 2.0;
                float nightBrightness = uNightBrightness;
                float lightMix = smoothstep(0.48, 0.59, intensity);
                vec4 dayColor = texture2D(dayTexture, vUv);
                vec4 nightColor = dayColor * nightBrightness;
                vec4 finalColor = mix(nightColor, dayColor, lightMix);
                if (intensity > 0.48) { 
                    float ringShadowMask = calculateRingShadow(vWorldPosition, uSunPosition, uObjectWorldPosition, uRingNormal, uRingInnerRadius, uRingOuterRadius, uRingShadowSoftness);
                    
                    // Multipliziert die Maske mit unserem en Transparenz-Wert
                    float finalMask = ringShadowMask * uShadowTransparency; 
                    
                    // Verwendet die e "finalMask"
                    vec3 shadowedColor = mix(finalColor.rgb, nightColor.rgb * uShadowIntensityFactor, finalMask); 
                    finalColor.rgb = shadowedColor;
                }
                gl_FragColor = finalColor;
            }
        `;

        const genericMoonFragmentShader = `
            uniform sampler2D dayTexture;
            uniform vec3 uSunPosition;
            uniform vec3 uObjectWorldPosition;
            uniform float uNightBrightness;
            uniform vec3 uParentPosition;
            uniform float uParentRadius;
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            float calculateParentShadow(vec3 fragPos, vec3 parentPos, float parentRadius, vec3 sunPos) {
                 vec3 sunToParent = parentPos - sunPos;
                 vec3 sunToFrag = fragPos - sunPos;
                 vec3 shadowAxis = normalize(sunToParent);
                 float distOnAxis = dot(fragPos - parentPos, shadowAxis);
                 if (distOnAxis < 0.0) return 1.0; 
                 vec3 closestPoint = parentPos + shadowAxis * distOnAxis;
                 float distFromAxis = distance(fragPos, closestPoint);
                 float umbra = parentRadius * 0.95;
                 float penumbra = parentRadius * 1.1;
                 return smoothstep(umbra, penumbra, distFromAxis);
            }
            void main() {
                vec4 textureColor = texture2D(dayTexture, vUv);
                vec3 objectToSun = normalize(uSunPosition - uObjectWorldPosition);
                vec3 objectToFragment = normalize(vWorldPosition - uObjectWorldPosition);
                float intensity = (dot(objectToFragment, objectToSun) + 1.0) / 2.0;
                float nightBrightness = uNightBrightness;
                float lightMix = smoothstep(0.48, 0.59, intensity);
                vec4 nightColor = textureColor * nightBrightness;
                vec4 finalColor = mix(nightColor, textureColor, lightMix);
                if (intensity > 0.01) {
                    float shadow = calculateParentShadow(vWorldPosition, uParentPosition, uParentRadius, uSunPosition);
                    finalColor.rgb *= mix(uNightBrightness, 1.0, shadow);
                }
                gl_FragColor = finalColor;
            }
        `;
        const moonVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            void main() {
                vUv = uv;
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const moonFragmentShader = `
            uniform sampler2D dayTexture;
            uniform vec3 uSunPosition;
            uniform vec3 uEarthPosition;
            uniform vec3 uObjectWorldPosition;
            uniform float uEarthRadius;
            uniform float uSunRadius;
            uniform float uMoonRadius;
            uniform float uNightBrightness;
            uniform bool uDemoActive;
            uniform float uShadowBrightness;
            uniform float uRedOverlayIntensity;
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            float calculateShadowIntensity(vec3 pixelPos, vec3 earthPos, float earthRadius, vec3 sunPos, float sunRadius) {
                vec3 sunToEarth = earthPos - sunPos;
                vec3 shadowAxis = normalize(sunToEarth);
                vec3 sunToPixel = pixelPos - sunPos;
                float depthInShadow = dot(sunToPixel, shadowAxis);
                if (depthInShadow < 0.0) return 1.0;
                vec3 closestPointOnAxis = sunPos + shadowAxis * depthInShadow;
                float pixelDistanceToAxis = distance(pixelPos, closestPointOnAxis);
                float umbraRadius = uEarthRadius * 0.9;
                float startRatio = 0.95; 
                float endRatio = 1.05;   
                float intensity = smoothstep(umbraRadius * startRatio, umbraRadius * endRatio, pixelDistanceToAxis);
                return intensity; 
            }
            void main() {
                vec4 textureColor = texture2D(dayTexture, vUv);
                vec3 objectToSun = normalize(uSunPosition - uObjectWorldPosition);
                vec3 objectToFragment = normalize(vWorldPosition - uObjectWorldPosition);
                float sunLightIntensity = (dot(objectToFragment, objectToSun) + 1.0) / 2.0;
                float nightBrightness = uNightBrightness;
                float sunLightMix = smoothstep(0.5, 0.6, sunLightIntensity);
                vec4 sunLitColor = mix(textureColor * nightBrightness, textureColor, sunLightMix);
                if (uDemoActive) {
                    vec4 finalColor = vec4(sunLitColor.rgb, 1.0);
                    float earthShadowIntensity = calculateShadowIntensity(vWorldPosition, uEarthPosition, uEarthRadius, uSunPosition, uSunRadius);
                    if (earthShadowIntensity < 1.0) {
                        if (earthShadowIntensity == 0.0) {
                            finalColor.rgb = mix(finalColor.rgb, finalColor.rgb * uShadowBrightness, sunLightMix);
                        } else {
                             finalColor.rgb *= (1.0 - (1.0 - earthShadowIntensity) * sunLightMix); 
                        }
                    }
                    vec3 bloodMoonColor = vec3(1.0, 0.2, 0.0);
                    float redMixAmount = uRedOverlayIntensity * sunLightMix * 0.4;
                    finalColor.rgb = mix(finalColor.rgb, bloodMoonColor, redMixAmount);
                    gl_FragColor = finalColor;
                } else {
                    gl_FragColor = sunLitColor;
                }
            }
        `;
        const ringVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            void main() {
                vUv = uv;
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // ### √ÑNDERUNG: Hilfsfunktion zum Beenden von Demos (ERWEITERT) ###
        function checkAndEndDemo() {
            if (isDemoActive) {
                endDemo();
            }
            // :
            if (isFrequencyDemoActive) {
                endFrequencyDemo();
            }
        }
        
        //  Hilfsfunktion zum Zur√ºcksetzen von UI-Indikatoren 
        function resetActiveIndicators() {
            // 1. Achsenlinie verstecken
            if (earthAxisLine) earthAxisLine.visible = false;

            // 2. Aktive Mondphasen-Klasse entfernen
            moonPhaseButtons.forEach(btn => btn.classList.remove('active'));

            // 3. Aktive Fokus/Jahreszeiten/Planeten-Klassen entfernen
            const groups = [
                document.getElementById('focus-system').parentElement, // Fokus-Gruppe
                document.getElementById('planet-focus-buttons'),      // Planeten-Gruppe
                document.getElementById('moon-focus-container'),    // Mond-Gruppe
                document.getElementById('seasons-group').querySelector('.btn-group'), // Jahreszeiten-Gruppe
                document.getElementById('human-objects-focus-buttons')
            ];
            
            try {
                groups.forEach(group => {
                    if (group) {
                        group.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
                    }
                });
            } catch (e) {
                console.warn("Fehler beim Zur√ºcksetzen der Indikatoren:", e);
            }
        }

        // Hilfsfunktion f√ºr das HUD
        function updateLaunchHUD(isVisible, title, subtext, icon, progressPercent) {
            const hud = document.getElementById('launch-hud');
            if (!hud) return;

            if (!isVisible) {
                hud.classList.remove('hud-visible');
                hud.style.display = 'none';
                return;
            }

            hud.style.display = 'flex'; // Sicherstellen, dass es da ist
            hud.classList.add('hud-visible');

            if (title) document.getElementById('hud-title').textContent = title;
            if (subtext) document.getElementById('hud-sub').textContent = subtext;
            if (icon) document.getElementById('hud-icon').textContent = icon;
            
            // Balken-Update (Optional)
            const bar = document.getElementById('hud-bar');
            if (bar && progressPercent !== undefined) {
                bar.style.width = progressPercent + '%';
            }
        }

        // Hilfsfunktion: L√∂scht Objekte komplett aus dem Speicher der Grafikkarte
        function disposeObject(object) {
            if (!object) return;
            
            object.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) {
                        child.geometry.dispose();
                    }
                    if (child.material) {
                        // Material kann ein Array sein oder einzeln
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                if (mat.map) mat.map.dispose();     // Textur l√∂schen
                                mat.dispose();                      // Material l√∂schen
                            });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    }
                }
            });
        }
        
        
        function formatDayCount(day) {
            // Die Konstante EARTH_YEAR_DAYS (365.25) ist bereits global definiert
            
            const sign = day < 0 ? "-" : "";
            const absDay = Math.abs(day);
            
            const years = Math.trunc(absDay / EARTH_YEAR_DAYS);
            const remainingDays = absDay % EARTH_YEAR_DAYS;
            
            // Runden auf eine Nachkommastelle
            const daysFixed = remainingDays.toFixed(1);
            
            // Plural-Regeln (vereinfacht)
            const dayPlural = (parseFloat(daysFixed) === 1.0) ? "Tag" : "Tage";

            if (years === 0) {
                // Format: "-10.5 Tage"
                return `${sign}${daysFixed} ${dayPlural}`;
            } else {
                // Format: "-1 Jahr 0.8 Tage"
                const yearPlural = (years === 1) ? "Jahr" : "Jahre";
                return `${sign}${years} ${yearPlural} ${daysFixed} ${dayPlural}`;
            }
        }

        

        function plantFlagOnMoon() {
            if (isFlagOnMoon) return;
            if (!moon) return;

            const moonRadius = MOON_RADIUS; 
            
            // 1. FLAGGE (Jetzt als 3D Modell)
            if (flagTemplate) {
                const flagGroup = flagTemplate.clone();
                
                // Shader anwenden!
                applySurfaceShader(flagGroup);

                // Positionieren (Werte evtl. anpassen je nach Modell)
                flagGroup.position.set(moonRadius, 0, 0); 
                flagGroup.rotation.z = Math.PI / 2; 
                flagGroup.rotation.y = Math.PI; // Drehen, damit sie zur Kamera zeigt
                
                flagGroup.visible = false;

                moon.add(flagGroup);

                moonSurfaceObjects.push(flagGroup);
                
            } else {
                console.warn("Flaggen-Modell noch nicht geladen!");
                // Fallback: Deine alte Plane-Logik hier rein, falls Modell fehlt
            }

            // 2. ASTRONAUT
            if (astronautTemplate) {
                const astro = astronautTemplate.clone();
                const astroScale = 0.01 * SCENE_SCALE; 
                astro.scale.set(astroScale, astroScale, astroScale);
                astro.position.set(moonRadius, 0, 0.1 * SCENE_SCALE); 
                astro.rotation.z = Math.PI / 2; 
                astro.rotation.y = Math.PI; 

                const northAmount = 0.03;  // Verschiebung nach Norden (z.B. 0.0 bis 1.0)
                const eastAmount = -0.03;   // Verschiebung nach Osten  (z.B. 0.0 bis 1.0)

                // 1. Wir setzen eine Richtung (die 1.0 bei X sorgt daf√ºr, dass er auf der Vorderseite bleibt)
                astro.position.set(1.0, northAmount, eastAmount);

                astro.traverse((child) => {
                    if (child.isMesh) {
                        child.material = child.material.clone(); // Wichtig: Klonen!
                        child.material.metalness = 0.8;          // Wenig Metall (Stoff)
                        child.material.roughness = 0.8;          // Rau (Stoff)
                    }
                });
                
                // 2. WICHTIG: Wir "normieren" den Vektor (L√§nge 1) und skalieren ihn auf den Mondradius
                // So klebt er immer perfekt auf der Oberfl√§che, egal welche Zahlen du oben eingibst.
                astro.position.normalize().multiplyScalar(moonRadius);
                
                astro.visible = false;

                // WICHTIG: Shader anwenden!
                applySurfaceShader(astro);

                moon.add(astro);
                moonSurfaceObjects.push(astro);
                astronautMesh = astro;
            } 

            // 3. LANDER
            if (landerTemplate) {
                const lander = landerTemplate.clone();
                const landerScale = 0.00025 * SCENE_SCALE;
                lander.scale.set(landerScale, landerScale, landerScale);
                
                const heightCorrection = 0.0082 * SCENE_SCALE;
                lander.position.set(moonRadius - heightCorrection, 0, -0.08 * SCENE_SCALE);
                
                lander.rotation.z = -Math.PI / 2.0; 
                lander.rotation.y = Math.PI / 0.492;
                
                lander.traverse((child) => {
                    if (child.isMesh) {
                        // Pr√ºfen, ob es der Schatten ist
                        // (Meistens hei√üt das Mesh "Plane", "Shadow" oder √§hnlich)
                        const isShadow = child.name.toLowerCase().includes('shadow') || child.name.toLowerCase().includes('plane');

                        if (isShadow) {
                            // --- L√ñSUNG F√úR DEN SCHATTEN ---
                            // Wir wechseln zu MeshBasicMaterial -> Das ignoriert Licht komplett!
                            child.material = new THREE.MeshBasicMaterial({
                                map: child.material.map, // Die alte Textur beibehalten
                                transparent: true,
                                opacity: 0.8, // Wie dunkel der Schatten sein soll
                                color: 0x000000 // Zwingend Schwarz
                            });
                            
                            // WICHTIG: Wir schlie√üen den Schatten vom Shader-Update aus,
                            // indem wir ihm eine Markierung geben (oder einfach nicht bearbeiten)
                            child.userData.ignoreShader = true; 

                        } else {
                            // --- L√ñSUNG F√úR DEN LANDER ---
                            child.material = child.material.clone(); 
                            child.material.metalness = 0.3; 
                            child.material.roughness = 0.7;
                            child.material.emissive.setHex(0x151515);
                        }
                    }
                });
                
                lander.visible = false; // Erstmal unsichtbar (wegen Anti-Lag)

                // Shader nur anwenden, wenn es NICHT der Schatten ist
                // (Wir m√ºssen applySurfaceShader leicht anpassen oder hier manuell filtern)
                // Einfacher Trick: Da MeshBasicMaterial (der Schatten) eh keine Lights nutzt, 
                // st√∂rt der Shader meist nicht, aber sauberer ist es, applySurfaceShader anzupassen.
                // F√ºr jetzt lassen wir applySurfaceShader laufen, da der BasicMaterial-Trick meist reicht.
                applySurfaceShader(lander);

                moon.add(lander);
                moonSurfaceObjects.push(lander);

                // --- L√ñSUNG F√úR DIE OBERSEITE ---
                // Intensity: Von 0.8 auf 1.2 erh√∂ht (heller)
                // Position: Y von 4.0 auf 15.0 erh√∂ht (deutlich h√∂her √ºber dem Dach)
                // Position: Z auf 5.0 gesetzt (leicht versetzt zur Kamera hin, f√ºr bessere 3D-Wirkung)
                addFillLight(lander, 1.2, 40, new THREE.Vector3(0, 180.0, -80.0), 0.0);
            }

            isFlagOnMoon = true;
            console.log("Die Flagge, der Astronaut und der Lander stehen! üá∫üá∏üë®‚ÄçüöÄüöÄ");
        }

        // Globale Liste f√ºr die Shader-Updates
        let surfaceObjectsMaterials = [];

        // Optimierte Shader-Funktion
        function applySurfaceShader(object3D) {
            object3D.traverse((child) => {
                if (child.userData.ignoreShader) return;
                
                if (child.isMesh && child.material) {
                    
                    // PERFORMANCE FIX: 
                    // Pr√ºfen, ob wir dieses Material schon bearbeitet haben.
                    // Wenn ja, brechen wir ab (da es sich um ein geteiltes Material handelt).
                    if (surfaceObjectsMaterials.includes(child.material)) {
                        return;
                    }

                    // Wir entfernen das .clone(), damit Teile, die dasselbe Material nutzen 
                    // (z.B. alle goldenen Folien), auch denselben Shader nutzen.
                    // child.material = child.material.clone(); <--- GEL√ñSCHT

                    child.material.userData.shader = null;

                    child.material.onBeforeCompile = (shader) => {
                        shader.uniforms.uSunPosition = { value: new THREE.Vector3(0, 0, 0) };
                        shader.uniforms.uMoonCenter = { value: new THREE.Vector3(0, 0, 0) };
                        shader.uniforms.uNightBrightness = { value: 0.04 }; 

                        child.material.userData.shader = shader;

                        shader.vertexShader = `
                            varying vec3 vWorldPositionCustom;
                        ` + shader.vertexShader;

                        shader.vertexShader = shader.vertexShader.replace(
                            '#include <worldpos_vertex>',
                            `
                            #include <worldpos_vertex>
                            vWorldPositionCustom = (modelMatrix * vec4(transformed, 1.0)).xyz;
                            `
                        );

                        shader.fragmentShader = `
                            uniform vec3 uSunPosition;
                            uniform vec3 uMoonCenter;
                            uniform float uNightBrightness;
                            varying vec3 vWorldPositionCustom;
                        ` + shader.fragmentShader;

                        shader.fragmentShader = shader.fragmentShader.replace(
                            '#include <dithering_fragment>',
                            `
                            #include <dithering_fragment>
                            vec3 surfaceUp = normalize(vWorldPositionCustom - uMoonCenter);
                            vec3 sunDir = normalize(uSunPosition - vWorldPositionCustom);
                            float globalDayFactor = dot(surfaceUp, sunDir);
                            float isDaySide = smoothstep(-0.2, 0.2, globalDayFactor);
                            float finalBrightness = mix(uNightBrightness, 1.0, isDaySide);
                            gl_FragColor.rgb *= finalBrightness;
                            `
                        );
                    };

                    // Material nur EINMAL zur Liste hinzuf√ºgen
                    surfaceObjectsMaterials.push(child.material);
                }
            });
        }

        function init() {

            //Loading Screen
            loadingManager = new THREE.LoadingManager();
            
            // Wird aufgerufen, wenn ALLES geladen ist
            loadingManager.onLoad = () => {
                console.log('Alle Assets geladen.');
                plantFlagOnMoon();
                const loadingScreen = document.getElementById('loading-screen');
                if (loadingScreen) {
                    loadingScreen.style.opacity = '0'; // Fade-Out starten
                    
                    // Nach der Animation aus dem DOM entfernen/verstecken
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500); // Muss zur CSS-Transitionszeit passen
                }
            };
            
            // (Optional) Zeigt den Ladefortschritt in der Konsole und im Text
            loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
                const progressBar = document.getElementById('progress-bar');
                const percent = (itemsLoaded / itemsTotal) * 100;
                if (progressBar) {
                    progressBar.style.width = percent + '%';
                }

                //  2. Text aktualisieren (Laden... + Prozentzahl) 
                const loadingText = document.getElementById('loading-text');
                if (loadingText) {
                    // Math.round() sorgt f√ºr eine saubere Zahl (z.B. 85% statt 85.123%)
                    loadingText.textContent = `Laden... (${Math.round(percent)}%)`;
                }
                
                console.log(`Lade: ${url} (${itemsLoaded}/${itemsTotal})`);
            };

            // (Optional) F√§ngt Ladefehler ab
            loadingManager.onError = (url) => {
                console.error('Fehler beim Laden von: ' + url);
                const loadingText = document.getElementById('loading-text');
                if (loadingText) {
                    loadingText.textContent = `Fehler beim Laden von Assets. Bitte  laden.`;
                }
            };

            distanceLabelEl = document.getElementById('distance-label');
            currentDayLabelEl = document.getElementById('current-day-label');

            infoToastButton = document.getElementById('info-toast-button');
            followCometBtn = document.getElementById('follow-comet-btn'); 
            cometControls = document.getElementById('comet-controls');

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20000);
            camera.position.set(EARTH_DISTANCE * 1.5, EARTH_DISTANCE * 0.7, EARTH_DISTANCE * 1.5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: false  // < DAS IST DER E L√ñSUNGSANSATZ
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.touches = { ONE: 0, TWO: 2 };
            controls.maxDistance = 7000;
            
            controls.addEventListener('start', () => {
                isUserControllingCamera = true;
                userInteractedRecently = true;
                if (interactionTimeout) clearTimeout(interactionTimeout);
                
                if (infoToastButton) {
                    infoToastButton.style.display = 'none';
                    currentSelectedInfo = null;
                }
            });

            controls.addEventListener('end', () => {
                isUserControllingCamera = false;
                interactionTimeout = setTimeout(() => {
                    userInteractedRecently = false;
                }, 3000); 
            });
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            targetEarthDistance = EARTH_DISTANCE;
            currentEarthDistance = EARTH_DISTANCE;
            targetMoonDistance = MOON_DISTANCE;
            currentMoonDistance = MOON_DISTANCE;

            definePlanetData();
            createSolarSystem();
            createAsteroidBelt();

            //  Skalierungsfaktoren berechnen NACHDEM createSolarSystem() lief 
            originalSunScale.copy(sun.scale);
            originalMoonScale.copy(moon.scale);

            // 1. Berechne, wie gross die Sonne sein muss, um die gleiche *scheinbare Gr√∂sse* wie der Mond
            //    in der Simulation (aus 15 Einheiten Entfernung) zu haben.
            //    Winkel(Mond) = 2 * atan( (Radius*Scale) / (2 * Distanz) )
            const moonApparentSizeRad = 2 * Math.atan((MOON_RADIUS * originalMoonScale.x) / (2 * MOON_DISTANCE));
            // Finde en Sonnenradius: tan(Winkel/2) = (erRadius) / (Sonnendistanz)
            const newSunRadius = Math.tan(moonApparentSizeRad / 2) * EARTH_DISTANCE;
            // Berechne Skalierungsfaktor
            freqDemoSunScale = (newSunRadius / (SUN_RADIUS * originalSunScale.x)) * 2.05;

            // 2. Berechne Skalierung f√ºr reale Winkelgr√∂sse (ca. 0.52 Grad)
            const realAngSizeRad = (0.52 * Math.PI) / 180;
            // Mond
            const realRatioNewMoonRadius = Math.tan(realAngSizeRad / 2) * MOON_DISTANCE;
            realRatioMoonScale = realRatioNewMoonRadius / (MOON_RADIUS * originalMoonScale.x);
            // Sonne
            const realRatioNewSunRadius = Math.tan(realAngSizeRad / 2) * EARTH_DISTANCE;
            realRatioSunScale = (realRatioNewSunRadius / (SUN_RADIUS * originalSunScale.x)) * 1.2;
            

            createOrbits();
            load3DModels();
            setupUI();

            //  Kometen-Lotterie 
            if (Math.random() < COMET_PROBABILITY) {
                // Juhu, er wird kommen! Wir legen den Tag fest.
                cometSpawnDay = THREE.MathUtils.randFloat(COMET_MIN_DAY, COMET_MAX_DAY);
                console.log(`Gl√ºck gehabt! Komet 67P wird an Tag ${cometSpawnDay.toFixed(1)} erscheinen.`);
            } else {
                console.log("Kein Komet in dieser Simulation.");
                cometSpawnDay = -1; // Wird nie spawnen
            }

            // ... Komet Code ...

            // --- RAKETEN-LOTTERIE ---
            // --- RAKETEN SETUP (Code verschoben) ---
            const rocketControls = document.getElementById('rocket-controls');
            const launchBtn = document.getElementById('launch-rocket-btn');
            // Boardkamera Button
            const rocketCamBtn = document.getElementById('rocket-cam-btn');
            rocketCamBtn.addEventListener('click', () => {
                if (rocketInstance) {
                    rocketInstance.toggleOnboardCamera();
                }
            });
            // 1. Den Listener IMMER hinzuf√ºgen (damit der Button funktioniert, egal wie er aktiviert wurde)
            launchBtn.addEventListener('click', () => {
                if (!rocketInstance) {
                    rocketInstance = new Rocket(scene);
                    rocketInstance.launch();
                    
                    // Button deaktivieren w√§hrend des Fluges
                    launchBtn.disabled = true;
                    launchBtn.classList.remove('btn-pulse');
                    launchBtn.textContent = "Startsequenz initiiert...";
                }
            });

            const abortBtn = document.getElementById('rocket-abort-btn');
            abortBtn.addEventListener('click', () => {
                if (rocketInstance) {
                    rocketInstance.abort();
                    rocketInstance = null; // WICHTIG: Instanz l√∂schen, damit update() aufh√∂rt
                }
            });

            // --- LISTENER F√úR "START ABLEHNEN" BUTTON ---
            const dismissBtn = document.getElementById('rocket-dismiss-btn');
            if (dismissBtn) {
                dismissBtn.addEventListener('click', () => {
                    // 1. Das HUD sofort ausschalten
                    updateLaunchHUD(false);

                    // 2. Den ganzen Raketen-Kontroll-Bereich ausblenden
                    if (rocketControls) {
                        rocketControls.style.display = 'none';
                    }

                    // 3. Logik-Variable zur√ºcksetzen
                    rocketSpawnAllowed = false;

                    console.log("Raketenstart vom Nutzer abgelehnt.");
                });
            }

            // 2. Die Lotterie entscheidet nur √ºber das AUTOMATISCHE Erscheinen
            const diceRoll = Math.random(); // Wir w√ºrfeln eine Zahl zwischen 0.0 und 1.0
            console.log(`üé≤ Raketen-Lotterie: Gew√ºrfelt wurde ${diceRoll.toFixed(2)} (Ben√∂tigt: < ${ROCKET_PROBABILITY})`);

            if (diceRoll < ROCKET_PROBABILITY) {
                console.log("üéâ GL√úCK GEHABT! Ein Raketenstart ist verf√ºgbar.");
                rocketSpawnAllowed = true;
                
                // --- NEU: ZUF√ÑLLIGE VERZ√ñGERUNG (4 bis 8 Minuten) ---
                // 1 Minute = 60.000 Millisekunden
                const minMinutes = 2;
                const maxMinutes = 5;
                
                // Zufallszahl zwischen min und max (in Millisekunden umgerechnet)
                const randomDelay = (Math.random() * (maxMinutes - minMinutes) + minMinutes) * 60 * 1000;
                
                console.log(`‚è±Ô∏è Der Start-Button erscheint in ${(randomDelay / 1000 / 60).toFixed(1)} Minuten.`);

                // Wir warten die berechnete Zeit
                setTimeout(() => {
                    if (rocketControls) rocketControls.style.display = 'block';
                    
                    // HUD als "Einladung" anzeigen!
                    updateLaunchHUD(true, "SYSTEM CHECK", "Warte auf Startfreigabe...", "‚è±Ô∏è", 0);
                    
                    // Kleiner Sound oder Log-Hinweis, wenn er erscheint
                    console.log("üöÄ Raketenstart JETZT verf√ºgbar!");
                    
                }, randomDelay); 
            } else {
                console.log("‚ùå Kein Raketenstart in dieser Sitzung.");
            }

            animate();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMouseClick, false);
            
            
            window.addEventListener('touchend', onTouchEnd, false);

            window.addEventListener('keydown', (e) => {
                if (e.shiftKey && (e.key === 'U' || e.key === 'u')) {
                    if (ufoState === 'inactive') {
                        spawnUFO();
                    }
                }
                if (e.shiftKey && (e.key === 'K' || e.key === 'k')) {
                    if (!comet) { 
                         spawnComet();
                    }
                }

                // +++ SHIFT + R f√ºr RAKETE +++
                if (e.shiftKey && (e.key === 'R' || e.key === 'r')) {
                    const rocketControls = document.getElementById('rocket-controls');
                    const launchBtn = document.getElementById('launch-rocket-btn');
                    
                    if (rocketControls) {
                        // 1. Men√º anzeigen
                        rocketControls.style.display = 'block';
                        
                        // 2. Falls schon mal geflogen wurde: Button zur√ºcksetzen
                        launchBtn.disabled = false;
                        launchBtn.textContent = "üöÄ Raketenstart verf√ºgbar!";
                        launchBtn.classList.add('btn-pulse');
                        
                        console.log("Raketen-Modus per Shortcut aktiviert!");
                    }
                }

                // Flat earth
                if (e.shiftKey && (e.key === 'F' || e.key === 'f')) {
                    toggleFlatEarthMode();
                }
            });
            
            updatePositions(currentDay);
            setFocus(sun, 0); 
            
            if (isPlaying) {
                 playPauseBtn.classList.add('playing');
                 playPauseBtn.innerHTML = iconPause;
            } else {
                playPauseBtn.innerHTML = iconPlay;
            }
            
        }
        
        function definePlanetData() {
            const textureBasePath = 'https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/ImagesGit/Objects/';
            const moonTextureBasePath = 'https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/ImagesGit/Objects/Moons/';
            const degToRad = Math.PI / 180;
            
            planetsData = [
                { 
                    name: 'Mercury', 
                    radius: 0.95 * SCENE_SCALE, 
                    distance: 110 * SCENE_SCALE, 
                    yearDays: 88, 
                    texture: textureBasePath + '2k_mercury.webp', 
                    axialTilt: 0.03, 
                    rotationSpeed: 0.017,
                    ecc: 0.205, 
                    perihelionAngle: 77.45 * degToRad, 
                    orbitalInclination: 7.0,
                    planetType_de: 'Innerer Gesteinsplanet',
                    //Fakten
                    name_de: 'Merkur', earthCompareRadius: '0,38x Erde', radius_km: '2.439', distance_Mio_km: '57,9 Mio. km', umlaufzeit: '88 Erdtage', taglaenge: '176 Erdtage', temperatur: 'ca. 167¬∞C',
                    funFacts: ['Auf Merkur dauert ein Tag (176 Erdtage) l√§nger als ein Jahr (88 Erdtage).', 'Er hat keine Monde und keine nennenswerte Atmosph√§re.', 'Trotz seiner N√§he zur Sonne ist er nicht der heisseste Planet.']
                },
                { 
                    name: 'Venus', 
                    radius: 2.4 * SCENE_SCALE, 
                    distance: 200 * SCENE_SCALE, 
                    yearDays: 225, 
                    texture: textureBasePath + '2k_venus_surface.webp', 
                    axialTilt: 177.0, rotationSpeed: -0.0041,
                    ecc: 0.007, 
                    perihelionAngle: 131.53 * degToRad, 
                    orbitalInclination: 3.39,
                    planetType_de: 'Innerer Gesteinsplanet',
                    //Fakten
                    name_de: 'Venus', earthCompareRadius: '0,95x Erde', radius_km: '6.051', distance_Mio_km: '108,2 Mio. km', umlaufzeit: '225 Erdtage', taglaenge: '243 Erdtage (r√ºckw√§rts!)', temperatur: 'ca. 464¬∞C (heissester Planet)',
                    funFacts: ['Die Venus dreht sich "r√ºckw√§rts" (retrograd).', 'Ein Tag auf der Venus ist l√§nger als ihr Jahr (Umlauf um die Sonne).', 'Ihre dichte CO2-Atmosph√§re erzeugt einen extremen Treibhauseffekt.']
                },
                { 
                    name: 'Mars', 
                    radius: 1.3 * SCENE_SCALE, 
                    distance: 415 * SCENE_SCALE, 
                    yearDays: 687, 
                    texture: textureBasePath + '2k_mars.webp', 
                    axialTilt: 25.19, 
                    rotationSpeed: 0.97,
                    ecc: 0.094, 
                    perihelionAngle: 336.04 * degToRad, 
                    orbitalInclination: 1.85,
                    planetType_de: 'Innerer Gesteinsplanet',
                    //Fakten
                    name_de: 'Mars', earthCompareRadius: '0,53x Erde', radius_km: '3.389', distance_Mio_km: '227,9 Mio. km', umlaufzeit: '687 Erdtage', taglaenge: '24h 37min', temperatur: 'ca. -63¬∞C',
                    funFacts: ['Der Mars hat den h√∂chsten Vulkan im Sonnensystem (Olympus Mons, 22km hoch).', 'Er hat zwei kleine Monde: Phobos und Deimos.', 'Seine rote Farbe kommt von Eisenoxid (Rost) im Boden.']
                },
                { 
                    name: 'Jupiter', 
                    radius: 28.0 * SCENE_SCALE, 
                    distance: 900 * SCENE_SCALE, 
                    yearDays: 4333, 
                    texture: textureBasePath + '2k_jupiter.webp', 
                    axialTilt: 3.13, 
                    rotationSpeed: 2.43,
                    ecc: 0.049, 
                    perihelionAngle: 14.75 * degToRad, 
                    orbitalInclination: 1.3,
                    planetType_de: '√Ñusserer Gasriese',
                    moons: [
                        { 
                            name: 'Io', 
                            radius: 0.715 * SCENE_SCALE, 
                            distance: 49.5 * SCENE_SCALE, 
                            speed: 0.565,
                            startAngle: Math.random() * Math.PI * 2, 
                            texture: moonTextureBasePath + 'jupiter_io.webp', 
                            inclination: 0.05 * degToRad,
                            //Fakten
                            earthCompareRadius: '0,28x Erde', radius_km: '1.821', distance_Mio_km: '421.700 km', umlaufzeit: '1,77 Tage', temperatur: 'ca. -143¬∞C', parentName: 'Jupiter',
                            funFacts: ['Io ist der vulkanisch aktivste K√∂rper im Sonnensystem.', 'Seine Oberfl√§che wird durch die Schwerkraft von Jupiter st√§ndig "durchgeknetet".']
                        },
                        { 
                            name: 'Europa', 
                            radius: 0.61 * SCENE_SCALE, 
                            distance: 78.9 * SCENE_SCALE, 
                            speed: 0.282, 
                            startAngle: Math.random() * Math.PI * 2, 
                            texture: moonTextureBasePath + 'jupiter_europa.webp', 
                            inclination: 0.47 * degToRad,
                            //Fakten
                            earthCompareRadius: '0,25x Erde', radius_km: '1.560', distance_Mio_km: '671.100 km', umlaufzeit: '3,55 Tage', temperatur: 'ca. -170¬∞C', parentName: 'Jupiter',
                            funFacts: ['Europa hat einen Ozean aus fl√ºssigem Wasser unter seiner Eiskruste.', 'Er gilt als einer der aussichtsreichsten Orte f√ºr ausserirdisches Leben.']
                        },
                        { 
                            name: 'Ganymed', 
                            radius: 1.03 * SCENE_SCALE, 
                            distance: 126 * SCENE_SCALE, 
                            speed: 0.14, 
                            startAngle: Math.random() * Math.PI * 2,
                            texture: moonTextureBasePath + 'jupiter_ganymede.webp', 
                            inclination: 0.20 * degToRad,
                            //Fakten
                            earthCompareRadius: '0,41x Erde', radius_km: '2.634', distance_Mio_km: '1,07 Mio. km', umlaufzeit: '7,15 Tage', temperatur: 'ca. -163¬∞C', parentName: 'Jupiter',
                            funFacts: ['Ganymed ist der gr√∂√üte Mond im Sonnensystem (gr√∂√üer als Merkur!).', 'Er ist der einzige Mond mit einer eigenen Magnetfeld.']
                        },
                        { 
                            name: 'Kallisto', 
                            radius: 0.945 * SCENE_SCALE, 
                            distance: 220 * SCENE_SCALE, 
                            speed: 0.060, 
                            startAngle: Math.random() * Math.PI * 2,
                            texture: moonTextureBasePath + 'jupiter_callisto.webp', 
                            inclination: 0.20 * degToRad,
                            //Fakten
                            earthCompareRadius: '0,38x Erde', radius_km: '2.410', distance_Mio_km: '1,88 Mio. km', umlaufzeit: '16,69 Tage', temperatur: 'ca. -139¬∞C', parentName: 'Jupiter',
                            funFacts: ['Kallisto hat eine der √§ltesten, am st√§rksten verkraterten Oberfl√§chen im Sonnensystem.']
                        }
                    ],
                    //Fakten
                    name_de: 'Jupiter', earthCompareRadius: '11,2x Erde', radius_km: '69.911', distance_Mio_km: '778,5 Mio. km', umlaufzeit: '11,9 Jahre', taglaenge: '9h 56min', temperatur: 'ca. -108¬∞C',
                    funFacts: ['Jupiter ist der gr√∂√üte Planet und hat √ºber 90 Monde.', 'Der "Gro√üe Rote Fleck" ist ein riesiger Wirbelsturm, der schon seit Jahrhunderten tobt.']
                },
                { 
                    name: 'Saturn', 
                    radius: 23.8 * SCENE_SCALE, 
                    distance: 1350 * SCENE_SCALE, 
                    yearDays: 10759, 
                    texture: textureBasePath + '2k_saturn.webp', 
                    axialTilt: 26.73, 
                    rotationSpeed: 2.22,
                    ecc: 0.057, 
                    perihelionAngle: 92.43 * degToRad, 
                    orbitalInclination: 2.49,
                    planetType_de: '√Ñusserer Gasriese',
                    // UPDATE: Ring-Daten nun generisch hier
                    ring: {
                        texture: textureBasePath + 'Rings/2k_saturn_ring.webp',
                        innerRadius: 1.2, // Multiplikator vom Planetenradius
                        outerRadius: 2.7, // Multiplikator vom Planetenradius
                    },
                    moons: [
                        { 
                            name: 'Titan', 
                            radius: 1.01 * SCENE_SCALE, 
                            distance: 144.9 * SCENE_SCALE, 
                            speed: 0.063, 
                            texture: moonTextureBasePath + 'saturn_titan.webp', 
                            inclination: 0.35 * degToRad,
                            //Fakten
                            earthCompareRadius: '0,40x Erde', radius_km: '2.574', distance_Mio_km: '1,22 Mio. km', umlaufzeit: '15,95 Tage', temperatur: 'ca. -179¬∞C', parentName: 'Saturn',
                            funFacts: ['Titan ist der einzige Mond mit einer dichten Atmosph√§re.', 'Es gibt dort Seen und Fl√ºsse aus fl√ºssigem Methan und Ethan.']
                        }
                    ],
                    //Fakten
                    name_de: 'Saturn', earthCompareRadius: '9,5x Erde', radius_km: '58.232', distance_Mio_km: '1,43 Mrd. km', umlaufzeit: '29,5 Jahre', taglaenge: '10h 34min', temperatur: 'ca. -139¬∞C',
                    funFacts: ['Saturns beeindruckende Ringe bestehen fast nur aus Eisbrocken und Staub.', 'Er hat die geringste Dichte aller Planeten ‚Äì er w√ºrde in einer riesigen Badewanne schwimmen!']
                },
                { 
                    name: 'Uranus', 
                    radius: 10.0 * SCENE_SCALE, 
                    distance: 1620 * SCENE_SCALE, 
                    yearDays: 30687, 
                    texture: textureBasePath + '2k_uranus_dunkler.webp', 
                    axialTilt: 97.77, rotationSpeed: 1.38,
                    ecc: 0.046, 
                    perihelionAngle: 170.96 * degToRad, 
                    orbitalInclination: 0.77,
                    planetType_de: '√Ñusserer Eisriese',
                    // UPDATE: Uranus hat jetzt auch Ringe!
                    ring: {
                        texture: textureBasePath + 'Rings/uranus_ring_2.webp', // Platzhalter-Textur (die gleiche wie Saturn)
                        innerRadius: 1.05, 
                        outerRadius: 3.4, 
                    },
                    //Fakten
                    name_de: 'Uranus', earthCompareRadius: '4,0x Erde', radius_km: '25.362', distance_Mio_km: '2,87 Mrd. km', umlaufzeit: '84 Jahre', taglaenge: '17h 14min', temperatur: 'ca. -197¬∞C',
                    funFacts: ['Uranus "rollt" auf seiner Bahn, da seine Achse um fast 98 Grad geneigt ist.', 'Er ist ein Eisriese und erscheint durch Methan in seiner Atmosph√§re blau-gr√ºn.', 'Auch Uranus hat Ringe, sie sind aber viel dunkler und d√ºnner als die des Saturn.']
                },
                { 
                    name: 'Neptune', 
                    radius: 9.8 * SCENE_SCALE, 
                    distance: 1980 * SCENE_SCALE, 
                    yearDays: 60190, 
                    texture: textureBasePath + '2k_neptune.webp', 
                    axialTilt: 28.32, 
                    rotationSpeed: 1.49,
                    ecc: 0.009, 
                    perihelionAngle: 44.97 * degToRad, 
                    orbitalInclination: 1.77,
                    planetType_de: '√Ñusserer Eisriese',
                    //Fakten
                    name_de: 'Neptun', earthCompareRadius: '3,9x Erde', radius_km: '24.622', distance_Mio_km: '4,50 Mrd. km', umlaufzeit: '165 Jahre', taglaenge: '16h 6min', temperatur: 'ca. -201¬∞C',
                    funFacts: ['Auf Neptun wehen die schnellsten Winde im Sonnensystem (bis zu 2.100 km/h).', 'Er wurde 1846 durch mathematische Berechnungen entdeckt, bevor man ihn im Teleskop sah.']
                },
                {
                    name: 'Pluto', 
                    radius: 0.19 * SCENE_SCALE, 
                    distance: 2340 * SCENE_SCALE, 
                    yearDays: 90582, texture: textureBasePath + '2k_pluto.webp', 
                    axialTilt: 122.5, 
                    rotationSpeed: -0.156,
                    ecc: 0.244, 
                    perihelionAngle: 224.07 * degToRad, 
                    orbitalInclination: 17.16, 
                    planetType_de: 'Zwergplanet (Kuiperg√ºrtel)',
                    //Fakten
                    name_de: 'Pluto (Zwergplanet)', earthCompareRadius: '0,19x Erde', radius_km: '1.188', distance_Mio_km: '5,9 Mrd. km (im Schnitt)', umlaufzeit: '248 Jahre', taglaenge: '6,4 Tage', temperatur: 'ca. -229¬∞C',
                    funFacts: ['Pluto wurde 2006 vom Planeten zum "Zwergplaneten" umklassifiziert.', 'Seine Bahn ist so elliptisch, dass er zeitweise n√§her an der Sonne ist als Neptun.']
                }
            ];
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function createSolarSystem() {
            const textureLoader = new THREE.TextureLoader(loadingManager);

            

            const starGeometry = new THREE.SphereGeometry(5000, 32, 32); 
            const starTexture = textureLoader.load('ImagesGit/Scenery/8k_stars_milky_way.webp');
            const starMaterial = new THREE.MeshBasicMaterial({ map: starTexture, side: THREE.BackSide });
            starField = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(starField);

	        const sunTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/ImagesGit/Objects/8k_sun.webp');
            const sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture });
	        sun = new THREE.Mesh(new THREE.SphereGeometry(SUN_RADIUS, 32, 32), sunMaterial);
            
            const sunLight = new THREE.PointLight(0xffffff, 1.5, 0, 2);
            sun.add(sunLight);

            sun.userData.info = {
                name: 'Sonne', earthCompareRadius: '109x Erde', radius_km: '696.340', oberflaeche_temp: 'ca. 5.500 ¬∞C', zusammensetzung: 'Wasserstoff, Helium',
                funFacts: ['Die Sonne macht 99,86% der gesamten Masse unseres Sonnensystems aus.', 'Sie ist ein Stern vom Typ "Gelber Zwerg" und etwa 4,6 Milliarden Jahre alt.']
            };
            clickableObjects.push(sun); 
            scene.add(sun);
            
            earthTiltPivot = new THREE.Group();
            earthTiltPivot.position.set(EARTH_DISTANCE, 0, 0);
            scene.add(earthTiltPivot);
            earthTiltPivot.rotation.z = EARTH_TILT_RAD;

            const earthMaterial = new THREE.ShaderMaterial({
                vertexShader: earthVertexShader, fragmentShader: earthFragmentShader,
                uniforms: {
                    dayTexture: { value: textureLoader.load('https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/ImagesGit/Objects/earth_day.webp') },
                    nightTexture: { value: textureLoader.load('https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/ImagesGit/Objects/2k_earth_nightmap.webp') },
                    uSunPosition: { value: new THREE.Vector3(0, 0, 0) }, uObjectWorldPosition: { value: new THREE.Vector3() }, uNightBrightness: { value: 0.3 },
                    uSofiDemoActive: { value: false }, uMoonPosition: { value: new THREE.Vector3() }, uMoonRadius: { value: MOON_RADIUS }, uSunRadius: { value: SUN_RADIUS }, 

                    uHasNightTexture: { value: true }
                }
            });
            earth = new THREE.Mesh(new THREE.SphereGeometry(EARTH_RADIUS, 32, 32), earthMaterial);
            
            
            earth.userData.info = {
                name: 'Erde', earthCompareRadius: '1x Erde', radius_km: '6.371', distance_Mio_km: '149,6 Mio. km',
                planetType_de: 'Innerer Gesteinsplanet',
                umlaufzeit: '365,25 Tage', taglaenge: '23h 56min', temperatur: 'ca. +15¬∞C',
                funFacts: [ 'Die Erde ist der einzige bekannte Planet mit fl√ºssigem Wasser an der Oberfl√§che.', 'Unsere Atmosph√§re sch√ºtzt uns vor sch√§dlicher Sonnenstrahlung und Meteoriten.']
            };
            clickableObjects.push(earth); 
            earthTiltPivot.add(earth); 
            
//  Achsenlinie erstellen 
            const axisMat = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 }); // Helles Gelb
            const axisPoints = [
                new THREE.Vector3(0, -EARTH_RADIUS * 1.5, 0),
                new THREE.Vector3(0, EARTH_RADIUS * 1.5, 0)
            ];
            const axisGeo = new THREE.BufferGeometry().setFromPoints(axisPoints);
            earthAxisLine = new THREE.Line(axisGeo, axisMat);
            earthAxisLine.visible = false; // Standardm√§ssig unsichtbar
            earthTiltPivot.add(earthAxisLine); // Zur Pivot-Gruppe hinzuf√ºgen
            

//  √Ñquatorlinie erstellen 
            const equatorRadius = EARTH_RADIUS * 1.01; // 1% gr√∂√üer als die Erde
            const equatorPoints = [];
            const equatorSegments = 64;
            for (let i = 0; i <= equatorSegments; i++) {
                const angle = (i / equatorSegments) * Math.PI * 2;
                // Ein Kreis in der X-Z-Ebene des Pivots (das ist die √Ñquatorebene)
                equatorPoints.push(new THREE.Vector3(Math.cos(angle) * equatorRadius, 0, Math.sin(angle) * equatorRadius)); 
            }
            const equatorGeo = new THREE.BufferGeometry().setFromPoints(equatorPoints);
            const equatorMat = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Rot
            earthEquatorLine = new THREE.Line(equatorGeo, equatorMat);
            earthEquatorLine.visible = false; // Standardm√§√üig unsichtbar
            earthTiltPivot.add(earthEquatorLine); // Zur gekippten Pivot-Gruppe hinzuf√ºgen
            

            moonPivot = new THREE.Group();
            moonPivot.rotation.x = MOON_TILT_RAD; 
            scene.add(moonPivot); 

            originalMoonMaterial = new THREE.ShaderMaterial({
                vertexShader: moonVertexShader, fragmentShader: moonFragmentShader,
                uniforms: {
                    dayTexture: { value: textureLoader.load('https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/ImagesGit/Objects/Moons/2k_moon.webp') },
                    uSunPosition: { value: new THREE.Vector3(0, 0, 0) }, uEarthPosition: { value: new THREE.Vector3() }, uObjectWorldPosition: { value: new THREE.Vector3() },
                    uEarthRadius: { value: EARTH_RADIUS }, uSunRadius: { value: SUN_RADIUS }, uMoonRadius: { value: MOON_RADIUS }, uNightBrightness: { value: 0.3 },
                    uDemoActive: { value: false }, uShadowBrightness: { value: 0.0 }, uRedOverlayIntensity: { value: 0.0 } 
                }
            });
            moon = new THREE.Mesh(new THREE.SphereGeometry(MOON_RADIUS, 32, 32), originalMoonMaterial);
            moon.position.x = -MOON_DISTANCE; 
            
            moon.userData.info = {
                name: 'Mond', earthCompareRadius: '0,27x Erde', radius_km: '1.737', distance_Mio_km: '384.400 km', umlaufzeit: '27,3 Tage', temperatur: '-173¬∞C bis +127¬∞C', parentName: 'Erde',
                funFacts: [ 'Der Mond zeigt uns immer dieselbe Seite, weil er sich genau einmal pro Umlauf um sich selbst dreht.', 'Seine Anziehungskraft verursacht Ebbe und Flut auf der Erde.']
            };
            clickableObjects.push(moon); 
            moonPivot.add(moon);
            
            planetsData.forEach(data => {
                const sunOrbitPivot = new THREE.Group();
                if (data.orbitalInclination) sunOrbitPivot.rotation.x = (data.orbitalInclination * Math.PI) / 180;
                scene.add(sunOrbitPivot);
                
                const planetSystemContainer = new THREE.Group();
                sunOrbitPivot.add(planetSystemContainer);

                const planetTiltPivot = new THREE.Group();
                planetTiltPivot.rotation.z = (data.axialTilt * Math.PI) / 180;
                planetSystemContainer.add(planetTiltPivot);

                const isJupiter = (data.name === 'Jupiter');

                let material;
                // UPDATE: Generischer Check auf Ringe
                if (data.ring) {
                     material = new THREE.ShaderMaterial({
                        vertexShader: earthVertexShader, fragmentShader: planetWithRingFragmentShader, 
                        uniforms: {
                            dayTexture: { value: textureLoader.load(data.texture) }, uSunPosition: { value: new THREE.Vector3(0, 0, 0) }, uObjectWorldPosition: { value: new THREE.Vector3() },
                            uNightBrightness: { value: 0.3 }, 
                            uRingNormal: { value: new THREE.Vector3(0, 1, 0) }, 
                            uRingInnerRadius: { value: data.radius * data.ring.innerRadius },
                            uRingOuterRadius: { value: data.radius * data.ring.outerRadius },
                            uRingShadowSoftness: { value: RING_SHADOW_SOFTNESS },
                            uShadowTransparency: { value: 1.0 }
                        }
                    });
                    // √úberschreibe den Transparenzwert nur f√ºr Uranus
                    if (data.name === 'Uranus') {
                        // 0.0 = 0% Schatten-Intensit√§t (komplett aus)
                        material.uniforms.uShadowTransparency.value = 0.0;
                    }

                    planetRingMaterials.push({ mat: material, pivot: planetTiltPivot });
                } else {

                    material = new THREE.ShaderMaterial({
                        vertexShader: earthVertexShader, fragmentShader: earthFragmentShader, 
                        uniforms: {
                            dayTexture: { value: textureLoader.load(data.texture) }, 
                            uSunPosition: { value: new THREE.Vector3(0, 0, 0) }, 
                            uObjectWorldPosition: { value: new THREE.Vector3() },
                            uNightBrightness: { value: 0.3 }, 
                            uSofiDemoActive: { value: false }, 
                            uMoonPosition: { value: new THREE.Vector3() }, 
                            uMoonRadius: { value: 0.1 }, 
                            uSunRadius: { value: SUN_RADIUS },
                            uHasNightTexture: { value: false },
                            //Jupiter Moon Shadow
                            uCastMoonShadows: { value: isJupiter },
                            uMoonPositions: { value: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()] },
                            uMoonRadii: { value: [0.0, 0.0, 0.0, 0.0] }
                        }
                    });
                }

                if (isJupiter) {
                    jupiterMoonShadowUniforms = material.uniforms;
                }

                const planet = new THREE.Mesh(new THREE.SphereGeometry(data.radius, 32, 32), material);
                planet.position.set(0, 0, 0); 

                planet.userData.info = { ...data }; 
                delete planet.userData.info.name; delete planet.userData.info.radius; delete planet.userData.info.distance; delete planet.userData.info.yearDays; delete planet.userData.info.texture; delete planet.userData.info.ring; delete planet.userData.info.axialTilt; delete planet.userData.info.orbitalInclination; delete planet.userData.info.rotationSpeed; delete planet.userData.info.moons; delete planet.userData.info.ecc; delete planet.userData.info.perihelionAngle;
                planet.userData.info.name = data.name_de;
                clickableObjects.push(planet);

                // UPDATE: Generische Ringerstellung
                if (data.ring) {
                    const ringTexture = textureLoader.load(data.ring.texture);
                    ringTexture.wrapT = THREE.RepeatWrapping;
                    
                    const ringMat = new THREE.ShaderMaterial({
                        vertexShader: ringVertexShader, fragmentShader: ringFragmentShader, 
                        uniforms: {
                            ringTexture: { value: ringTexture }, uSunPosition: { value: new THREE.Vector3(0, 0, 0) }, uRingParentPosition: { value: new THREE.Vector3() },
                            uRingParentRadius: { value: data.radius }, uNightBrightness: { value: 0.3 }
                        },
                        transparent: true, side: THREE.DoubleSide
                    });
                    // Speichern f√ºr Updates
                    planetRingMaterials.push({ ringMat: ringMat, parentPlanet: planet });

                    const ringGeometry = new THREE.RingGeometry(data.radius * data.ring.innerRadius, data.radius * data.ring.outerRadius, 64);
                    ringGeometry.rotateX(Math.PI / 2); 
                    const pos = ringGeometry.attributes.position; const uv = ringGeometry.attributes.uv; 
                    const innerRadius = data.radius * data.ring.innerRadius; const outerRadius = data.radius * data.ring.outerRadius; 
                    const repeatFactor = 10; 
                    for (let i = 0; i < pos.count; i++) {
                        const x = pos.getX(i); const z = pos.getZ(i);
                        let angle = 1.0 - ((Math.atan2(z, x) / (Math.PI * 2)) + 0.5);
                        let v = angle * repeatFactor; const r = Math.sqrt(x * x + z * z);
                        let u = (r - innerRadius) / (outerRadius - innerRadius);
                        uv.setXY(i, u, v);
                    }
                    const ringMesh = new THREE.Mesh(ringGeometry, ringMat);
                    planetTiltPivot.add(ringMesh); 
                }
                planetTiltPivot.add(planet); 

                if (data.moons) {
                    data.moons.forEach(moonData => {
                        const moonOrbitPivot = new THREE.Group();
                        if (data.name === 'Saturn' || data.name === 'Jupiter') {
                            moonOrbitPivot.rotation.x = moonData.inclination || 0; 
                            planetTiltPivot.add(moonOrbitPivot);
                        } else {
                            moonOrbitPivot.rotation.x = (Math.random() * 10 - 5) * Math.PI / 180;
                            planetSystemContainer.add(moonOrbitPivot);
                        }
                        const moonMat = new THREE.ShaderMaterial({
                            vertexShader: earthVertexShader, fragmentShader: genericMoonFragmentShader, 
                            uniforms: {
                                dayTexture: { value: textureLoader.load(moonData.texture) }, uSunPosition: { value: new THREE.Vector3(0, 0, 0) }, uObjectWorldPosition: { value: new THREE.Vector3() },
                                uNightBrightness: { value: 0.3 }, uParentPosition: { value: new THREE.Vector3() }, uParentRadius: { value: data.radius }
                            }
                        });
                        const moonMesh = new THREE.Mesh(new THREE.SphereGeometry(moonData.radius, 32, 32), moonMat);
                        moonMesh.position.x = moonData.distance;
                        moonOrbitPivot.add(moonMesh);
                        otherMoons.push({ mesh: moonMesh, pivot: moonOrbitPivot, speed: moonData.speed, data: moonData, parentPlanet: planet });

                        //  Monde in Jupiters Liste eintragen 
                        if (data.name === 'Jupiter') {
                            jupiterMoons.push(moonMesh);
                        }
                        
                        const moonInfo = { ...moonData };
                        delete moonInfo.name; delete moonInfo.radius; delete moonInfo.distance; delete moonInfo.speed; delete moonInfo.texture; delete moonInfo.inclination;
                        moonMesh.userData.info = { name: `${data.name_de}-Mond: ${moonData.name}`, ...moonInfo };
                        
                        clickableObjects.push(moonMesh);
                    });
                }
                otherPlanets.push(planet);
                otherPlanetControls.push({ orbit: sunOrbitPivot, container: planetSystemContainer, tiltPivot: planetTiltPivot });
            });
        }

        function createAsteroidBelt() {
            // Konfiguration
            const asteroidCount = 4000; // Anzahl der Asteroiden (bei Performance-Problemen reduzieren)
            const startDist = 550 * SCENE_SCALE; // Kurz nach Mars
            const endDist = 650 * SCENE_SCALE;   // Vor Jupiter
            
            // 1. Geometrie & Material (Ein einfacher grauer Stein)
            // DodecahedronGeometry ist low-poly und sieht "steinig" aus
            const geometry = new THREE.DodecahedronGeometry(1.2 * SCENE_SCALE, 0); 
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x666666, 
                roughness: 0.9, 
                metalness: 0.1 
            });

            // 2. InstancedMesh erstellen (Hochleistungs-Rendering)
            asteroidInstancedMesh = new THREE.InstancedMesh(geometry, material, asteroidCount);
            
            const dummy = new THREE.Object3D();
            const asteroidData = []; // Hier speichern wir Winkel & Geschwindigkeit f√ºr jeden Stein

            for (let i = 0; i < asteroidCount; i++) {
                // Zuf√§llige Position im Ring berechnen
                const angle = Math.random() * Math.PI * 2;
                const distance = THREE.MathUtils.randFloat(startDist, endDist);
                
                // Streuung in der H√∂he (Y-Achse), damit es nicht wie eine CD aussieht, sondern Volumen hat
                const heightSpread = THREE.MathUtils.randFloatSpread(40 * SCENE_SCALE); 

                // Initiale Position setzen
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                const y = heightSpread;

                dummy.position.set(x, y, z);
                
                // Zuf√§llige Rotation und Gr√∂sse f√ºr Abwechslung
                dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                const scale = THREE.MathUtils.randFloat(0.5, 1.5);
                dummy.scale.set(scale, scale, scale);

                dummy.updateMatrix();
                asteroidInstancedMesh.setMatrixAt(i, dummy.matrix);

                // Daten f√ºr die Animation speichern
                asteroidData.push({
                    startAngle: angle,
                    distance: distance,
                    y: y,
                    // Innere Asteroiden sind schneller (Kepler l√§sst gr√ºssen, vereinfacht)
                    speed: (0.05 / (distance / (100 * SCENE_SCALE))) 
                });

                
            }

            // Daten im Mesh speichern, damit updatePositions darauf zugreifen kann
            asteroidInstancedMesh.userData.asteroids = asteroidData;

            scene.add(asteroidInstancedMesh);
            console.log("Asteroideng√ºrtel erstellt!");
        }

        //  E SKALIERBARE FUNKTION ZUM LADEN VON 3D-MODELLEN 
        function load3DModels() {
            
            // 1. Definiere alle Modelle, die wir laden wollen
            const modelsToLoad = [
                {
                    id: 'comet',
                    url: 'ImagesGit/3D-Models/comet_ice_compressed.glb',
                    type: 'template', // Ein Schalter, damit wir wissen, dass dies eine Vorlage ist
                    scale: EARTH_RADIUS * 0.15
                },

                {
                    id: 'ufo',
                    url: 'ImagesGit/3D-Models/ufo_spaceship.glb', 
                    type: 'template'
                },

                {
                    id: 'iss',
                    url: 'ImagesGit/3D-Models/iss-mid_c.glb',
                    label: 'ISS',
                    scale: 1.3, // Sehr klein, wie gew√ºnscht
                    orbitTarget: 'earth', // (Reserviert f√ºr sp√§ter)
                    altitude: EARTH_RADIUS + 0.5, // 0.5 Einheiten √ºber der Erde
                    ambientIntensity: 0.7,
                    inclination: 51.6, // Grad
                    orbitsPerDay: 15.6, // Umkreisungen pro Tag
                    updateType: 'earth_orbit', // Logik-Schalter f√ºr updatePositions
                    focusDistance: 0.4
                },

                {
                    id: 'hubble',
                    // WICHTIG: Du musst ein 3D-Modell (z.B. hubble.glb) 
                    // in deinen 'ImagesGit/3D-Models/' Ordner hochladen.
                    url: 'ImagesGit/3D-Models/hubble_telescope-v1.glb', // Pfad anpassen!
                    label: 'Hubble', // F√ºr den Fokus-Button
                    scale: 0.00001, // Ggfs. anpassen, damit es kleiner als die ISS ist
                    altitude: EARTH_RADIUS + 1.0, // ~540 km (etwas h√∂her als ISS)
                    ambientIntensity: 0.7,
                    inclination: 28.5, // Andere Bahnebene als die ISS
                    orbitsPerDay: 15.2, // Etwas langsamer als die ISS
                    updateType: 'earth_orbit', // Nutzt die gleiche Orbit-Logik
                    focusDistance: 0.2 // Etwas n√§her ranzoomen als bei der ISS
                },

                {
                    id: 'voyager1',
                    url: 'ImagesGit/3D-Models/nasa_voyager_space_probe.glb', // Datei muss existieren!
                    label: 'Voyager 1',
                    scale: 0.01, // Etwas gr√∂sser skalieren, da sie weit weg ist
                    ambientIntensity: 15.0,
                    updateType: 'static_rotation', // Bewegt sich nicht, rotiert nur
                    focusDistance: 0.3
                },

                {
                    id: 'rocket_full', // MODELL 1: Ganze Rakete
                    url: 'ImagesGit/3D-Models/saturn_v.glb', // DEIN PFAD
                    type: 'template',
                    scale: ROCKET_SIZE_SCALE * 0.001
                },
                {
                    id: 'rocket_stage2', // MODELL 2: Oberer Teil (fliegt weiter)
                    url: 'ImagesGit/3D-Models/saturn_v_1.glb', // DEIN PFAD (oder spezielles Modell)
                    type: 'template',
                    scale: ROCKET_SIZE_SCALE * 0.001
                },
                {
                    id: 'debris_stage1', // MODELL 3: Abwurf 1 (Booster)
                    url: 'ImagesGit/3D-Models/saturn_v_1_dis.glb', // DEIN PFAD
                    type: 'template',
                    scale: ROCKET_SIZE_SCALE * 0.001
                },
                {
                    id: 'debris_stage2', // MODELL 4: Abwurf 2 (Ring/Adapter)
                    url: 'ImagesGit/3D-Models/saturn_v_2_dis.glb', // DEIN PFAD
                    type: 'template',
                    scale: ROCKET_SIZE_SCALE * 0.001
                },
                {
                    id: 'capsule', // MODELL 5: Kapsel
                    url: 'ImagesGit/3D-Models/saturn_v_cockpit.glb', 
                    type: 'template',
                    scale: ROCKET_SIZE_SCALE * 0.00005
                },

                {
                    id: 'astronaut',
                    url: 'ImagesGit/3D-Models/astronaut_shadow.glb', // Bitte Datei hochladen!
                    type: 'template',
                    scale: 0.000015 * SCENE_SCALE // Start-Skalierung (wird unten angepasst)
                },

                {
                    id: 'flag',
                    url: 'ImagesGit/3D-Models/us_flag_shadow.glb', // <--- DEIN NEUES FLAGGEN MODELL
                    type: 'template',
                    scale: 0.004 * SCENE_SCALE // Skalierung anpassen!
                },

                {
                    id: 'lander',
                    url: 'ImagesGit/3D-Models/lunar_module_shadow.glb', // Bitte Datei hochladen!
                    type: 'template',
                    scale: 0.003 * SCENE_SCALE
                }
                // HIER K√ñNNTEST DU EINFACH MEHR OBJEKTE HINZUF√úGEN
                // { id: 'hubble', url: 'hubble.glb', ... }
            ];

            
            // Draco Loader initialisieren 
            const dracoLoader = new THREE.DRACOLoader();
            // WICHTIG: Pfad zu den Decoder-Dateien auf dem CDN
            dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');
            
            const loader = new THREE.GLTFLoader(loadingManager);
            // Dem GLTFLoader sagen, dass er den DracoLoader verwenden soll
            loader.setDRACOLoader(dracoLoader);

            modelsToLoad.forEach(modelData => {
                loader.load(modelData.url, (gltf) => {

                    //  Pr√ºfen, ob es eine Vorlage ist 
                    if (modelData.type === 'template') {
                        // Skalierung direkt hier anwenden, falls vorhanden +++
                        if (modelData.scale) {
                            gltf.scene.scale.set(modelData.scale, modelData.scale, modelData.scale);
                        }
                        if (modelData.id === 'comet') {
                            cometModelTemplate = gltf.scene;
                            console.log("3D-Modell-Vorlage 'Komet' erfolgreich geladen.");
                        }


                        // 2. UFO
                        else if (modelData.id === 'ufo') {
                            ufoModelTemplate = gltf.scene;
                            
                            // UFO Material aufh√ºbschen
                            ufoModelTemplate.traverse((child) => {
                                if (child.isMesh) {
                                    child.material = child.material.clone();
                                    // UFO leuchten lassen
                                    child.material.emissive = new THREE.Color(0x555555); 
                                    child.material.emissiveIntensity = 100;
                                    if (child.material.metalness > 0.5) child.material.metalness = 0.4;
                                    if (child.material.roughness < 0.5) child.material.roughness = 0.6;
                                }
                            });
                            console.log("Vorlage 'UFO' geladen.");
                        }
                        
                        // 3. RAKETEN TEILE (M√ºssen hier separat stehen!)
                        else if (modelData.id === 'rocket_full') {
                            rocketFullTemplate = gltf.scene;
                            console.log("Rakete (Full) geladen.");
                        }
                        else if (modelData.id === 'rocket_stage2') {
                            rocketStage2Template = gltf.scene;
                            console.log("Rakete (Stage 2) geladen.");
                        }
                        else if (modelData.id === 'debris_stage1') {
                            debris1Template = gltf.scene;
                            console.log("Debris (Booster) geladen.");
                        }
                        else if (modelData.id === 'debris_stage2') {
                            debris2Template = gltf.scene;
                            console.log("Debris (Ring) geladen.");
                        }
                        else if (modelData.id === 'capsule') {
                            capsuleModelTemplate = gltf.scene;
                            console.log("Kapsel geladen.");
                        }
                        else if (modelData.id === 'astronaut') {
                            astronautTemplate = gltf.scene;
                            console.log("Astronaut geladen.");
                        }
                        else if (modelData.id === 'lander') {
                            landerTemplate = gltf.scene;
                            console.log("Lander geladen.");
                        }
                        else if (modelData.id === 'flag') {
                            flagTemplate = gltf.scene;
                            console.log("Flagge geladen.");
                        }

                        return; // Wichtig: Hier abbrechen f√ºr Templates
                    }
                    

                    // Das geladene 3D-Modell (die "scene")
                    const modelScene = gltf.scene;
                    
                    // Skalierung anwenden
                    modelScene.scale.set(modelData.scale, modelData.scale, modelData.scale);
                    
                    if (modelData.id === 'iss') {
                        // Rotiere das Modell um 90 Grad (PI/2 Radianten) um seine "Hoch"-Achse (Y).
                        modelScene.rotation.z = -(Math.PI / 2); 
                        
                        // : Helle die ISS auf (Konstantes Leuchten)
                        modelScene.traverse(child => {
                            if (child.isMesh) {
                                child.material = child.material.clone();
                                
                                child.material.metalness = 0.7; // Sollte leicht metallisch bleiben
                            }
                        });
                    }

                    if (modelData.id === 'hubble') {
                        modelScene.rotation.z = -(Math.PI / 1.2); 
                        
                        // : Helle Hubble auf
                        modelScene.traverse(child => {
                            if (child.isMesh) {
                                child.material = child.material.clone();
                                // Ein sehr leichtes, fast wei√ües Leuchten (dezenter als ISS)
                                
                                child.material.roughness = 0.8; // Wirkt matt und reflektiert weniger Schwarz
                            }
                        });
                    }

                    // ... nach Hubble ...

                    if (modelData.id === 'voyager1') {
                        // 1. Position: Weit draussen, leicht oberhalb der Ekliptik
                        // Voyager fliegt Richtung Sternbild Schlangentr√§ger
                        const dist = 3500 * SCENE_SCALE; // Weit weg, aber noch vor den Sternen (5000)
                        
                        
                        
                        // Ausrichtung: Zur Erde schauen lassen
                        modelScene.lookAt(0, 0, 0);

                        // 2. Material: Aufhellen (Emissive), damit man sie im All sieht
                        modelScene.traverse(child => {
                            if (child.isMesh) {
                                child.material = child.material.clone();
                                
                                child.material.metalness = 0.8; 
                                child.material.roughness = 0.4; 
                            }
                        });

                        // 3. INFOS f√ºr das Popup
                        modelScene.userData.info = {
                            name: 'Voyager 1',
                            earthCompareRadius: 'ca. 3,7m Durchmesser (Antenne)',
                            radius_km: '24,4 Mrd. km', // Wir nutzen das Feld f√ºr "Distanz zur Erde"
                            umlaufzeit: 'N/A (Verl√§sst Sonnensystem)',
                            taglaenge: 'Seit 1977 unterwegs', // Wir nutzen das Feld f√ºr "Startdatum"
                            parentName: 'Erde',
                            funFacts: [
                                'Ist das am weitesten entfernte von Menschen gebaute Objekt.',
                                'Hat das Sonnensystem verlassen und befindet sich im interstellaren Raum.',
                                'Tr√§gt eine "Golden Record" mit Ger√§uschen und Bildern der Erde f√ºr Ausserirdische.'
                            ]
                        };
                        
                        // Zur Klick-Liste hinzuf√ºgen
                        clickableObjects.push(modelScene);
                    }

                    //  START: ER CODE F√úR ISS-INFO 
                    if (modelData.id === 'iss') {
                        
                        // 1. Info-Objekt definieren
                        // Wir verwenden Felder wieder, die 'showInfoPopup' schon kennt.
                        modelScene.userData.info = {
                            name: 'ISS (Internationale Raumstation)',
                            earthCompareRadius: 'ca. 109m Spannweite', // Wird als "Gr√∂√üe" angezeigt
                            radius_km: 'ca. 400 km', // "missbrauchen" wir f√ºr die Flugh√∂he
                            umlaufzeit: 'ca. 90 Minuten', // "missbrauchen" wir f√ºr die Umlaufzeit
                            taglaenge: '16 pro Tag', // "missbrauchen" wir f√ºr Sonnenaufg√§nge
                            parentName: 'Erde', // Wichtig f√ºr Schritt 2
                            funFacts: [
                                'Die ISS umkreist die Erde mit ca. 28.000 km/h.',
                                'Sie ist das gr√∂√üte k√ºnstliche Objekt im Erdorbit.',
                                'Astronauten an Bord erleben 16 Sonnenauf- und -unterg√§nge pro Tag.'
                            ]
                        };

                        // 2. Objekt zur globalen Klick-Liste hinzuf√ºgen
                        clickableObjects.push(modelScene);
                    }

                    //  Hubble-Info-Daten 
                    if (modelData.id === 'hubble') {
                        
                        // 1. Info-Objekt definieren
                        modelScene.userData.info = {
                            name: 'Hubble-Weltraumteleskop (HST)',
                            earthCompareRadius: 'ca. 13,2m lang', // "Gr√∂√üe"
                            radius_km: 'ca. 540 km', // "Flugh√∂he"
                            umlaufzeit: 'ca. 95 Minuten', 
                            taglaenge: '15.2 pro Tag', // "Sonnenaufg√§nge"
                            parentName: 'Erde',
                            funFacts: [
                                'Startete 1990 und hat unser Bild vom Universum revolutioniert.',
                                'Fliegt au√üerhalb der Erdatmosph√§re f√ºr gestochen scharfe Bilder.',
                                'Hat die ber√ºhmten "Deep Fields" mit Tausenden Galaxien fotografiert.'
                            ]
                        };

                        // 2. Objekt zur globalen Klick-Liste hinzuf√ºgen
                        clickableObjects.push(modelScene);
                    }
                    // Erstelle den Pivot-Punkt (den Rotations-Anker)
                    // Dieser Pivot wird an der Position der Erde sein
                    const pivot = new THREE.Group();
                    
                    // Positioniere das Modell *innerhalb* des Pivots
                    // (auf der X-Achse, in der gew√ºnschten H√∂he)
                    modelScene.position.x = modelData.altitude;

                    if (modelData.id === 'voyager1') {
                        const dist = 3500 * SCENE_SCALE;
                        // Hier setzen wir die Position des gesamten Pivots im Raum
                        pivot.position.set(dist * 0.5, dist * 0.3, -dist * 0.8);
                        
                        // Wichtig: Da wir den Pivot verschoben haben, muss das Modell im Pivot
                        // auf 0,0,0 zur√ºckgesetzt werden (sonst addiert sich 'altitude' noch dazu)
                        modelScene.position.set(0, 0, 0); 
                    }
                    
                    // F√ºge das Modell zum Pivot hinzu
                    pivot.add(modelScene);

                    if (modelData.id === 'iss' || modelData.id === 'hubble' || modelData.id === 'voyager1') {
    
                        const intensity = modelData.ambientIntensity !== undefined ? modelData.ambientIntensity : 0.4;
                        
                        // KORREKTUR: Statt AmbientLight (global) nutzen wir PointLight (lokal)
                        // Parameter: Farbe, Intensit√§t, Distanz (Reichweite)
                        // 50 * SCENE_SCALE sorgt daf√ºr, dass das Licht die Asteroiden nicht erreicht.
                        const localLight = new THREE.PointLight(0xffffff, intensity * 1.5, 50 * SCENE_SCALE);
                        
                        // WICHTIG: Das Licht muss genau dort sein, wo das Modell ist
                        localLight.position.copy(modelScene.position);
                        
                        // Das Licht leicht versetzen, damit es das Modell sch√∂n anstrahlt (optional)
                        localLight.position.y += 2 * SCENE_SCALE; 
                        localLight.position.z += 2 * SCENE_SCALE;

                        pivot.add(localLight);
                    }
                    
                    // F√ºge den Pivot zur Haupt-Szene hinzu
                    scene.add(pivot);

                    // Speichere alle Infos in unserem globalen Array
                    const modelObject = {
                        scene: modelScene, // Das 3D-Objekt selbst
                        pivot: pivot,      // Der Rotationspunkt
                        data: modelData    // Die Konfigurationsdaten
                    };
                    loaded3DModels.push(modelObject);

                    // Fokus-Button erstellen, falls ein Label vorhanden ist 
                    if (modelData.label) {
                        const btnContainer = document.getElementById('human-objects-focus-buttons');
                        const btn = document.createElement('button');
                        // Wir verwenden die 'btn-planet'-Klasse wieder, da sie gut aussieht
                        btn.className = 'btn btn-planet'; 
                        btn.textContent = modelData.label;
                        
                        btn.addEventListener('click', () => {
                            checkAndEndDemo();
                            // Wichtig: Wir fokussieren die 'scene' (das THREE.Group-Objekt)
                            setFocus(modelObject.scene); 
                        });
                        
                        // Speichere eine Referenz zum Button, damit wir ihn in setFocus() 'aktiv' schalten k√∂nnen
                        modelObject.focusButton = btn; 
                        
                        btnContainer.appendChild(btn);
                    }
                    
                    // Setze die initiale Sichtbarkeit basierend auf der Checkbox
                    if (humanObjectsCheckbox) {
                        // (humanObjectsCheckbox wird in setupUI() gefunden)
                        const isChecked = humanObjectsCheckbox.checked;
                        modelScene.visible = isChecked;
                        pivot.visible = isChecked; // Auch Pivot steuern
                    }
                    const asteroidsCheckbox = document.getElementById('asteroids-checkbox');
                    asteroidsCheckbox.addEventListener('change', (e) => {
                        if (asteroidInstancedMesh) {
                            asteroidInstancedMesh.visible = e.target.checked;
                        }
                    });
                    
                    // Initialen Status setzen (falls beim Start abgew√§hlt)
                    if (asteroidInstancedMesh) {
                        asteroidInstancedMesh.visible = asteroidsCheckbox.checked;
                    }

                    console.log(`3D-Modell '${modelData.id}' erfolgreich geladen.`);

                }, undefined, (error) => {
                    console.error(`Fehler beim Laden des Modells '${modelData.id}':`, error);
                });
            });
        }
        //  ENDE E FUNKTION 

        function createOrbits() {
            const createEllipticalOrbitLine = (a, e, perihelionAngle, color, segments = 1024) => {
                const points = [];
                for (let i = 0; i <= segments; i++) {
                    const nu = (i / segments) * Math.PI * 2;
                    const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
                    const x_orb = r * Math.cos(nu);
                    const z_orb = r * Math.sin(nu); 
                    const x_final = x_orb * Math.cos(perihelionAngle) - z_orb * Math.sin(perihelionAngle);
                    const z_final = x_orb * Math.sin(perihelionAngle) + z_orb * Math.cos(perihelionAngle);
                    points.push(new THREE.Vector3(x_final, 0, -z_final)); 
                }
                return new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: color }));
            };

            const createCircleOrbit = (radius, color, segments = 512) => {
                 const points = [];
                 for (let i = 0; i <= segments; i++) {
                     const angle = (i / segments) * Math.PI * 2;
                     points.push(new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
                 }
                 return new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: color }));
            };

            earthOrbitLine = createCircleOrbit(EARTH_DISTANCE, 0x0000FF); 
            scene.add(earthOrbitLine);

            moonOrbitLine = createCircleOrbit(MOON_DISTANCE, 0xFFFF00);
            moonOrbitLine.rotation.x = MOON_TILT_RAD; 
            scene.add(moonOrbitLine); 
            
            planetsData.forEach(data => {
                const orbitLine = createEllipticalOrbitLine(data.distance, data.ecc, data.perihelionAngle, 0x555555);
                if (data.orbitalInclination) orbitLine.rotation.x = (data.orbitalInclination * Math.PI) / 180;
                scene.add(orbitLine);
                otherPlanetOrbits.push(orbitLine);
            });
            //  Ekliptik-Fl√§chen erstellen 
            // Erde (Blau)
            const earthPlaneGeo = new THREE.CircleGeometry(EARTH_DISTANCE, 512);
            earthPlaneGeo.rotateX(-Math.PI / 2); // Flach auf die XZ-Ebene legen
            const earthPlaneMat = new THREE.MeshBasicMaterial({
                color: 0x00aaff, // Hellblau
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            earthEclipticPlane = new THREE.Mesh(earthPlaneGeo, earthPlaneMat);
            earthEclipticPlane.visible = false; // Standardm√§ssig aus
            scene.add(earthEclipticPlane);

            // Mond (Gelb)
            const moonPlaneGeo = new THREE.CircleGeometry(MOON_DISTANCE, 256);
            moonPlaneGeo.rotateX(-Math.PI / 2); // Flach auf die XZ-Ebene legen
            const moonPlaneMat = new THREE.MeshBasicMaterial({
                color: 0xffff99, // Hellgelb
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            moonEclipticPlane = new THREE.Mesh(moonPlaneGeo, moonPlaneMat);
            
            // WICHTIG: Die Neigung der Mondbahn anwenden
            moonEclipticPlane.rotation.x = MOON_TILT_RAD; 
            
            moonEclipticPlane.visible = false; // Standardm√§ssig aus
            scene.add(moonEclipticPlane);
            
        }

        function setupUI() {
             const uiContainer = document.getElementById('ui-container');
            const toggleBtn = document.getElementById('toggle-ui');
            toggleBtn.addEventListener('click', () => {
                uiContainer.classList.toggle('minimized');
                toggleBtn.textContent = uiContainer.classList.contains('minimized') ? '‚ò∞' : '‚úï';
                toggleBtn.title = uiContainer.classList.contains('minimized') ? 'Men√º anzeigen' : 'Men√º verbergen';
            });
            
            orbitCheckbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                earthOrbitLine.visible = isChecked;
                moonOrbitLine.visible = isChecked;
            });
            earthOrbitLine.visible = orbitCheckbox.checked;
            moonOrbitLine.visible = orbitCheckbox.checked;

//  Listener f√ºr √Ñquator-Checkbox 
            const equatorCheckbox = document.getElementById('equator-checkbox');
            equatorCheckbox.addEventListener('change', (e) => {
                if (earthEquatorLine) {
                    earthEquatorLine.visible = e.target.checked;
                }
            });
            // Initialen Status setzen (ausgeschaltet)
            if (earthEquatorLine) {
                earthEquatorLine.visible = equatorCheckbox.checked;
            }


            //  Listener f√ºr Ekliptik-Fl√§chen 
            eclipticPlaneCheckbox = document.getElementById('ecliptic-plane-checkbox');
            eclipticPlaneCheckbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                if (earthEclipticPlane) earthEclipticPlane.visible = isChecked;
                if (moonEclipticPlane) moonEclipticPlane.visible = isChecked;
            });
            // Initialen Status setzen
            if (earthEclipticPlane) earthEclipticPlane.visible = eclipticPlaneCheckbox.checked;
            if (moonEclipticPlane) moonEclipticPlane.visible = eclipticPlaneCheckbox.checked;
            
            
            //3D-Mensch. Objekt
            //3D-Mensch. Objekt
            humanObjectsCheckbox = document.getElementById('human-objects-checkbox');
            const humanObjectsBtnContainer = document.getElementById('human-objects-focus-buttons'); // 

            humanObjectsCheckbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                
                // 1. Modelle ein/ausblenden (wie bisher)
                loaded3DModels.forEach(model => {
                    model.scene.visible = isChecked;
                    model.pivot.visible = isChecked; 
                });
                
                // 2. : Button-Container ein/ausblenden
                if (humanObjectsBtnContainer) {
                    humanObjectsBtnContainer.style.display = isChecked ? 'flex' : 'none';
                }
            });

            // Initialen Status beim Laden setzen
            const isCheckedInitially = humanObjectsCheckbox.checked; // Ist jetzt 'false'
            loaded3DModels.forEach(model => {
                model.scene.visible = isCheckedInitially;
                model.pivot.visible = isCheckedInitially;
            });
            
            // : Button-Container initial ausblenden
            if (humanObjectsBtnContainer) {
                humanObjectsBtnContainer.style.display = isCheckedInitially ? 'flex' : 'none';
            }
            // Initialen Status beim Laden setzen
            loaded3DModels.forEach(model => {
                const isChecked = humanObjectsCheckbox.checked;
                model.scene.visible = isChecked;
                model.pivot.visible = isChecked;
            });

            planetsVisibleCheckbox.addEventListener('change', (e) => {
                const isVisible = e.target.checked;
                otherPlanetControls.forEach(ctrl => { ctrl.orbit.visible = isVisible; });
                // *** √ÑNDERUNG 3: Listener muss auch Monde steuern ***
                otherMoons.forEach(moonObj => { moonObj.mesh.visible = isVisible; });
                planetFocusContainer.style.display = isVisible ? 'grid' : 'none';
            });
            planetsOrbitCheckbox.addEventListener('change', (e) => {
                const isVisible = e.target.checked;
                otherPlanetOrbits.forEach(orbit => { orbit.visible = isVisible; });
            });
            const planetsInitiallyVisible = planetsVisibleCheckbox.checked;
            otherPlanetControls.forEach(ctrl => { ctrl.orbit.visible = planetsInitiallyVisible; });
            const orbitsInitiallyVisible = planetsOrbitCheckbox.checked;
            otherPlanetOrbits.forEach(orbit => { orbit.visible = orbitsInitiallyVisible; });
            planetFocusContainer.style.display = planetsInitiallyVisible ? 'grid' : 'none';
            
            darknessSlider.addEventListener('input', (e) => {
                const brightness = parseFloat(e.target.value);
                earth.material.uniforms.uNightBrightness.value = brightness;
                originalMoonMaterial.uniforms.uNightBrightness.value = brightness;
                otherPlanets.forEach(planet => { planet.material.uniforms.uNightBrightness.value = brightness; });
                otherMoons.forEach(moonObj => { moonObj.mesh.material.uniforms.uNightBrightness.value = brightness; });
                
                // UPDATE: Loop durch alle Ring-Materials
                planetRingMaterials.forEach(entry => {
                    if (entry.ringMat) entry.ringMat.uniforms.uNightBrightness.value = brightness;
                });

                surfaceObjectsMaterials.forEach(mat => {
                    if (mat.uniforms && mat.uniforms.uNightBrightness) {
                        mat.uniforms.uNightBrightness.value = brightness;
                    }
                });
                
                darknessLabel.textContent = brightness.toFixed(2);
            });
            
            speedSlider.addEventListener('input', onSpeedSliderChange);
            onSpeedSliderChange(); 
            playPauseBtn.addEventListener('click', togglePlay);
            
            // *** √ÑNDERUNG 2: Listener f√ºr Zur√ºckspul-Button ***
            const rewindBtn = document.getElementById('rewind-btn');
            rewindBtn.addEventListener('click', toggleRewind);
            //  Ende √Ñnderung 2 
            
            const daySlider = document.getElementById('day-slider');
            daySlider.addEventListener('input', () => {
                pauseSimulation();
                currentDay = parseFloat(daySlider.value);
                if (currentDayLabelEl) currentDayLabelEl.textContent = formatDayCount(currentDay);
                updatePositions(currentDay);
                updateUI();

                //  HIER STARTET DEIN ER CODE 

                // 1. Pr√ºfen, ob ein Objekt (und kein String wie 'system') fokussiert ist
                if (cameraFocus && typeof cameraFocus !== 'string') {

                    // 2. Die E Position des Objekts holen
                    let newTargetPos = new THREE.Vector3();
                    cameraFocus.getWorldPosition(newTargetPos);

                    // 3. Die Differenz (delta) zur LETZTEN bekannten Position berechnen
                    //    (lastCameraTargetPos wurde im letzten Frame von animate() gesetzt)
                    const delta = newTargetPos.clone().sub(lastCameraTargetPos);

                    // 4. Kamera und Kontroll-Ziel um dieses Delta verschieben
                    camera.position.add(delta);
                    controls.target.add(delta);

                    // 5. Die "letzte" Position f√ºr den n√§chsten "input"-Event aktualisieren
                    //    (damit es auch beim weiteren Ziehen funktioniert)
                    lastCameraTargetPos.copy(newTargetPos);
                }
                //  HIER ENDET DEIN ER CODE 
            });
            
            const initialBrightness = parseFloat(darknessSlider.value);
            earth.material.uniforms.uNightBrightness.value = initialBrightness;
            originalMoonMaterial.uniforms.uNightBrightness.value = initialBrightness;
            otherPlanets.forEach(planet => { planet.material.uniforms.uNightBrightness.value = initialBrightness; });
            otherMoons.forEach(moonObj => { moonObj.mesh.material.uniforms.uNightBrightness.value = initialBrightness; });
            
            planetRingMaterials.forEach(entry => {
                if (entry.ringMat) entry.ringMat.uniforms.uNightBrightness.value = initialBrightness;
            });

            darknessLabel.textContent = initialBrightness.toFixed(2);

            // ### √ÑNDERUNG: checkAndEndDemo() zu allen Fokus-Buttons hinzugef√ºgt ###
            document.getElementById('focus-system').addEventListener('click', () => {
                checkAndEndDemo();
                setFocus(sun);
            });
            document.getElementById('focus-earth').addEventListener('click', () => {
                checkAndEndDemo();
                if (isRealScaleActive) {
                    let earthPos = new THREE.Vector3();
                    earth.getWorldPosition(earthPos); 
                    const offsetDir = earthPos.clone().normalize(); 
                    offsetDir.y = 0.2; 
                    offsetDir.normalize();
                    const endPos = earthPos.clone().add(offsetDir.multiplyScalar(EARTH_RADIUS * 10)); 
                    flyTo(endPos, earthPos, 1.5, earth);
                } else {
                    setFocus(earth);
                }
            });
            document.getElementById('focus-moon').addEventListener('click', () => {
                checkAndEndDemo();
                if (isRealScaleActive) {
                    let moonPos = new THREE.Vector3();
                    moon.getWorldPosition(moonPos);
                    const sunToMoonDir = moonPos.clone().normalize();
                    sunToMoonDir.y = 0.25;
                    sunToMoonDir.normalize();
                    const endPos = moonPos.clone().add(sunToMoonDir.multiplyScalar(MOON_RADIUS * 12)); 
                     flyTo(endPos, moonPos, 2.0, moon); 
                } else {
                    setFocus(moon);
                }
            });

            document.getElementById('focus-ecliptic').addEventListener('click', () => {
                checkAndEndDemo();
                
                //  Indikatoren-Logik 
                resetActiveIndicators();
                document.getElementById('focus-ecliptic').classList.add('active');
                

                //  üí° HIER DIE EN ZEILEN F√úR DIE LOGIK 
                
                // 1. Andere Planeten und ihre Bahnen ausblenden
                toggleOtherPlanets(false); 
                
                // 2. Sicherstellen, dass Erd- & Mondbahn ihrer Checkbox folgen (wie gew√ºnscht)
                restoreOrbitLines(); 
                
                //  üí° ENDE  
                
                cameraFocus = 'ecliptic_side_view'; 
                let earthPos = new THREE.Vector3();
                earth.getWorldPosition(earthPos);
                const target = new THREE.Vector3(0, 0, 0); 
                let offset = earthPos.clone().normalize().multiplyScalar(40);
                let sideOffset = new THREE.Vector3(-earthPos.z, 0, earthPos.x).normalize().multiplyScalar(4); 
                const endPos = earthPos.clone().add(offset).add(sideOffset);
                endPos.y = 0; 
                flyTo(endPos, target, 2.0, 'ecliptic_side_view'); 
            });

            //  Listener f√ºr Frequenz-Demo 
            document.getElementById('demo-freq').addEventListener('click', startFrequencyDemo);
            

            document.getElementById('demo-sofi').addEventListener('click', () => startDemo('sofi'));
            document.getElementById('demo-mofi').addEventListener('click', () => startDemo('mofi'));
            
            //  End-Button-Listener angepasst 
            endDemoBtn.addEventListener('click', () => {
                if (isFrequencyDemoActive) {
                    endFrequencyDemo();
                } else if (isDemoActive) {
                    endDemo();
                }
            });
            
            
            document.getElementById('real-scale-btn').addEventListener('click', () => {
                checkAndEndDemo();
                toggleRealScale();
            });
            
            //  Listener f√ºr Real-Dist-Button 
            document.getElementById('real-dist-btn').addEventListener('click', () => {
                // checkAndEndDemo() wird nicht ben√∂tigt, da es bereits in toggleRealScale() passiert
                // und dieser Knopf nur dann sichtbar ist.
                toggleRealDistance();
            }); 
            
            
            demoSpeedSlider.addEventListener('input', onDemoSpeedSliderChange);
            onDemoSpeedSliderChange();

            document.querySelectorAll('#moon-phases-ui button').forEach(btn => {
                const index = parseInt(btn.dataset.phaseIndex);
                btn.addEventListener('click', () => {
                    checkAndEndDemo();
                    jumpToPhase(index);
                });
                moonPhaseButtons.push(btn);
            });

            followCometBtn.addEventListener('click', () => {
                if (comet && comet.mesh) {
                    setFocus(comet.mesh, 1.5);
                }
            });

            document.getElementById('comet-speed-checkbox').addEventListener('change', (e) => {
                cometTimeScale = e.target.checked ? 3.0 : 1.0;
            });
            
            planetsData.forEach((data, index) => {
                const btn = document.createElement('button');
                btn.id = `focus-${data.name.toLowerCase()}`;
                btn.className = 'btn btn-planet'; 
                let btnName = data.name_de;
                
                if (data.name === 'Pluto') {
                    btnName = '(Pluto)';
                } else if (btnName.includes('(')) {
                    btnName = btnName.split('(')[0].trim(); 
                }

                btn.textContent = btnName;
                btn.addEventListener('click', () => {
                    checkAndEndDemo();
                    setFocus(otherPlanets[index]);
                });
                planetFocusContainer.appendChild(btn);
            });
            
            document.getElementById('popup-close-btn').addEventListener('click', () => {
                document.getElementById('info-popup').style.display = 'none';
            });
            infoToastButton.addEventListener('click', () => {
                if (currentSelectedInfo) {
                    showInfoPopup(currentSelectedInfo);
                    infoToastButton.style.display = 'none'; 
                    currentSelectedInfo = null; 
                }
            });

            //  UFO Dialog Listener 
            document.getElementById('ufo-yes-btn').addEventListener('click', () => {
                

                // --- NEU: BILD √ÑNDERN (GL√úCKLICH) ---
                // Ersetze den Pfad unten mit deinem Bild f√ºr das gl√ºckliche Alien
                document.getElementById('ufo-alien-image').src = "ImagesGit/Alien/alien_happy.webp";
                
                //  Logik basierend auf Z√§hler 
                if (ufoEncounterCount === 0) {
                    document.getElementById('ufo-dialog-text').textContent = "Perfekt. Danke f√ºr die Hilfe.";
                } else if (ufoEncounterCount === 1) {
                    document.getElementById('ufo-dialog-text').textContent = "Gut wir geben unser Bestes. Wir melden uns, mit weiteren Infos! *zwoop*";
                }
                

                document.getElementById('ufo-initial-buttons').style.display = 'none';
                const closeGroup = document.getElementById('ufo-close-group');
                closeGroup.style.display = 'flex';
                
                const closeBtn = document.getElementById('ufo-close-btn');
                closeBtn.onclick = () => {
                     document.getElementById('ufo-dialog').style.display = 'none';
                     ufoState = 'leaving';
                     
                     //  Ziel anpassen & Z√§hler erh√∂hen 
                     // Nur beim ersten Mal zur Erde fliegen
                     ufoDepartureTarget = (ufoEncounterCount === 0) ? earth : null; 
                     cameraFocus = (ufoEncounterCount === 0) ? 'ufo_to_earth' : ufo;
                     if (!isPlaying) togglePlay();
                     
                     ufoEncounterCount++; // Z√§hler erh√∂hen
                     resetUfoDialog(); // Buttons zur√ºcksetzen
                     
                };
            });

            document.getElementById('ufo-no-btn').addEventListener('click', () => {
                
                // --- NEU: BILD √ÑNDERN (B√ñSE/ENTT√ÑUSCHT) ---
                // Ersetze den Pfad unten mit deinem Bild f√ºr das entt√§uschte Alien
                document.getElementById('ufo-alien-image').src = "ImagesGit/Alien/alien_angry.webp";
                
                //  Logik basierend auf Z√§hler 
                if (ufoEncounterCount === 0) {
                    document.getElementById('ufo-dialog-text').textContent = "Schade. Dann suchen wir weiter. Gute Reise, Erdling.";
                } else if (ufoEncounterCount === 1) {
                    document.getElementById('ufo-dialog-text').textContent = "Na gut, dann nicht. Wir suchen weiter nach Herrn Maurer.";
                }
                

                document.getElementById('ufo-initial-buttons').style.display = 'none';
                const closeGroup = document.getElementById('ufo-close-group');
                closeGroup.style.display = 'flex';

                const closeBtn = document.getElementById('ufo-close-btn');
                closeBtn.onclick = () => {
                     document.getElementById('ufo-dialog').style.display = 'none';
                     ufoState = 'leaving';
                     ufoDepartureTarget = null; 
                     ufoLeaveTimer = 0; 
                     ufoTargetPos.set(
                        (Math.random() - 0.5) * 20000,
                        (Math.random() - 0.5) * 20000,
                        (Math.random() - 0.5) * 20000
                     );
                     cameraFocus = ufo; 
                     if (!isPlaying) togglePlay();
                     
                     //  Z√§hler erh√∂hen 
                     ufoEncounterCount++; // Z√§hler erh√∂hen
                     resetUfoDialog(); // Buttons zur√ºcksetzen
                     
                };
            });
            
            //  Jahreszeiten-Listener (√ºberarbeitet) 
            const SEASON_SPRING_DAY = 274.19;  // Fr√ºhlings√§quinoktium (ca. 20. M√§rz)
            const SEASON_SUMMER_DAY = 0.49; // Sommersonnenwende (ca. 21. Juni)
            const SEASON_AUTUMN_DAY = 91.76; // Herbst√§quinoktium (ca. 23. September)
            const SEASON_WINTER_DAY = 182.95; // Wintersonnenwende (ca. 21. Dezember)
            
            const seasonSpringBtn = document.getElementById('season-spring');
            const seasonSummerBtn = document.getElementById('season-summer');
            const seasonAutumnBtn = document.getElementById('season-autumn');
            const seasonWinterBtn = document.getElementById('season-winter');

            seasonSpringBtn.addEventListener('click', () => {
                jumpToSeason(SEASON_SPRING_DAY, seasonSpringBtn);
            });
            seasonSummerBtn.addEventListener('click', () => {
                jumpToSeason(SEASON_SUMMER_DAY, seasonSummerBtn);
            });
            seasonAutumnBtn.addEventListener('click', () => {
                jumpToSeason(SEASON_AUTUMN_DAY, seasonAutumnBtn);
            });
            seasonWinterBtn.addEventListener('click', () => {
                jumpToSeason(SEASON_WINTER_DAY, seasonWinterBtn);
            });
            

            //  DOM-Elemente und Listener f√ºr Frequenz-Demo holen 
            freqDemoControls = document.getElementById('freq-demo-controls');
            realRatioCheckbox = document.getElementById('real-ratio-checkbox');
            realRatioCheckbox.addEventListener('change', applyFrequencyDemoScaling);
            
            // Logik f√ºr Scroll-Indikator
            const scrollContent = document.getElementById('ui-scrollable-content');
            const scrollIndicator = document.getElementById('scroll-indicator');

            function checkScrollIndicator() {
                if (!scrollContent || !scrollIndicator) return;

                // Pr√ºfen: Ist der Inhalt h√∂her als das Fenster? (Scrollbar n√∂tig?)
                const isScrollable = scrollContent.scrollHeight > scrollContent.clientHeight;
                
                // Pr√ºfen: Sind wir schon ganz unten? (5px Toleranz)
                const isAtBottom = scrollContent.scrollHeight - scrollContent.scrollTop - scrollContent.clientHeight < 5;

                // Pfeil zeigen, wenn scrollbar UND noch nicht unten
                if (isScrollable && !isAtBottom) {
                    scrollIndicator.style.display = 'block';
                } else {
                    scrollIndicator.style.display = 'none';
                }
            }

            // Listener: Pr√ºfen beim Scrollen
            scrollContent.addEventListener('scroll', checkScrollIndicator);
            // Listener: Pr√ºfen wenn Fenstergr√∂sse sich √§ndert
            window.addEventListener('resize', checkScrollIndicator);
            
            // Listener: Pr√ºfen wenn Men√º auf/zugeklappt wird (verz√∂gert)
            document.getElementById('toggle-ui').addEventListener('click', () => {
                setTimeout(checkScrollIndicator, 350);
            });

            // Einmal beim Start pr√ºfen
            checkScrollIndicator();
        }

        //  Komet Funktionen 
        function spawnComet() {
            if (comet) {
                comet.destroy(); 
            }
            comet = new Comet(scene);
            cometSpawnTimer = THREE.MathUtils.randFloat(600, 1200); 
            
            // UPDATE: Nur anzeigen wenn NICHT im Real-Scale-Modus
            if (!isRealScaleActive) {
                if (cometControls) cometControls.style.display = 'block';
                if (followCometBtn) followCometBtn.style.display = 'block';
            } else {
                // Merken, dass es eigentlich sichtbar sein sollte
                if (cometControls) cometControls.dataset.wasVisible = 'true';
            }

            document.getElementById('comet-speed-checkbox').checked = false;
            cometTimeScale = 1.0;

            if (!isPlaying) togglePlay();
        }
        // --


        //  UFO Funktionen 
        //  E createUFO() FUNKTION 
        function createUFO() {
            if (ufoModelTemplate) {
                //  1. 3D-Modell-Version 
                ufo = ufoModelTemplate.clone();
                
                // ‚ùó WICHTIG: Skalierung anpassen!
                // Das alte UFO war ca. 3 Einheiten breit (Radius 1.5 * 2).
                // Wir skalieren das e Modell auf diese Gr√∂sse.
                const ufoTargetWidth = 1.5 * SCENE_SCALE;
                
                try {
                    // Automatische Skalierung basierend auf der Modellgr√∂sse
                    const box = new THREE.Box3().setFromObject(ufo);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scaleFactor = ufoTargetWidth / maxDim;
                    ufo.scale.set(scaleFactor, scaleFactor, scaleFactor);
                } catch (e) {
                    // Fallback, falls die Box-Berechnung fehlschl√§gt
                    ufo.scale.set(1.0, 1.0, 1.0); 
                    console.error("Konnte UFO-Gr√∂sse nicht automatisch anpassen:", e);
                }

            } else {
                //  2. Fallback-Version (Dein alter Code) 
                // (Falls das 3D-Modell nicht geladen werden konnte)
                console.warn("UFO-Modell nicht geladen, verwende Fallback-Geometrie.");
                const ufoGroup = new THREE.Group();
                const saucerGeo = new THREE.CylinderGeometry(0.5 * SCENE_SCALE, 1.5 * SCENE_SCALE, 0.3 * SCENE_SCALE, 16);
                const saucerMat = new THREE.MeshStandardMaterial({ color: 0x888888, emissive: 0x444444, metalness: 0.8, roughness: 0.2 });
                const saucer = new THREE.Mesh(saucerGeo, saucerMat);
                ufoGroup.add(saucer);
                const cockpitGeo = new THREE.SphereGeometry(0.6 * SCENE_SCALE, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.5);
                const cockpitMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00aaaa, metalness: 0.5, roughness: 0.1, transparent: true, opacity: 0.8 });
                const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
                cockpit.position.y = 0.15 * SCENE_SCALE; 
                ufoGroup.add(cockpit);
                ufo = ufoGroup;
            }

            //  3. Gemeinsame Logik (unver√§ndert) 
            ufo.userData.isUFO = true; 
            clickableObjects.push(ufo);
            scene.add(ufo);
        }
        //  ENDE E FUNKTION 

        function spawnUFO() {
            if (!ufo) createUFO();
            ufoDepartureTarget = null; 
            const startAngle = Math.random() * Math.PI * 2;
            const startDist = 1500 * SCENE_SCALE;
            ufo.position.set(
                Math.cos(startAngle) * startDist,
                (Math.random() - 0.5) * 300 * SCENE_SCALE,
                Math.sin(startAngle) * startDist
            );
            ufoState = 'approaching_planet';
            pickNextPlanetTarget();
            ufo.visible = true;
        }

        function pickNextPlanetTarget() {
            const potentialTargets = clickableObjects.filter(obj => {
                
                // 1. Standard-Ausschl√ºsse (Sich selbst, aktuelles Ziel, UFOs)
                if (obj === ufo || obj.userData.isUFO || obj === ufoCurrentTargetObject) return false;

                // 2. Die gro√üen Himmelsk√∂rper ausschlie√üen
                if (obj === earth || obj === moon) return false;

                // 3. Objekte im Orbit der Erde ausschlie√üen (ISS, Hubble)
                if (obj.userData && obj.userData.info) {
                    if (obj.userData.info.parentName === 'Erde') return false;
                    if (obj.userData.info.name && obj.userData.info.name.includes('Voyager')) return false;
                    if (obj.userData.info.type === 'rocket') return false;
                }

                // --- NEU: MOND-OBJEKTE AUSSCHLIESSEN ---
                
                // A) Pr√ºfung √ºber unsere neue Liste (die sauberste Methode)
                // Wir pr√ºfen: Existiert die Liste UND ist das Objekt darin enthalten?
                if (typeof moonSurfaceObjects !== 'undefined' && moonSurfaceObjects.includes(obj)) {
                    return false;
                }

                // B) Sicherheits-Check: Ist das Objekt ein direktes Kind des Mondes?
                // Falls du sie versehentlich nicht in die Liste gepusht hast, f√§ngt das hier sie ab.
                if (obj.parent === moon) return false;

                // ----------------------------------------

                return true;
            });

            if (potentialTargets.length > 0) {
                const randomIndex = Math.floor(Math.random() * potentialTargets.length);
                ufoCurrentTargetObject = potentialTargets[randomIndex];
                // Optional: Log entfernen, wenn es nervt
                // console.log("üõ∏ UFO neues Ziel:", ufoCurrentTargetObject.userData.info ? ufoCurrentTargetObject.userData.info.name : "Unbekannt");
            } else {
                ufoCurrentTargetObject = sun;
            }
        }

        function updateUFO(deltaTime) {
            if (ufoState === 'inactive') {

                // Pr√ºfen, ob die Story vorbei ist.
                // ufoEncounterCount wird NACH der 3. Begegnung (Index 2) auf 3 gesetzt.
                if (ufoEncounterCount >= 3) {
                    return; // Timer nicht mehr starten, nicht mehr spawnen.
                }
                ufoSpawnTimer -= deltaTime;
                if (ufoSpawnTimer <= 0) {
                    spawnUFO();
                    ufoSpawnTimer = Math.random() * 300 + 180; 
                }
                return;
            }

            if (ufoCurrentTargetObject && (ufoState === 'approaching_planet' || ufoState === 'hovering')) {
                let targetRadius = 5.0 * SCENE_SCALE;
                if (ufoCurrentTargetObject.geometry && ufoCurrentTargetObject.geometry.parameters.radius) {
                    targetRadius = ufoCurrentTargetObject.geometry.parameters.radius;
                }
                const planetWorldPos = new THREE.Vector3();
                ufoCurrentTargetObject.getWorldPosition(planetWorldPos);
                const sunSideDir = planetWorldPos.clone().normalize().negate(); 
                sunSideDir.y += 0.5; 
                sunSideDir.normalize();
                // UFO Distanz zum Planeten anpassen
                const offsetDistance = targetRadius * 1.3 + 4 * SCENE_SCALE; 
                ufoCurrentTargetObject.getWorldPosition(ufoTargetPos).add(sunSideDir.multiplyScalar(offsetDistance));
            }

            if (ufoState === 'approaching_planet' || ufoState === 'leaving') {
                if (ufoState === 'leaving' && ufoDepartureTarget) {
                     ufoDepartureTarget.getWorldPosition(ufoTargetPos);
                     if (ufo.position.distanceTo(ufoTargetPos) < EARTH_RADIUS * 5) { 
                          ufo.visible = false;
                          ufoState = 'inactive';
                          setFocus(earth); 
                          resetUfoDialog();
                          return;
                     }
                }

                const direction = new THREE.Vector3().subVectors(ufoTargetPos, ufo.position);
                const distance = direction.length();
                let arrivalThreshold = 2.0 * SCENE_SCALE; 
                let currentSpeed = UFO_SPEED;

                if (ufoState === 'leaving') {
                    if (ufoDepartureTarget) {
                        currentSpeed = UFO_SPEED_TO_EARTH;
                    } else {
                        ufoLeaveTimer += deltaTime;
                        arrivalThreshold = 10.0 * SCENE_SCALE;
                        if (ufoLeaveTimer < 3.0) {
                             currentSpeed = UFO_SPEED * 0.5; 
                             cameraFocus = ufo; 
                        } else {
                             currentSpeed = UFO_SPEED * 10.0; 
                             cameraFocus = 'ufo_leaving_watch'; 
                        }
                        if (ufo.position.length() > 3000 * SCENE_SCALE || distance < arrivalThreshold) { 
                              ufo.visible = false;
                              ufoState = 'inactive';
                              setFocus(sun, 3.0); 
                              resetUfoDialog();
                              return;
                        }
                    }
                }

                if (distance > arrivalThreshold) {
                     direction.normalize();
                     ufo.position.add(direction.multiplyScalar(currentSpeed * deltaTime));
                     ufo.lookAt(ufoTargetPos); 
                } else {
                    if (ufoState === 'approaching_planet') {
                        ufoState = 'hovering';
                        ufoWanderTimer = Math.random() * 20 + 20; 
                    } else if (ufoState === 'leaving' && !ufoDepartureTarget) {
                          ufo.visible = false;
                          ufoState = 'inactive';
                          if (cameraFocus === ufo || cameraFocus === 'ufo_leaving_watch') setFocus(sun, 3.0); 
                          resetUfoDialog();
                    }
                }
            } else if (ufoState === 'hovering') {
                 ufo.position.copy(ufoTargetPos);
                 ufoWanderTimer -= deltaTime;
                 ufo.rotation.y += deltaTime * 1.0; 
                 if (ufoWanderTimer <= 0) {
                    ufoState = 'approaching_planet';
                    pickNextPlanetTarget();
                }
            }
        }

        function resetUfoDialog() {
            //  Setzt nur die Buttons zur√ºck 
            document.getElementById('ufo-initial-buttons').style.display = 'flex';
            document.getElementById('ufo-close-group').style.display = 'none';

            // Button-Texte auf Standard zur√ºcksetzen (f√ºr Begegnung 0 und 1)
            document.getElementById('ufo-yes-btn').textContent = "Ja, dort lang! üëâ";
            document.getElementById('ufo-no-btn').textContent = "Keine Ahnung ü§∑‚Äç‚ôÇÔ∏è";
            document.getElementById('ufo-close-btn').textContent = "Kommunikation beenden";
            
            // --- NEU: BILD ZUR√úCKSETZEN ---
            // Hier muss wieder das Standard-Bild rein (Alien_Nisu.webp)
            document.getElementById('ufo-alien-image').src = "ImagesGit/Alien/Alien_Nisu.webp";
        }
        
        //  Setzt den Dialogtext basierend auf dem Z√§hler 
        function setupUfoDialogText() {
            const dialog = document.getElementById('ufo-dialog');
            const titleEl = dialog.querySelector('h3');
            const textEl = document.getElementById('ufo-dialog-text');
            const initialButtons = document.getElementById('ufo-initial-buttons');
            const closeGroup = document.getElementById('ufo-close-group');
            const closeBtn = document.getElementById('ufo-close-btn');

            if (ufoEncounterCount === 0) {
                // Begegnung 1: Die urspr√ºngliche Nachricht
                titleEl.textContent = "üõ∏ Unbekanntes Flugobjekt";
                textEl.textContent = "Bist du in der Klasse von Herrn Lehmann? Wir sind auf dem Weg zur Erde, um Herrn Maurer zu entf√ºhren. Er hat wichtige Informationen √ºber das Universum, die wir brauchen. Weisst du wo er ist?";
                
                // Sicherstellen, dass die richtigen Buttons sichtbar sind
                initialButtons.style.display = 'flex';
                closeGroup.style.display = 'none';
                
            } else if (ufoEncounterCount === 1) {
                // Begegnung 2: Eine e Nachricht
                titleEl.textContent = "üõ∏ Signal [Priorit√§t Rot]";
                textEl.textContent = "Wir sind es nochmal! Wir konnten Herrn Maurer nicht festnehmen, Er hatte einen Gehilfen namens Bursatsch oder so √§hnlich. Wir hatten keine Chance gegen die Zwei. Ausserdem sehen wir auf unserem Radar, dass ein feindliches Raumschiff auf dem Weg zur Erde ist, um diese zu zerst√∂ren. Sollen wir das Problem f√ºr euch beseitigen?";
                
                // Button-Texte anpassen
                document.getElementById('ufo-yes-btn').textContent = "Ja, gerne! ‚òÑÔ∏è";
                document.getElementById('ufo-no-btn').textContent = "Nein, ist egal! üòü";

                initialButtons.style.display = 'flex';
                closeGroup.style.display = 'none';
                
            } else {
                // Begegnung 3 (und alle weiteren)
                titleEl.textContent = "üõ∏ [√úbertragung gest√∂rt]";
                textEl.textContent = "Verbindung instabil... *kzzrt* ... Herr Maurer ist... *bzzzt* ... in Gewahrsam. Mission ... *krrk* ... erfolgreich. Danke f√ºr die ... *rausch* ... Kooperation. Das Spaceship ... *bzzz* ... ist jetzt euer Probl ... *Klick* ...";
                
                // Nur den "Schliessen"-Button anzeigen
                initialButtons.style.display = 'none';
                closeGroup.style.display = 'flex';
                closeBtn.textContent = "Verbindung verloren...";

                // Eigene Klick-Logik f√ºr diesen "End-Dialog"
                closeBtn.onclick = () => {
                     document.getElementById('ufo-dialog').style.display = 'none';
                     ufoState = 'leaving';
                     ufoDepartureTarget = null; 
                     ufoLeaveTimer = 0; 
                     ufoTargetPos.set( (Math.random() - 0.5) * 20000, (Math.random() - 0.5) * 20000, (Math.random() - 0.5) * 20000 );
                     cameraFocus = ufo; 
                     if (!isPlaying) togglePlay();
                     
                     ufoEncounterCount++; // Z√§hler erh√∂hen
                     resetUfoDialog(); // Buttons f√ºr das n√§chste Mal zur√ºcksetzen
                };
            }
        }
        
        
        function flyTo(endPos, endTarget, duration = 1.0, newFocusTarget = null, callback = null) {
            isUserControllingCamera = false;
            cameraTransitionCallback = callback; 
            if (duration <= 0) {
                camera.position.copy(endPos);
                controls.target.copy(endTarget);
                lastCameraTargetPos.copy(endTarget);
                isCameraTransitioning = false;
                cameraFocus = newFocusTarget;
                if (cameraTransitionCallback) {
                    cameraTransitionCallback();
                    cameraTransitionCallback = null;
                }
                return; 
            }
            isCameraTransitioning = true;
            cameraTransitionProgress = 0.0;
            cameraTransitionDuration = duration;
            cameraTransitionStartPos.copy(camera.position);
            cameraTransitionStartTarget.copy(controls.target);
            cameraTransitionEndPos.copy(endPos);
            cameraTransitionEndTarget.copy(endTarget);
            cameraFocusAfterTransition = newFocusTarget; 
            cameraFocus = 'transitioning'; 
        }
        
        // *** √ÑNDERUNG 2: Handler-Funktionen f√ºr Zur√ºckspulen ***
        function toggleRewind() {
            // Pr√ºfen, ob wir gerade zur√ºckspulen
            if (isRewinding) {
                stopRewind();
            } else {
                // Nein -> also starten
                if (isDemoActive || isRealScaleActive) {
                    return; // Nicht w√§hrend Demos oder Real-Scale zur√ºckspulen
                }
                
                isRewinding = true; // 1. Zur√ºckspulen-Status AKTIVIEREN

                // 2. Wenn die Simulation lief, stoppe sie DIREKT
                if (isPlaying) {
                    isPlaying = false; 
                    playPauseBtn.innerHTML = iconPlay;
                    playPauseBtn.classList.remove('playing');
                }

                // 4. Aktualisiere den Rewind-Button
                document.getElementById('rewind-btn').classList.add('playing'); // Visuelles Feedback
            }
        }

        function stopRewind() {
            isRewinding = false;
            document.getElementById('rewind-btn').classList.remove('playing');
        }
        //  Ende √Ñnderung 2 

        function togglePlay() {
            // *** √ÑNDERUNG 2: Sicherstellen, dass Spulen gestoppt wird, wenn Play gedr√ºckt wird ***
            if (isRewinding) {
                stopRewind();
            }
            //  Ende √Ñnderung 2 
            
            isPlaying = !isPlaying;
            playPauseBtn.innerHTML = isPlaying ? iconPause : iconPlay;
            playPauseBtn.title = isPlaying ? "Pause" : "Abspielen";
            if (isPlaying) {
                playPauseBtn.classList.add('playing');
            } else {
                playPauseBtn.classList.remove('playing');
            }
            controls.enableZoom = true;
        }

        function pauseSimulation() {
            if (isPlaying) {
                togglePlay();
            }
            // *** √ÑNDERUNG 2: Auch Spulen anhalten ***
            if (isRewinding) {
                stopRewind();
            }
            //  Ende √Ñnderung 2 
        }
        
        function onSpeedSliderChange() {
            const value = parseFloat(speedSlider.value); 
            const minSpeed = 0.0000019013; 
            const normalSpeed = 1.0; 
            const fastSpeed = 10.0;
            const maxSpeed = 100.0; 
            
            if (value <= 80) {
                const normalizedValue = (value / 80.0);
                speed = minSpeed + (Math.pow(normalizedValue, 4)) * (normalSpeed - minSpeed);
            } else if (value <= 90) {
                const normalizedValue = (value - 80) / 10;
                speed = normalSpeed + normalizedValue * (fastSpeed - normalSpeed);
            } else {
                const normalizedValue = (value - 90) / 10;
                speed = fastSpeed + normalizedValue * (maxSpeed - fastSpeed);
            }

            // : Label-Update-Logik
            const daysPerSecondFactor = EARTH_YEAR_DAYS / 60.0; // 6.0875
            const daysPerSecond = speed * daysPerSecondFactor;
            
            let labelText = "";
            if (daysPerSecond < (1/3600)) { // Weniger als 1 Tag pro Stunde
                const hoursPerDay = (1.0 / daysPerSecond) / 3600.0;
                 labelText = `~${hoursPerDay.toFixed(0)} Std. = 1 Tag`;
            } else if (daysPerSecond < (1/60)) { // Weniger als 1 Tag pro Minute
                const minutesPerDay = (1.0 / daysPerSecond) / 60.0;
                labelText = `~${minutesPerDay.toFixed(1)} Min. = 1 Tag`;
            } else if (daysPerSecond < 1.0) { // Weniger als 1 Tag pro Sekunde
                const secondsPerDay = 1.0 / daysPerSecond;
                labelText = `~${secondsPerDay.toFixed(1)} Sek. = 1 Tag`;
            } else { // Mehr als 1 Tag pro Sekunde
                labelText = `1 Sek. = ~${daysPerSecond.toFixed(1)} Tage`;
            }
            
            const labelEl = document.getElementById('speed-label');
            if (labelEl) {
                labelEl.textContent = labelText;
            }
        }
        
        function onDemoSpeedSliderChange() {
            const value = parseFloat(demoSpeedSlider.value); 
            const minSpeed = 0.01; const normalSpeed = 0.1; const maxSpeed = 1.0;
            if (value <= 50) {
                demoLoopSpeed = minSpeed + (value / 50) * (normalSpeed - minSpeed);
            } else {
                demoLoopSpeed = normalSpeed + ((value - 50) / 50) * (maxSpeed - normalSpeed);
            }
            demoSpeedLabel.textContent = demoLoopSpeed.toFixed(2) + 'x';
        }

        // ### √ÑNDERUNG: setFocus() √ºberarbeitet f√ºr Indikatoren ###
        function setFocus(targetObj, duration = 2.0) { 
            
            //  Alle Indikatoren zu Beginn zur√ºcksetzen 
            resetActiveIndicators();
            
            // : Planeten wieder einblenden, wenn ein Fokus-Knopf gedr√ºckt wird
            // Wir pr√ºfen, ob der Fokus auf dem Mond liegt, um die Ansicht f√ºr Erd-Mond-System zu behalten.
            toggleOtherPlanets(true);
            

            // Spezialfall f√ºr 'Sonnensystem'-Button
            if (targetObj === sun) {
                cameraFocus = sun; 
                const homePos = new THREE.Vector3(-600, 450, 600); 
                const homeTarget = new THREE.Vector3(0, 0, 0); 
                document.getElementById('moon-focus-container').style.display = 'none';
                
                //  Aktiven Knopf setzen 
                document.getElementById('focus-system').classList.add('active');
                
                
                if (duration === 0) { 
                    camera.position.copy(homePos);
                    controls.target.copy(homeTarget);
                    lastCameraTargetPos.copy(homeTarget);
                    isCameraTransitioning = false; 
                    cameraFocus = sun; 
                } else {
                    flyTo(homePos, homeTarget, duration, sun); 
                }
                controls.enableZoom = true;
                return; 
            }
            
            cameraFocus = targetObj; 
            const moonContainer = document.getElementById('moon-focus-container');
            moonContainer.style.display = 'none';
            moonContainer.innerHTML = ''; 
            
            // Im Real-Scale-Modus keine Mond-Buttons anzeigen
            if (!isRealScaleActive) {
                let activePlanetIndex = -1;
                if (targetObj === otherPlanets[3]) activePlanetIndex = 3; // Jupiter
                else if (targetObj === otherPlanets[4]) activePlanetIndex = 4; // Saturn
                else {
                    // Pr√ºfen, ob ein Mond von Jup/Sat fokussiert ist
                    const moonEntry = otherMoons.find(m => m.mesh === targetObj);
                    if (moonEntry) {
                         if (moonEntry.parentPlanet === otherPlanets[3]) activePlanetIndex = 3;
                         if (moonEntry.parentPlanet === otherPlanets[4]) activePlanetIndex = 4;
                    }
                }
                
                // Wenn Jupiter oder Saturn (oder deren Monde) aktiv sind, zeige Mond-Buttons
                if (activePlanetIndex !== -1) {
                    moonContainer.style.display = 'flex';
                    const planetData = planetsData[activePlanetIndex];
                    const parentPlanetMesh = otherPlanets[activePlanetIndex];
                    if (planetData.moons) {
                        planetData.moons.forEach(moonData => {
                            const moonEntry = otherMoons.find(m => m.data.name === moonData.name && m.parentPlanet === parentPlanetMesh);
                            if (moonEntry) {
                                const btn = document.createElement('button');
                                btn.className = 'btn btn-moon';
                                btn.textContent = moonData.name;
                                btn.addEventListener('click', () => {
                                    checkAndEndDemo();
                                    setFocus(moonEntry.mesh);
                                });
                                moonContainer.appendChild(btn);
                                
                                //  Indikator f√ºr Monde setzen 
                                if (targetObj === moonEntry.mesh) {
                                    btn.classList.add('active');
                                }
                                
                            }
                        });
                    }
                }
            }
            
            //  Passenden Knopf f√ºr Indikator finden 
            let matchingBtn = null;
            if (targetObj === earth) {
                matchingBtn = document.getElementById('focus-earth');
            } else if (targetObj === moon) {
                matchingBtn = document.getElementById('focus-moon');
            } else {
                const planetIndex = otherPlanets.indexOf(targetObj);
                if (planetIndex > -1) {
                    matchingBtn = document.getElementById(`focus-${planetsData[planetIndex].name.toLowerCase()}`);
                }
                // Mond-Logik ist schon oben im "if (activePlanetIndex !== -1)"-Block
            }
            if (matchingBtn) matchingBtn.classList.add('active');
            
            // Pr√ºfen, ob es ein 3D-Modell-Button ist
            if (!matchingBtn) { 
                const modelEntry = loaded3DModels.find(m => m.scene === targetObj);
                if (modelEntry && modelEntry.focusButton) {
                    modelEntry.focusButton.classList.add('active');
                }
            }
            
            
            const radius = targetObj.geometry ? targetObj.geometry.parameters.radius : (targetObj.radius ? targetObj.radius : 1.0); 

            const targetPos = new THREE.Vector3();
            targetObj.getWorldPosition(targetPos);
            
            // Kamera-Ausrichtung im Real-Scale-Modus (bleibt wie es war)
            if (isRealScaleActive && targetObj !== sun) {
                const sunPos = new THREE.Vector3(0,0,0);
                const planetToSun = new THREE.Vector3().subVectors(sunPos, targetPos).normalize();
                const camOffset = planetToSun.clone().negate().multiplyScalar(radius * 30); 
                camOffset.y += radius * 2; 
                
                const endPos = targetPos.clone().add(camOffset);
                flyTo(endPos, targetPos, duration, targetObj);
                return;
            }

            // Dynamische Zoom-Berechnung
            const endTarget = targetPos.clone();
            let distance; // 'const' zu 'let' ge√§ndert, damit wir sie √ºberschreiben k√∂nnen

            //   (Komet Kamerafokus) 
            
            if (comet && (targetObj === comet.mesh || targetObj === comet.hitbox)) {

                // Comet Distance and Angle Calculation
                // 1. Distanz definieren (WICHTIG: Sonst ist sie "undefined" -> schwarzer Bildschirm)
                const visualRadius = comet.visualRadius || 1.0; 
                // Wir setzen hier einen Startwert, falls 'distance' noch leer ist
                if (!distance) distance = visualRadius * 7.0; 

                // 2. Distanz einschr√§nken
                distance = THREE.MathUtils.clamp(distance, visualRadius * 2.0, 500.0);

                // 3. Positionen berechnen (mit eindeutigen Namen gegen Konflikte)
                const cometSunPos = new THREE.Vector3(); 
                sun.getWorldPosition(cometSunPos);       

                // A) Vektor von der Sonne zum Kometen
                const sunToComet = new THREE.Vector3().subVectors(targetPos, cometSunPos).normalize();
                
                // B) Vektor nach "Oben" (Y-Achse)
                const up = new THREE.Vector3(0, 1, 0);

                // C) SEITENANSICHT: Das Kreuzprodukt erzeugt einen Vektor im 90¬∞-Winkel + 45¬∞ Drehung
                const cometOffsetDir = new THREE.Vector3().crossVectors(sunToComet, up).normalize();
                cometOffsetDir.applyAxisAngle(up, THREE.MathUtils.degToRad(-45));
                // Optional: Leicht von oben draufschauen
                cometOffsetDir.y = 0.3; 
                cometOffsetDir.normalize();
                
                // 4. Endposition berechnen
                const offset = cometOffsetDir.multiplyScalar(distance);
                const endPos = targetPos.clone().add(offset);

                comet.isCameraTransitioning = true;
                flyTo(endPos, endTarget, duration, targetObj);
                return; 

            // Rakete Kamera-Fokus    
            // 2b. RAKETE (Spezielle Verfolgerkamera Initialisierung)
            } else if (targetObj.userData && targetObj.userData.isRocket) {
                
                const rInst = rocketInstance; 
                // Standard-Skalierung holen
                const scaleBase = rInst ? rInst.effScale : 0.003;

                //Rakete Kamera Abstand
                distance = scaleBase * 150.0; 
                
                // Wir positionieren die Kamera "Seitlich" (X-Achse) und leicht "Oben" (Y-Achse)
                // vector(1, 0.2, 0) bedeutet: Viel Seite, bisschen Oben.
                const startDir = new THREE.Vector3(1, 2.5, 0).normalize();
                
                const offset = startDir.multiplyScalar(distance);
                const endPos = targetPos.clone().add(offset);

                // Kamerafahrt starten
                if (duration === 0) { 
                    camera.position.copy(endPos);
                    controls.target.copy(endTarget);
                    lastCameraTargetPos.copy(endTarget);
                    isCameraTransitioning = false; 
                    cameraFocus = targetObj; 
                } else {
                    flyTo(endPos, endTarget, duration, targetObj); 
                }
                controls.enableZoom = true;
                return; // Wichtig: Hier rausspringen

                
                

            // 3. STANDARD / ANDERE MODELLE
            } else {
                const modelEntry = loaded3DModels.find(m => m.scene === targetObj);
                if (modelEntry && modelEntry.data.focusDistance) {
                    distance = modelEntry.data.focusDistance;
                } else {
                    // Fallback f√ºr Planeten etc.
                    const radius = targetObj.geometry ? targetObj.geometry.parameters.radius : (targetObj.radius ? targetObj.radius : 1.0); 
                    const fovInRad = THREE.MathUtils.degToRad(camera.fov);
                    distance = (radius / 0.3) / Math.tan(fovInRad / 2); 
                }
            }
            

            const offsetDir = new THREE.Vector3(0, 0, 0).sub(targetPos).normalize();
            offsetDir.y = 0.5; 
            offsetDir.normalize(); 
            const offset = offsetDir.multiplyScalar(distance); 
            const endPos = targetPos.clone().add(offset);

            if (duration === 0) { 
                camera.position.copy(endPos);
                controls.target.copy(endTarget);
                lastCameraTargetPos.copy(endTarget);
                isCameraTransitioning = false; 
                cameraFocus = targetObj; 
            } else {
                flyTo(endPos, endTarget, duration, targetObj); 
            }
            controls.enableZoom = true;
        }
        

        //  Funktionen zur Steuerung der Frequenz-Demo 
        
        function startFrequencyDemo() {
            checkAndEndDemo(); // Beendet andere Demos (SoFi/MoFi) oder RealScale
            isFrequencyDemoActive = true;
            pauseSimulation();

            // Andere Planeten und Erdbahn ausblenden
            toggleOtherPlanets(false);
            earthOrbitLine.visible = false;
            moonOrbitLine.visible = true; // Mondbahn explizit zeigen

            // UI-Steuerung anzeigen
            freqDemoControls.style.display = 'block';
            realRatioCheckbox.checked = false;
            demoControlButtons.style.display = 'flex'; // "Demo beenden" anzeigen
            demoButtons.style.display = 'none'; // Andere Demo-Buttons verstecken

            // Zeit zur√ºcksetzen
            currentDay = 0;
            if (currentDayLabelEl) currentDayLabelEl.textContent = formatDayCount(currentDay);
            updatePositions(currentDay);
            document.getElementById('day-slider').value = currentDay;
            updateUI();

            // Initiale Skalierung anwenden (Sonne = scheinbare Gr√∂sse Mond)
            applyFrequencyDemoScaling();

            // Kamera fixieren
            controls.enabled = false;
            cameraFocus = 'eclipse_frequency_view';
            updateCamera(true); // 'true' erzwingt sofortige positionierung
        }

        function applyFrequencyDemoScaling() {
            if (!isFrequencyDemoActive) return;

            if (realRatioCheckbox.checked) {
                // Checkbox AN: Reale Winkelgr√∂ssen (beide sehr klein)
                sun.scale.set(realRatioSunScale, realRatioSunScale, realRatioSunScale);
                moon.scale.set(realRatioMoonScale, realRatioMoonScale, realRatioMoonScale);
            } else {
                // Checkbox AUS: Sonne an simulierte Mondgr√∂sse angepasst
                sun.scale.set(freqDemoSunScale, freqDemoSunScale, freqDemoSunScale);
                moon.scale.copy(originalMoonScale); // Mond auf Normalgr√∂sse
            }
        }

        function endFrequencyDemo() {
            isFrequencyDemoActive = false;

            // UI-Steuerung verstecken
            freqDemoControls.style.display = 'none';
            demoControlButtons.style.display = 'none';
            demoButtons.style.display = 'flex';

            // Skalierung zur√ºcksetzen
            sun.scale.copy(originalSunScale);
            moon.scale.copy(originalMoonScale);

            // Sichtbarkeiten wiederherstellen (basierend auf Checkboxen)
            toggleOtherPlanets(true);
            restoreOrbitLines();

            // Kamera freigeben und zur√ºcksetzen
            controls.enabled = true;
            setFocus(sun, 1.0);
        }
        
        //  ENDE E FUNKTIONEN 


        function resetToRealMode() {
            isDemoActive = false;
            demoType = '';
            controls.enableZoom = true;
            if (!isRealScaleActive) {
                demoButtons.style.display = 'flex';
            }
            demoControlButtons.style.display = 'none';
            demoSpeedControl.style.display = 'none';
            earthTiltPivot.rotation.z = EARTH_TILT_RAD;
            earth.rotation.x = 0; 
            moonPivot.rotation.x = MOON_TILT_RAD; 
            earth.material.uniforms.uSofiDemoActive.value = false;
            if (moon.material.uniforms) {
                originalMoonMaterial.uniforms.uDemoActive.value = false; 
                originalMoonMaterial.uniforms.uShadowBrightness.value = 0.0;
                originalMoonMaterial.uniforms.uRedOverlayIntensity.value = 0.0;
            }
        }
        
        function startDemo(type) {
            //  Frequenz-Demo auch beenden 
            checkAndEndDemo();
            
            
            pauseSimulation(); 
            resetToRealMode(); 
            isDemoActive = true;
            demoType = type;
            toggleOtherPlanets(false);    // 1. Planeten & Bahnen ausblenden
            earthOrbitLine.visible = false; // 2. Erdbahn explizit ausblenden
            moonOrbitLine.visible = false;  // 3. Mondbahn explizit ausblenden
            isPlaying = true; 
            playPauseBtn.textContent = 'Pause';
            playPauseBtn.classList.add('playing'); 
            controls.enableZoom = true; 
            demoButtons.style.display = 'none'; 
            demoControlButtons.style.display = 'flex'; 
            demoSpeedControl.style.display = 'block'; 
            // Fl√§chen ausblenden 
            if (earthEclipticPlane) earthEclipticPlane.visible = false;
            if (moonEclipticPlane) moonEclipticPlane.visible = false;

            //3D-Modelle ausblenden 
            loaded3DModels.forEach(model => model.pivot.visible = false);
            
            
            if (type === 'sofi') {
                earthTiltPivot.rotation.z = EARTH_TILT_RAD;
                demoDurationDays = 2; 
                currentDay = LUNAR_MONTH_DAYS * 0.0 - (demoDurationDays / 2); 
                demoLoopStartDay = currentDay;
                demoLoopEndDay = LUNAR_MONTH_DAYS * 0.0 + (demoDurationDays / 2); 
                earth.material.uniforms.uSofiDemoActive.value = true;
                earthDemoRotationOffset = 3.7 * Math.PI / 4; 
                moon.position.y = 0.3; 
            } else if (type === 'mofi') {
                earthTiltPivot.rotation.z = EARTH_TILT_RAD;
                
                // Wir definieren den idealen Mittelpunkt (Vollmond)
                const FULL_MOON_DAY = 29.53 / 2; // = 14.765
                const demoDurationDays = 3.5; 
                
                // Start bei ca. 13.015 Tagen
                currentDay = FULL_MOON_DAY - (demoDurationDays / 2); 
                demoLoopStartDay = currentDay;
                
                // Ende bei ca. 16.515 Tagen
                demoLoopEndDay = FULL_MOON_DAY + (demoDurationDays / 2); 
                
                moonPivot.position.y = MOON_RADIUS * 1.0; 
                originalMoonMaterial.uniforms.uDemoActive.value = true;
            }

            if (currentDayLabelEl) currentDayLabelEl.textContent = formatDayCount(currentDay);

            updatePositions(currentDay); 
            const daySlider = document.getElementById('day-slider');
            daySlider.value = currentDay;
            updateUI();

            if (type === 'sofi') {
                const earthPos = new THREE.Vector3();
                earth.getWorldPosition(earthPos);
                const sunPos = new THREE.Vector3(0,0,0); 
                const target = earthPos.clone();
                const direction = sunPos.clone().sub(earthPos).normalize();
                const endPos = earthPos.clone().add(direction.multiplyScalar(EARTH_RADIUS * 5)); 
                flyTo(endPos, target, 3.0, earth); 
            } else if (type === 'mofi') {
                const moonPos = new THREE.Vector3();
                moon.getWorldPosition(moonPos);
                const sunPos = new THREE.Vector3(0,0,0); 
                const target = moonPos.clone();
                const direction = sunPos.clone().sub(moonPos).normalize();
                const endPos = moonPos.clone().add(direction.multiplyScalar(MOON_RADIUS * 12)); 
                flyTo(endPos, target, 3.0, moon); 
            }
        }

        function endDemo() {
            //  Indikatoren zur√ºcksetzen 
            resetActiveIndicators();
            
            
            resetToRealMode();
            toggleOtherPlanets(true);  // Stellt Planeten gem. Checkbox wieder her
            restoreOrbitLines();       // Stellt Erd/Mond-Bahnen gem. Checkbox wieder her
            //  Fl√§chen wiederherstellen (gem. Checkbox) 
            if (eclipticPlaneCheckbox) {
                const isChecked = eclipticPlaneCheckbox.checked;
                if (earthEclipticPlane) earthEclipticPlane.visible = isChecked;
                if (moonEclipticPlane) moonEclipticPlane.visible = isChecked;
            }

            // 3D-Modelle wiederherstellen (gem. Checkbox) 
            if (humanObjectsCheckbox) {
                const isChecked = humanObjectsCheckbox.checked;
                loaded3DModels.forEach(model => model.pivot.visible = isChecked);
            }
        
            currentDay = 0; 
            if (currentDayLabelEl) currentDayLabelEl.textContent = formatDayCount(currentDay);
            const daySlider = document.getElementById('day-slider');
            daySlider.value = currentDay;
            moonPivot.position.y = 0; 
            earthDemoRotationOffset = 0.0; 
            moon.position.y = 0; 
            updatePositions(currentDay);
            updateUI();
        }

        //  Sequenzieller Realit√§tscheck 
        function toggleRealScale() {
            pauseSimulation();
            
            //  Indikatoren zur√ºcksetzen 
            resetActiveIndicators();
            
            
            if (isRealScaleActive) {
                deactivateRealScale();
                return;
            }

            activateRealScaleSequence();
        }

        function activateRealScaleSequence() {
            isRealScaleActive = true;
            realityCheckPhase = 'positioning'; 

            const scaleBtn = document.getElementById('real-scale-btn');
            scaleBtn.textContent = 'Beenden (Zur√ºck zur Simulation)';
            scaleBtn.classList.remove('btn-secondary');
            scaleBtn.classList.add('btn-danger'); // Rot f√ºr "Beenden"
            
            document.getElementById('real-dist-btn').style.display = 'block';
            
            const planetButtons = document.getElementById('planet-focus-buttons');
            document.getElementById('real-scale-controls').prepend(planetButtons); // Verschiebt das Element
            planetButtons.style.display = 'grid'; // Sicherstellen, dass es sichtbar ist
            planetButtons.style.marginTop = '0px'; // Margin zur√ºcksetzen
            
            // KORREKTUR 4: Trennlinien und Border entfernen
            planetButtons.style.borderTop = 'none';
            planetButtons.style.paddingTop = '0px';

            // KORREKTUR 4: Trennlinien ausblenden
            document.getElementById('real-scale-sep1').style.display = 'none';
            document.getElementById('real-scale-sep2').style.display = 'none';

            infoBox.textContent = "MA·∫ûSTAB: Kamera fliegt zur Position f√ºr Gr√∂ssenvergleich...";

            // UI aufr√§umen & Bahnen verstecken
            setRealScaleUiVisibility(false);
            earthOrbitLine.visible = false;
            moonOrbitLine.visible = false;

            updateSpecialObjectsVisibility(false);
            //  Fl√§chen ausblenden 
            if (earthEclipticPlane) earthEclipticPlane.visible = false;
            if (moonEclipticPlane) moonEclipticPlane.visible = false;
            // 3D-Modelle ausblenden
            loaded3DModels.forEach(model => model.pivot.visible = false);
            
            otherPlanetOrbits.forEach(o => o.visible = false);

            otherMoons.forEach(moonObj => { moonObj.mesh.visible = false; });
            
            //  Planeten explizit sichtbar machen 
            otherPlanetControls.forEach(ctrl => { ctrl.orbit.visible = true; });
            

            //  E REFERENZ-OBJEKTE 
            // 1. Geister-Sonne f√ºr Gr√∂ssenvergleich (w√§chst mit)
            const ghostGeo = new THREE.SphereGeometry(SUN_RADIUS, 32, 32);
            const ghostMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.3 });
            sunGhost = new THREE.Mesh(ghostGeo, ghostMat);
            scene.add(sunGhost);

            // Originalwerte sichern
            sun.userData.originalScale = sun.scale.clone();
            moon.userData.originalScale = moon.scale.clone();
            earthTiltPivot.userData.originalPosition = earthTiltPivot.position.clone();
            camera.userData.originalFar = camera.far;

            // Kamera-Sichtweite erh√∂hen
            camera.far = 5000000; 
            camera.updateProjectionMatrix();
            controls.maxDistance = 5000000;

            targetSunScale = 1.0; 
            targetEarthDistance = COMPARE_EARTH_DIST_VALUE;
            
            earthTiltPivot.position.set(targetEarthDistance, 0, 0);
            currentEarthDistance = targetEarthDistance;

            const planetCount = otherPlanetControls.length;
            otherPlanetControls.forEach((ctrl, index) => {
                const angle = Math.PI/3 + (index / (planetCount-1)) * (Math.PI * 4/3);
                
                // UPDATE: ALLE Planeten auf Abstand 400!
                const dist = COMPARE_EARTH_DIST_VALUE;
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                
                ctrl.container.position.set(x, 0, z);
                ctrl.tiltPivot.rotation.z = 0; 
            });

            // UPDATE: Kamera fliegt weit weg, um alles zu sehen, BEVOR Sonne w√§chst.
            // Ziel ist, dass die fertige Sonne (Radius ~272.5) ganz drauf passt.
            // Wir berechnen den n√∂tigen Abstand f√ºr 80% F√ºllung.
            const finalSunRadius = REAL_SUN_SCALE_FACTOR * SUN_RADIUS;
            const fovInRad = THREE.MathUtils.degToRad(camera.fov);
            // Formel: distance = radius / sin(fov/2) -> das w√§re f√ºr volle Breite/H√∂he.
            // Besser: tan(fov/2) = (visible_height / 2) / distance
            // Wir wollen visible_height = finalSunDiameter / 0.8
            const visibleHeightNeeded = (finalSunRadius * 2) / 0.8;
            const requiredDist = (visibleHeightNeeded / 2) / Math.tan(fovInRad / 2);

            let earthPos = new THREE.Vector3(targetEarthDistance, 0, 0);
            let sunToEarthDir = earthPos.clone().normalize();
            let camTargetPos = sunToEarthDir.multiplyScalar(requiredDist); 
            // camTargetPos.y += 100 * SCENE_SCALE; // Keine H√∂he mehr, direkt von vorne drauf schauen
            let camTargetTarget = new THREE.Vector3(0,0,0); // Blick auf Zentrum

            flyTo(camTargetPos, camTargetTarget, 2.0, null, () => {
                realityCheckPhase = 'growing';
                targetSunScale = REAL_SUN_SCALE_FACTOR;
                infoBox.textContent = "MA·∫ûSTAB: Sonne w√§chst auf reale Gr√∂sse...";
            });
        }

        function deactivateRealScale() {
            isRealScaleActive = false;
            isRealDistanceActive = false;
            realityCheckPhase = 'idle';

            const scaleBtn = document.getElementById('real-scale-btn');
            scaleBtn.textContent = 'üîç Reale Gr√∂ssen';
            scaleBtn.classList.remove('btn-danger');
            scaleBtn.classList.add('btn-secondary');
            
            document.getElementById('real-dist-btn').style.display = 'none';
            const distBtn = document.getElementById('real-dist-btn');
            distBtn.textContent = "üöÄ Reale Distanz";
            distBtn.classList.remove('btn-warning');
            distBtn.classList.add('btn-secondary');
            
            //  Referenz-Objekte entfernen 
            if (sunGhost) { scene.remove(sunGhost); sunGhost.geometry.dispose(); sunGhost.material.dispose(); sunGhost = null; }
            if (rulerGroup) { scene.remove(rulerGroup); rulerGroup = null; } 
            // Label verstecken
            if (distanceLabelEl) {
                 distanceLabelEl.style.display = 'none';
            }

            const planetButtons = document.getElementById('planet-focus-buttons');
            // KORREKTUR 2: Ziel-Container f√ºr Buttons korrigiert
            const cameraGroup = document.querySelectorAll('#ui-scrollable-content .control-group')[1]; 
            const moonContainer = document.getElementById('moon-focus-container');
            
            // KORREKTUR 2: insertBefore statt appendChild
            cameraGroup.insertBefore(planetButtons, moonContainer); 
            
            planetButtons.style.display = planetsVisibleCheckbox.checked ? 'grid' : 'none';
            planetButtons.style.marginTop = '10px'; 
            
            // KORREKTUR 4: Border/Padding wiederherstellen
            planetButtons.style.borderTop = '1px solid #444';
            planetButtons.style.paddingTop = '10px';


            document.getElementById('real-scale-sep1').style.display = 'none';
            document.getElementById('real-scale-sep2').style.display = 'none';

            setRealScaleUiVisibility(true);
            
            //  Planeten-Sichtbarkeit basierend auf Checkbox wiederherstellen 
            const planetsShouldBeVisible = planetsVisibleCheckbox.checked;
            otherPlanetControls.forEach(ctrl => { ctrl.orbit.visible = planetsShouldBeVisible; });
            
            
            earthOrbitLine.visible = orbitCheckbox.checked;
            moonOrbitLine.visible = orbitCheckbox.checked;
            //  Fl√§chen wiederherstellen (gem. Checkbox) 
            if (eclipticPlaneCheckbox) {
                const isChecked = eclipticPlaneCheckbox.checked;
                if (earthEclipticPlane) earthEclipticPlane.visible = isChecked;
                if (moonEclipticPlane) moonEclipticPlane.visible = isChecked;
            }

            //  3D-Modelle wiederherstellen (gem. Checkbox) 
            updateSpecialObjectsVisibility(true);
            
            otherPlanetOrbits.forEach(o => o.visible = planetsOrbitCheckbox.checked);

            otherMoons.forEach(moonObj => { moonObj.mesh.visible = true; });

            otherPlanetControls.forEach((ctrl, index) => {
                const data = planetsData[index];
                ctrl.tiltPivot.rotation.z = (data.axialTilt * Math.PI) / 180;
            });

            earthTiltPivot.visible = true;
            if (sun.userData.originalScale) sun.scale.copy(sun.userData.originalScale);
            currentSunScale = 1.0;
            currentEarthDistance = EARTH_DISTANCE;
            currentMoonDistance = MOON_DISTANCE;

            setTimeout(() => {
                if (!isRealScaleActive) {
                     camera.far = 20000; 
                     camera.updateProjectionMatrix();
                     controls.maxDistance = 7000;
                }
            }, 500);

            updatePositions(currentDay);
            setFocus(sun, 1.5);
            updateUI();
            if (!isPlaying) togglePlay();
        }

        function setRealScaleUiVisibility(visible) {
            const displayStyle = visible ? '' : 'none';
            const flexStyle = visible ? 'flex' : 'none';

            // e Zeile, um die Ekliptik-Checkbox zu finden und zu steuern
            const eclipticPlaneLabel = document.getElementById('ecliptic-plane-checkbox');
            if (eclipticPlaneLabel) {
                // Wir blenden das √ºbergeordnete <label>-Element aus (das 'display: flex' hat)
                eclipticPlaneLabel.parentElement.style.display = flexStyle;
            }
            
            //  3D-Modell-Checkbox auch ausblenden 
            if (humanObjectsCheckbox) {
                humanObjectsCheckbox.parentElement.style.display = flexStyle;
            }

            // --- NEU: ASTEROIDEN CHECKBOX STEUERN ---
            const astCheckbox = document.getElementById('asteroids-checkbox');
            if (astCheckbox) astCheckbox.parentElement.style.display = flexStyle;
            
            // KORREKTUR 3: Und den Button-Container auch
            const humanObjectsBtnContainer = document.getElementById('human-objects-focus-buttons');
            if (humanObjectsBtnContainer) {
                if (visible) {
                    // Wenn wir die UI wieder anzeigen (visible = true),
                    // stelle den Zustand basierend auf der Checkbox wieder her.
                    humanObjectsBtnContainer.style.display = humanObjectsCheckbox.checked ? 'flex' : 'none';
                } else {
                    // Wenn wir die UI verstecken (visible = false),
                    // blende die Buttons IMMER aus.
                    humanObjectsBtnContainer.style.display = 'none';
                }
            }

            // --- RAKETEN CONTROLS STEUERN ---
            const rocketCtrl = document.getElementById('rocket-controls');
            if (rocketCtrl) {
                if (!visible) {
                    // Wenn Real-Scale aktiv ist -> Rakete IMMER ausblenden
                    rocketCtrl.style.display = 'none';
                } else {
                    // Wenn Real-Scale beendet ist -> Rakete nur zeigen, wenn sie erlaubt ist
                    // (Wir pr√ºfen die globale Variable rocketSpawnAllowed oder ob rocketInstance existiert)
                    if (rocketSpawnAllowed || rocketInstance) {
                        rocketCtrl.style.display = 'block';
                    }
                }
            }

            document.getElementById('focus-ecliptic').style.display = displayStyle;
            
            document.getElementById('orbit-checkbox').parentElement.style.display = flexStyle;
            document.getElementById('planets-visible-checkbox').parentElement.parentElement.style.display = flexStyle; 
            document.getElementById('demo-buttons').style.display = flexStyle;
            document.getElementById('moon-phases-group').style.display = displayStyle;
            document.getElementById('play-group').style.display = flexStyle;
            
            // KORREKTUR 1: time-controls (Tag/Geschw.) wird versteckt, aber Helligkeit (draussen) nicht.
            document.getElementById('time-controls').style.display = displayStyle;
            
            //  Jahreszeiten-Gruppe auch verstecken 
            document.getElementById('seasons-group').style.display = displayStyle;
            
            
            // UPDATE: Kometen-Kontrollen sicher verbergen
            if (!visible) {
                 if (cometControls.style.display !== 'none') {
                      cometControls.dataset.wasVisible = 'true';
                 }
                 cometControls.style.display = 'none';
            } else {
                 if (cometControls.dataset.wasVisible === 'true') {
                      cometControls.style.display = 'block';
                 }
            }
        }

        //  Dynamisches HTML-Label (L√∂sung 2) 
        function updateDynamicLabel(km) {
            if (!distanceLabelEl) return;

            // 1. Text aktualisieren
            distanceLabelEl.textContent = Math.round(km / 1000000).toLocaleString('de-DE') + " Mio. km";

            // 2. 3D-Position der Erde holen
            // Wir nehmen earthTiltPivot, da es die Orbitalposition ist.
            let earthPos = new THREE.Vector3();
            // earth.getWorldPosition(earthPos); // Alternativ: exakte Position inkl. Tilt
            // Da das Label √ºber der Erde schweben soll, nehmen wir die Orbitalposition (Pivot)
            earthTiltPivot.getWorldPosition(earthPos);

            // Offset nach oben (in 3D-Einheiten), damit es √ºber der Erde schwebt
            earthPos.y += 15 * SCENE_SCALE;

            // 3. In 2D-Bildschirmkoordinaten umwandeln
            earthPos.project(camera);

            // Wenn der Punkt hinter der Kamera ist (z > 1), ausblenden
            if (earthPos.z > 1) {
                distanceLabelEl.style.display = 'none';
                return;
            }

            // Koordinaten von [-1, 1] auf [0, windowWidth/Height] umrechnen
            const x = (earthPos.x * .5 + .5) * window.innerWidth;
            const y = (earthPos.y * -.5 + .5) * window.innerHeight;

            // 4. Positionieren
            distanceLabelEl.style.display = 'block';
            // Nutze transform f√ºr bessere Performance als top/left
            distanceLabelEl.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
        }

        // UPDATE: Echtes Grid mit VIELEN Querstrichen (gleichm√§√üiger Abstand)
        function createGrid() {
             if (rulerGroup) scene.remove(rulerGroup);
             rulerGroup = new THREE.Group();
             
             const gridColor = 0xaaaaaa; 
             // Wir nutzen LineSegments f√ºr bessere Performance bei vielen Linien
             const material = new THREE.LineBasicMaterial({ color: gridColor, transparent: true, opacity: 0.8 });
             const points = [];

             const startX = COMPARE_EARTH_DIST_VALUE * 0.5;
             const endX = REAL_EARTH_DIST_VALUE * 1.05;
             const widthZ = 200 * SCENE_SCALE; 
             const yPos = -30 * SCENE_SCALE;
             const step = 50 * SCENE_SCALE; // Einheitlicher Abstand f√ºr Quadrate

             // L√§ngslinien (X-Richtung)
             for (let z = -widthZ; z <= widthZ; z += step) {
                 points.push(new THREE.Vector3(startX, yPos, z));
                 points.push(new THREE.Vector3(endX, yPos, z));
             }

             // Querlinien (Z-Richtung) - Jetzt mit gleichem 'step'
             for (let x = startX; x <= endX; x += step) {
                 points.push(new THREE.Vector3(x, yPos, -widthZ));
                 points.push(new THREE.Vector3(x, yPos, widthZ));
             }
             
             const geometry = new THREE.BufferGeometry().setFromPoints(points);
             const grid = new THREE.LineSegments(geometry, material);
             rulerGroup.add(grid);

             scene.add(rulerGroup);
        }

        function toggleRealDistance() {
            //  Simulation sofort pausieren! 
            pauseSimulation();
            //  Indikatoren zur√ºcksetzen 
            resetActiveIndicators();
            
            
            isRealDistanceActive = !isRealDistanceActive;
            updateSpecialObjectsVisibility(!isRealDistanceActive);
            const distBtn = document.getElementById('real-dist-btn');
            const planetButtons = document.getElementById('planet-focus-buttons'); 
            

            // UPDATE: Duration auf 10.0s erh√∂ht (halb so schnell)
            flightStartState.progress = 0;
            if (isRealDistanceActive) {
                 flightStartState.duration = 10.0;
            } else {
                 flightStartState.duration = 3.0;
            }
            flightStartState.startDist = currentEarthDistance;
            flightStartState.startMoonDist = currentMoonDistance; 

            if (isRealDistanceActive) {
                targetEarthDistance = REAL_EARTH_DIST_VALUE;
                targetMoonDistance = REAL_MOON_DIST_VALUE;
                infoBox.textContent = "DISTANZ: Flug in die reale Leere...";
                realityCheckPhase = 'flying_out';
                controls.enabled = false;
                
                distBtn.textContent = "‚òÄÔ∏è Zur√ºck zur Sonne";
                distBtn.classList.remove('btn-secondary');
                distBtn.classList.add('btn-warning');
                
                planetButtons.style.display = 'none';

                document.getElementById('moon-phases-group').style.display = 'block';

                createGrid(); 
                rulerFadeTimer = 0;

            } else {
                targetEarthDistance = COMPARE_EARTH_DIST_VALUE;
                targetMoonDistance = MOON_DISTANCE;
                infoBox.textContent = "DISTANZ: R√ºckflug zur Aufstellung...";
                realityCheckPhase = 'flying_in';
                controls.enabled = false;
                
                distBtn.textContent = "üöÄ Reale Distanz";
                distBtn.classList.remove('btn-warning');
                distBtn.classList.add('btn-secondary');
                document.getElementById('moon-phases-group').style.display = 'none';

                if (rulerGroup) {
                    scene.remove(rulerGroup);
                    rulerGroup = null;
                }
                // Label wird am Ende der Animation (in animate) entfernt
            }
        }

        function jumpToPhase(index) {
            pauseSimulation(); 
            resetToRealMode(); 
            
            //  Frequenz-Demo auch beenden 
            if (isFrequencyDemoActive) endFrequencyDemo();
            
            
            //  Indikatoren zur√ºcksetzen 
            resetActiveIndicators();
            
            if (!isRealScaleActive) {
                restoreOrbitLines();
            }
            // : Planeten ausblenden, da der Fokus auf dem Mondzyklus liegt
            toggleOtherPlanets(false);
            
            earthDemoRotationOffset = 0.0; 
            moonPivot.position.y = 0; 
            moon.position.y = 0;
            currentDay = PHASE_DAY_MAP[index];
            if (currentDayLabelEl) currentDayLabelEl.textContent = formatDayCount(currentDay);
            
            // moonPhaseButtons.forEach(btn => { btn.classList.remove('active'); }); // Wird jetzt von resetActiveIndicators() erledigt
            const clickedButton = moonPhaseButtons.find(btn => parseInt(btn.dataset.phaseIndex) === index);
            if (clickedButton) clickedButton.classList.add('active'); // en Indikator setzen
            
            updatePositions(currentDay);
            const daySlider = document.getElementById('day-slider');
            daySlider.value = currentDay;
            updateUI();
            let earthPos = new THREE.Vector3();
            let moonPos = new THREE.Vector3();
            earth.getWorldPosition(earthPos);
            moon.getWorldPosition(moonPos);
            flyTo(earthPos, moonPos, 0, 'earthView'); 
        }

        //  Hilfsfunktion zum Wiederherstellen der Erd/Mond-Bahnen 
            function restoreOrbitLines() {
                // Liest den globalen Zustand der Checkbox
                const isChecked = orbitCheckbox.checked;
                earthOrbitLine.visible = isChecked;
                moonOrbitLine.visible = isChecked;
            }

            // ZENTRALE STEUERUNG F√úR SPEZIAL-OBJEKTE (Asteroiden & Menschl. Objekte)
        function updateSpecialObjectsVisibility(modeAllowsVisibility) {
            
            // 1. ASTEROIDEN G√úRTEL
            const astCb = document.getElementById('asteroids-checkbox');
            if (asteroidInstancedMesh) {
                // Zeigen nur wenn: Modus erlaubt es (true) UND Checkbox ist an
                // (Falls Checkbox noch nicht existiert, standardm√§√üig true annehmen)
                const isChecked = astCb ? astCb.checked : true;
                asteroidInstancedMesh.visible = modeAllowsVisibility && isChecked;
            }

            // 2. MENSCHLICHE OBJEKTE (ISS, Hubble etc.)
            const humanCb = document.getElementById('human-objects-checkbox');
            const humanBtns = document.getElementById('human-objects-focus-buttons');
            
            // Auch hier: Nur zeigen, wenn Modus OK und Checkbox AN
            const humanChecked = humanCb ? humanCb.checked : false;
            const shouldShowHuman = modeAllowsVisibility && humanChecked;

            loaded3DModels.forEach(model => {
                model.pivot.visible = shouldShowHuman;
            });

            // Optional: Auch die Fokus-Buttons f√ºr ISS etc. ausblenden, wenn sie nicht zu sehen sind
            if (humanBtns) {
                humanBtns.style.display = shouldShowHuman ? 'flex' : 'none';
            }
            if (moonSurfaceObjects.length > 0) {
                moonSurfaceObjects.forEach(obj => {
                    // Das Objekt darf nur sichtbar sein, wenn:
                    // 1. Der allgemeine Modus es erlaubt (modeAllowsVisibility)
                    // 2. UND die Rakete tats√§chlich gelandet ist (hasMoonMissionLanded)
                    obj.visible = modeAllowsVisibility && hasMoonMissionLanded;
                });
            }
        }
        
        // *** √ÑNDERUNG 3: `toggleOtherPlanets` √ºberarbeitet ***
        function toggleOtherPlanets(visible) {
            
            // 1. UI-Elemente (Buttons) werden NICHT mehr von dieser Funktion gesteuert.
            //    Das √ºbernimmt der globale Checkbox-Listener in setupUI().
            //    Wir steuern hier nur noch die 3D-Objekte.

            // 2. Zustand der Haupt-Checkboxen pr√ºfen
            //    'visible' ist der Override (z.B. visible=false f√ºr Demos)
            const planetsShouldBeVisible = visible && planetsVisibleCheckbox.checked;
            const orbitsShouldBeVisible = visible && planetsOrbitCheckbox.checked && !isRealScaleActive;

            // 3. Planeten-Meshes und Pivots steuern (Planetenk√∂rper)
            otherPlanetControls.forEach(ctrl => { 
                ctrl.orbit.visible = planetsShouldBeVisible; 
            });

            // 4. Umlaufbahnen der Planeten steuern
            otherPlanetOrbits.forEach(orbit => { 
                orbit.visible = orbitsShouldBeVisible; 
            });
            
            // 5. Monde der anderen Planeten steuern
            otherMoons.forEach(moonObj => { 
                moonObj.mesh.visible = planetsShouldBeVisible; 
            });
            updateSpecialObjectsVisibility(visible);
        }
        //  Ende √Ñnderung 3 


        //  Funktion zum Springen zu Jahreszeiten (√ºberarbeitet) 
        //  Funktion zum Springen zu Jahreszeiten (√ºberarbeitet) 
        //  Funktion zum Springen zu Jahreszeiten (√ºberarbeitet) 
        function jumpToSeason(day, clickedBtn) {
            // 1. Demos & Realit√§tscheck beenden
            checkAndEndDemo(); 
            if (isRealScaleActive) {
                deactivateRealScale(); 
            }
            // 2. Simulation stoppen
            pauseSimulation();

            restoreOrbitLines(); //Erd und Mondlaufbahn wiederherstellen

            // 3. Alle Indikatoren zur√ºcksetzen
            resetActiveIndicators();

            // 4. Tag setzen
            currentDay = day;
            if (currentDayLabelEl) currentDayLabelEl.textContent = formatDayCount(currentDay);
            const daySlider = document.getElementById('day-slider');
            daySlider.value = currentDay;

            // 5. Positionen aktualisieren
            updatePositions(currentDay);
            updateUI();
            
            // üí° HIER DIE √ÑNDERUNG: Von 'true' auf 'false'
            toggleOtherPlanets(false); // < Planeten ausblenden

            // 6. e Indikatoren setzen
            if (clickedBtn) clickedBtn.classList.add('active');
            if (earthAxisLine) earthAxisLine.visible = true;

            // 7. Manuell zur Erde fliegen (restlicher Code bleibt gleich)
            let earthPos = new THREE.Vector3();
            earth.getWorldPosition(earthPos);
            const radius = EARTH_RADIUS;
            const fovInRad = THREE.MathUtils.degToRad(camera.fov);
            const distance = (radius / 0.3) / Math.tan(fovInRad / 2); 
            
            const offsetDir = new THREE.Vector3(0, 0, 0).sub(earthPos).normalize();
            offsetDir.y = 0.5; 
            offsetDir.normalize(); 
            const offset = offsetDir.multiplyScalar(distance);
            const endPos = earthPos.clone().add(offset);
            
            flyTo(endPos, earthPos, 1.5, earth); 
        }

        function toggleFlatEarthMode() {
            // Verhindern, dass man klickt, w√§hrend eine Animation l√§uft
            if (flatAnimPhase !== 'idle') return;

            if (!isFlatEarth) {
                // START: Wir machen sie platt!
                
                // 1. Simulation pausieren (damit sich die Erde nicht wegdreht beim Dr√ºcken)
                if (isPlaying) pauseSimulation();

                // 2. UI ausblenden f√ºr dramatischen Effekt
                // (Optional, kannst du weglassen, wenn du willst)
                
                // 3. Kamerafahrt zur Seite der Erde (√Ñquator-Blick), damit man die Kante sieht
                const earthPos = new THREE.Vector3();
                earth.getWorldPosition(earthPos);
                
                // Vektor zur Sonne (Lichtrichtung), damit die Erde sch√∂n beleuchtet ist
                const sunPos = new THREE.Vector3(0,0,0);
                const dirToSun = new THREE.Vector3().subVectors(sunPos, earthPos).normalize();
                
                // Kamera seitlich versetzen (90 Grad zur Sonne)
                const sideDir = new THREE.Vector3(-dirToSun.z, 0, dirToSun.x).normalize();
                
                // Position: Etwa 5 Erdradien entfernt
                const camPos = earthPos.clone().add(sideDir.multiplyScalar(EARTH_RADIUS * 5));
                
                // Callback-Funktion: Was passiert, wenn die Kamera angekommen ist?
                const onArrival = () => {
                    flatAnimPhase = 'anticipation'; // Start der Animations-Kette
                    flatAnimTimer = 0;
                };

                // Fokus auf "System" setzen, damit OrbitControls nicht an der Erde kleben
                // aber wir zielen manuell
                flyTo(camPos, earthPos, 1.5, null, onArrival); 
                
            } else {
                // START: Wir pumpen sie wieder auf
                flatAnimPhase = 'restoring';
                flatAnimTimer = 0;
                if (infoToastButton) {
                    infoToastButton.textContent = "Puh... Physik wiederhergestellt.";
                    infoToastButton.style.display = 'block';
                    setTimeout(() => infoToastButton.style.display = 'none', 3000);
                }
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // --- FLAT EARTH ANIMATION LOOP ---
            if (flatAnimPhase !== 'idle') {
                // Timer hochz√§hlen
                flatAnimTimer += deltaTime;

                if (flatAnimPhase === 'anticipation') {
                    // Phase 1: Luftholen / Strecken (0.5 Sekunden)
                    // Die Erde wird d√ºnner und h√∂her (wie beim Einatmen vor dem Schlag)
                    const progress = Math.min(1.0, flatAnimTimer / 0.5);
                    const stretch = 1.0 + (Math.sin(progress * Math.PI) * 0.2); // Geht bis 1.2
                    const thin = 1.0 - (Math.sin(progress * Math.PI) * 0.1);    // Geht bis 0.9
                    earth.scale.set(thin, stretch, thin);
                    
                    if (progress >= 1.0) {
                        flatAnimPhase = 'wobble';
                        flatAnimTimer = 0;
                    }

                } else if (flatAnimPhase === 'wobble') {
                    // Phase 2: Angst-Zittern / Widerstand (0.8 Sekunden)
                    const progress = Math.min(1.0, flatAnimTimer / 0.8);
                    // Schnelles Wackeln mit abnehmender St√§rke
                    const shake = Math.sin(flatAnimTimer * 30) * (0.1 * (1.0 - progress)); 
                    earth.scale.set(1.0 + shake, 1.0 - shake, 1.0 + shake);

                    if (progress >= 1.0) {
                        flatAnimPhase = 'splat';
                        flatAnimTimer = 0;
                    }

                } else if (flatAnimPhase === 'splat') {
                    // Phase 3: DER SPLAT! (Sehr schnell, 0.2 Sekunden)
                    const progress = Math.min(1.0, flatAnimTimer / 0.2);
                    
                    // Y-Achse: Von 1.0 runter auf 0.05 (fast flach)
                    // Wir nutzen "easeOutBounce" oder einfach eine harte Kurve f√ºr den Comic-Effekt
                    const currentY = 1.0 - (0.95 * progress); 
                    
                    // X/Z-Achse: Dehnt sich aus wie Teig (Volumenerhalt)
                    // Von 1.0 auf 1.5
                    const currentXZ = 1.0 + (0.5 * progress);

                    earth.scale.set(currentXZ, currentY, currentXZ);

                    if (progress >= 1.0) {
                        flatAnimPhase = 'idle'; // Fertig
                        isFlatEarth = true;
                        // Info anzeigen
                        if (infoToastButton) {
                            infoToastButton.textContent = "‚ö†Ô∏è ACHTUNG: Erde wurde plattgedr√ºckt!";
                            infoToastButton.style.display = 'block';
                            infoToastButton.classList.add('btn-danger');
                            setTimeout(() => { 
                                infoToastButton.style.display = 'none'; 
                                infoToastButton.classList.remove('btn-danger');
                            }, 4000);
                        }
                    }
                } else if (flatAnimPhase === 'restoring') {
                    // Zur√ºck zur Kugel (Sanft, 1.0 Sekunde)
                    const progress = Math.min(1.0, flatAnimTimer / 1.0);
                    
                    // Lerp von IST-Zustand (1.5, 0.05, 1.5) zur√ºck zu (1, 1, 1)
                    const currentY = 0.05 + (0.95 * progress);
                    const currentXZ = 1.5 - (0.5 * progress);
                    
                    // Kleines "Nachwabbeln" am Ende (Elastic Out)
                    const elastic = 1.0 + (Math.sin(progress * Math.PI * 4) * 0.05 * (1.0 - progress));
                    
                    earth.scale.set(currentXZ * elastic, currentY * elastic, currentXZ * elastic);

                    if (progress >= 1.0) {
                        earth.scale.set(1, 1, 1); // Sauberer Abschluss
                        flatAnimPhase = 'idle';
                        isFlatEarth = false;
                    }
                }
            }
            //---------------------------------
             
            
            if (isRealScaleActive) {
                if (realityCheckPhase === 'growing') {
                    const growthSpeed = 2.0; 
                    currentSunScale += growthSpeed * deltaTime;
                    
                    if (currentSunScale >= targetSunScale) {
                        currentSunScale = targetSunScale;
                        realityCheckPhase = 'active';
                        infoBox.textContent = "MA·∫ûSTAB: Reale Gr√∂sse erreicht.";

                        if (sunGhost) {
                            setTimeout(() => {
                                if (sunGhost) { 
                                    sunGhost.visible = false;
                                }
                            }, 2000); 
                        }
                    }
                    sun.scale.set(currentSunScale, currentSunScale, currentSunScale);
                    if (sunGhost) sunGhost.scale.set(currentSunScale, currentSunScale, currentSunScale);

                    // UPDATE: Keine Kamerabewegung mehr w√§hrend des Wachstums!
                }
                else if (realityCheckPhase === 'flying_out') {
                    // UPDATE: Erde bleibt bei Winkel 0
                    const earthOrbitAngle = 0;
                    flightStartState.progress += deltaTime / flightStartState.duration;
                    const easing = easeInOutCubic(Math.min(1.0, flightStartState.progress)); 
                    currentEarthDistance = THREE.MathUtils.lerp(flightStartState.startDist, targetEarthDistance, easing);
                    
                    // : Dynamisches Label updaten
                    const currentKm = (currentEarthDistance / REAL_EARTH_DIST_VALUE) * 149600000;
                    updateDynamicLabel(currentKm);

                    if (flightStartState.progress >= 1.0) {
                        currentEarthDistance = targetEarthDistance; 
                        realityCheckPhase = 'active_distant';
                        infoBox.textContent = "ANGEKOMMEN! Distanz: ca. 150 Mio. km";
                        controls.enabled = true;
                        cameraFocus = earth; 
                        let earthPos = new THREE.Vector3(Math.cos(earthOrbitAngle) * currentEarthDistance, 0, -Math.sin(earthOrbitAngle) * currentEarthDistance);
                        controls.target.copy(earthPos);
                    } else {
                         let earthPos = new THREE.Vector3(Math.cos(earthOrbitAngle) * currentEarthDistance, 0, -Math.sin(earthOrbitAngle) * currentEarthDistance);
                         const offsetDir = earthPos.clone().normalize();
                         offsetDir.y = 0.2; offsetDir.normalize();
                         const camPos = earthPos.clone().add(offsetDir.multiplyScalar(EARTH_RADIUS * 20)); 
                         camera.position.copy(camPos);
                         controls.target.copy(earthPos); 
                    }
                    currentMoonDistance = THREE.MathUtils.lerp(flightStartState.startMoonDist, targetMoonDistance, easing);
                }
                else if (realityCheckPhase === 'active_distant') {
                    if (rulerGroup) {
                        rulerFadeTimer += deltaTime;
                        if (rulerFadeTimer > 2.0) {
                             const fadeDuration = 1.0;
                             const opacity = Math.max(0, 0.8 * (1.0 - (rulerFadeTimer - 2.0) / fadeDuration));
                             rulerGroup.traverse(child => {
                                 if (child.material) {
                                     child.material.opacity = opacity;
                                 }
                             });
                             // Auch das Label ausblenden (durch CSS opacity)
                             if (distanceLabelEl) {
                                 distanceLabelEl.style.opacity = opacity;
                             }
                             
                             if (opacity <= 0) {
                                 scene.remove(rulerGroup);
                                 rulerGroup = null;
                                 if (distanceLabelEl) {
                                      distanceLabelEl.style.display = 'none';
                                      distanceLabelEl.style.opacity = 1.0; // Reset f√ºr n√§chsten Flug
                                 }
                             }
                        }
                    }
                }
                else if (realityCheckPhase === 'flying_in') {
                    // UPDATE: Erde bleibt bei Winkel 0
                    const earthOrbitAngle = 0;
                    flightStartState.progress += deltaTime / flightStartState.duration;
                    const easing = easeInOutCubic(Math.min(1.0, flightStartState.progress)); 
                    currentEarthDistance = THREE.MathUtils.lerp(flightStartState.startDist, targetEarthDistance, easing);

                    // : Dynamisches Label updaten (R√ºckflug)
                    const currentKm = (currentEarthDistance / REAL_EARTH_DIST_VALUE) * 149600000;
                    updateDynamicLabel(currentKm);

                    if (flightStartState.progress >= 1.0) {
                        currentEarthDistance = targetEarthDistance;
                        realityCheckPhase = 'active';
                        infoBox.textContent = "Wieder beim Gr√∂ssenvergleich.";
                        
                        document.getElementById('planet-focus-buttons').style.display = 'grid';

                        let earthPos = new THREE.Vector3(Math.cos(earthOrbitAngle) * currentEarthDistance, 0, -Math.sin(earthOrbitAngle) * currentEarthDistance);
                        
                        const finalSunRadius = REAL_SUN_SCALE_FACTOR * SUN_RADIUS;
                        const fovInRad = THREE.MathUtils.degToRad(camera.fov);
                        const visibleHeightNeeded = (finalSunRadius * 2) / 0.8;
                        const requiredDist = (visibleHeightNeeded / 2) / Math.tan(fovInRad / 2);
                        
                        let sunToEarthDir = earthPos.clone().normalize();
                        let camEndPos = sunToEarthDir.multiplyScalar(requiredDist); 
                        
                        flyTo(camEndPos, new THREE.Vector3(0,0,0), 1.5, null, () => { controls.enabled = true; });
                        
                        // Label verstecken am Ende
                        if (distanceLabelEl) {
                             distanceLabelEl.style.display = 'none';
                        }

                    } else {
                         let earthPos = new THREE.Vector3(Math.cos(earthOrbitAngle) * currentEarthDistance, 0, -Math.sin(earthOrbitAngle) * currentEarthDistance);
                         const offsetDir = earthPos.clone().normalize();
                         offsetDir.y = 0.2; offsetDir.normalize();
                         const camPos = earthPos.clone().add(offsetDir.multiplyScalar(EARTH_RADIUS * 20)); 
                         camera.position.copy(camPos);
                         controls.target.copy(earthPos);
                    }
                    currentMoonDistance = THREE.MathUtils.lerp(flightStartState.startMoonDist, targetMoonDistance, easing);
                }
            }

            if (comet) {
                if (comet.update(deltaTime)) {
                    comet = null;
                }
            } else {
                //  SPAWN LOGIK 
                if (comet) {
                    // Wenn er da ist, updaten
                    if (comet.update(deltaTime)) {
                        comet = null; // Wenn er zerst√∂rt wird (weggeflogen), ist er weg.
                        // Da wir keinen en Timer setzen, kommt er nie wieder.
                    }
                } else {
                    // Wenn er noch nicht da ist: Pr√ºfen ob heute der Tag ist!
                    // Wir pr√ºfen, ob wir den Spawn-Tag √ºberschritten haben
                    if (cometSpawnDay !== -1 && currentDay >= cometSpawnDay) {
                        spawnComet();
                        cometSpawnDay = -1; // Damit er nicht sofort nochmal spawnt
                    }
                }
                // 
            }
            
            updateUFO(deltaTime);

            // +++ RAKETEN UPDATE +++
            if (rocketInstance) {
                // Wir nutzen das rohe deltaTime (Echtzeit), damit die Rakete immer 
                // gleich schnell fliegt, egal wie schnell die Planeten rasen.
                const isFinished = rocketInstance.update(deltaTime);
                if (isFinished) {
                    rocketInstance = null;
                }
            }

            if (isCameraTransitioning) {
                cameraTransitionProgress += deltaTime / cameraTransitionDuration;
                const t = cameraTransitionProgress < 0.5 ? 4 * cameraTransitionProgress * cameraTransitionProgress * cameraTransitionProgress : 1 - Math.pow(-2 * cameraTransitionProgress + 2, 3) / 2;
                if (cameraTransitionProgress >= 1.0) {
                    isCameraTransitioning = false;
                    camera.position.copy(cameraTransitionEndPos);
                    controls.target.copy(cameraTransitionEndTarget);
                    cameraFocus = cameraFocusAfterTransition; 
                    lastCameraTargetPos.copy(controls.target);
                    if (cameraTransitionCallback) {
                        cameraTransitionCallback();
                        cameraTransitionCallback = null;
                    }
                } else {
                    camera.position.lerpVectors(cameraTransitionStartPos, cameraTransitionEndPos, t);
                    controls.target.lerpVectors(cameraTransitionStartTarget, cameraTransitionEndTarget, t);
                }
            }
            
            // *** √ÑNDERUNG 2: Logik f√ºr Zeit-Update (Spulen/Spielen) ***
            let actualSpeed = speed;
            if (isDemoActive) actualSpeed = demoLoopSpeed;
            else if (isFrequencyDemoActive) actualSpeed = speed;

            if (isRewinding) {
                let daysPerSecondFactor = EARTH_YEAR_DAYS / 60.0;
                const deltaDays = actualSpeed * daysPerSecondFactor * deltaTime;
                currentDay -= deltaDays;
                
                

                const daySlider = document.getElementById('day-slider');
                daySlider.value = ((currentDay % EARTH_YEAR_DAYS) + EARTH_YEAR_DAYS) % EARTH_YEAR_DAYS;
                if (currentDayLabelEl) currentDayLabelEl.textContent = formatDayCount(currentDay);
                updateUI();
                
            } else if (isPlaying && !isRealScaleActive && !isRealDistanceActive) {
                let daysPerSecondFactor;
                if (isDemoActive) {
                    daysPerSecondFactor = 1.0;
                } else {
                    daysPerSecondFactor = EARTH_YEAR_DAYS / 60.0;
                }
                
                const deltaDays = actualSpeed * daysPerSecondFactor * deltaTime;
                currentDay += deltaDays;
                
                if (isDemoActive) {
                    if (currentDay > demoLoopEndDay) currentDay = demoLoopStartDay; 
                    else if (currentDay < demoLoopStartDay) currentDay = demoLoopEndDay;
                }
                //  Frequenz-Demo l√§uft einfach weiter 
                //  Frequenz-Demo l√§uft einfach weiter 
                else if (isFrequencyDemoActive) {
                    // if (currentDay > EARTH_YEAR_DAYS) currentDay -= EARTH_YEAR_DAYS; // <-- AUSKOMMENTIEREN
                }
                
                const daySlider = document.getElementById('day-slider');
                daySlider.value = currentDay % EARTH_YEAR_DAYS;
                if (currentDayLabelEl) currentDayLabelEl.textContent = formatDayCount(currentDay);
                updateUI();
            }
            //  Ende √Ñnderung 2 

            
            updatePositions(currentDay);
            updateCamera(false); 
            controls.update();
            renderer.render(scene, camera);
        }

        function calculateEllipticalPosition(a, e, perihelionAngle, days, yearDays) {
            const M = (days / yearDays) * Math.PI * 2;
            let nu = M + 2 * e * Math.sin(M) + 1.25 * e * e * Math.sin(2 * M);
            const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
            const x_orb = r * Math.cos(nu);
            const z_orb = r * Math.sin(nu);
            const x_final = x_orb * Math.cos(perihelionAngle) - z_orb * Math.sin(perihelionAngle);
            const z_final = x_orb * Math.sin(perihelionAngle) + z_orb * Math.cos(perihelionAngle);
            return { x: x_final, z: -z_final }; 
        }

        function updatePositions(day) {
            // UPDATE: Im Real-Modus Erde immer auf Winkel 0 fixieren
            let earthOrbitAngle;
            if (isRealScaleActive) {
                earthOrbitAngle = 0;
            } else {
                earthOrbitAngle = (day / EARTH_YEAR_DAYS) * Math.PI * 2;
            }
            earthTiltPivot.position.set(Math.cos(earthOrbitAngle) * currentEarthDistance, 0, -Math.sin(earthOrbitAngle) * currentEarthDistance);

            let rotationFactor = 1.0;
            if (isDemoActive && demoType === 'sofi') rotationFactor = 0.1; 
            earth.rotation.y = (day * rotationFactor) * Math.PI * 2; 
            earth.rotation.y += earthDemoRotationOffset; 

            let moonOrbitAngle;
            if (isDemoActive) moonOrbitAngle = (day / LUNAR_MONTH_DAYS) * Math.PI * 2;
            else moonOrbitAngle = ((day - PHASE_OFFSET_DAYS) / LUNAR_MONTH_DAYS) * Math.PI * 2;
            
            let earthWorldPos = new THREE.Vector3();
            earth.getWorldPosition(earthWorldPos);
            
            moonPivot.position.copy(earthWorldPos);
            moonPivot.rotation.y = earthOrbitAngle + moonOrbitAngle; 
            moonOrbitLine.position.copy(earthWorldPos);
            //  Position der Mond-Ekliptik-Fl√§che aktualisieren 
            if (moonEclipticPlane) moonEclipticPlane.position.copy(earthWorldPos);
            
            moon.rotation.y = 0;
            moon.position.x = -currentMoonDistance; 

            otherPlanetControls.forEach((ctrl, index) => {
                const data = planetsData[index];
                const planet = otherPlanets[index];
                
                // Wenn nicht im Real-Scale-Modus ODER wenn wir uns im Idle-Zustand befinden (d.h. vor dem Klick auf "Reale Gr√∂sse"),
                // dann normale Bahnbewegung.
                // WICHTIG: W√§hrend 'flying_out'/'flying_in' wollen wir, dass sie stehen bleiben!
                if (!isRealScaleActive || realityCheckPhase === 'idle') {
                    const pos = calculateEllipticalPosition(data.distance, data.ecc, data.perihelionAngle, day, data.yearDays);
                    ctrl.container.position.set(pos.x, 0, pos.z);
                }
                // Sonst (w√§hrend Real Scale aktiv ist), bleiben sie einfach da stehen, wo activateRealScaleSequence sie hingestellt hat.
                
                planet.rotation.y = (day * data.rotationSpeed) * Math.PI * 2;
                let tempVec = new THREE.Vector3();
                planet.getWorldPosition(tempVec);
                planet.material.uniforms.uObjectWorldPosition.value.copy(tempVec);
                
                // UPDATE: Generisches Ring-Update
                if (data.ring) {
                     const ringEntry = planetRingMaterials.find(e => e.parentPlanet === planet);
                     if (ringEntry && ringEntry.ringMat) {
                         ringEntry.ringMat.uniforms.uRingParentPosition.value.copy(tempVec);
                     }
                     
                     // F√ºr den Planet-Shader (Schatten auf Planet)
                     const planetEntry = planetRingMaterials.find(e => e.pivot === ctrl.tiltPivot && e.mat);
                     if (planetEntry && planetEntry.mat) {
                        const ringNormalWorld = new THREE.Vector3(0, 1, 0).applyQuaternion(ctrl.tiltPivot.getWorldQuaternion(new THREE.Quaternion()));
                        planetEntry.mat.uniforms.uRingNormal.value.copy(ringNormalWorld);
                     }
                }
            });

            let tempParentPos = new THREE.Vector3();
            otherMoons.forEach(moonObj => {
                const startAngle = moonObj.data.startAngle || 0; 
                moonObj.pivot.rotation.y = (day * moonObj.speed) * Math.PI * 2 + startAngle; 

                let tempVec = new THREE.Vector3();
                moonObj.mesh.getWorldPosition(tempVec);
                moonObj.mesh.material.uniforms.uObjectWorldPosition.value.copy(tempVec);
                moonObj.parentPlanet.getWorldPosition(tempParentPos);
                moonObj.mesh.material.uniforms.uParentPosition.value.copy(tempParentPos);
            });

            /*  Jupiter-Mondschatten-Uniforms aktualisieren  */
            if (jupiterMoonShadowUniforms && jupiterMoons.length > 0) {
                let tempMoonPos = new THREE.Vector3();
                for (let i = 0; i < 4; i++) {
                    if (jupiterMoons[i]) {
                        // 1. Weltposition des Mondes holen
                        jupiterMoons[i].getWorldPosition(tempMoonPos);
                        // 2. Position in den Shader-Uniforms aktualisieren
                        jupiterMoonShadowUniforms.uMoonPositions.value[i].copy(tempMoonPos);
                        // 3. Radius des Mondes aktualisieren
                        jupiterMoonShadowUniforms.uMoonRadii.value[i] = jupiterMoons[i].geometry.parameters.radius;
                    } else {
                        // Falls es (noch) keinen Mond an diesem Index gibt, Radius auf 0
                        jupiterMoonShadowUniforms.uMoonRadii.value[i] = 0.0;
                    }
                }
            }

            // 3D-Modelle (z.B. ISS) aktualisieren 
            if (loaded3DModels.length > 0) {
                let tempEarthPos = new THREE.Vector3(); // Wiederverwendbarer Vektor
                
                loaded3DModels.forEach(model => {
                    // Pr√ºfe, welche Update-Logik dieses Modell ben√∂tigt
                    if (model.data.updateType === 'earth_orbit') {
                        
                        // 1. Finde das Zielobjekt (Erde)
                        earth.getWorldPosition(tempEarthPos);
                        
                        // 2. Binde den Pivot an die Erdposition
                        model.pivot.position.copy(tempEarthPos);
                        
                        // 3. Berechne die Rotation basierend auf dem Tag
                        const orbitsPerDay = model.data.orbitsPerDay;
                        model.pivot.rotation.y = (day * orbitsPerDay) * Math.PI * 2;
                        
                        // 4. Setze die Neigung (Inklination) relativ zur Erdachse
                        const inclinationRad = (model.data.inclination * Math.PI) / 180;
                        model.pivot.rotation.y = (day * orbitsPerDay) * Math.PI * 2;

                        
                        model.pivot.rotation.order = 'ZXY'; // WICHTIG!

                        // 1. Die Neigung der Erdachse (kippt die "Basis" der ISS-Bahn)
                        model.pivot.rotation.z = EARTH_TILT_RAD; 
                        
                        // 2. Die Inklination der ISS *relativ* zur Erd-√Ñquator-Ebene
                        model.pivot.rotation.x = inclinationRad; 

                        
                        const precessionSpeedPerDay = (Math.PI * 2) / 365.25; // 1 volle Drehung pro Jahr
                        model.pivot.rotation.z += (day * precessionSpeedPerDay);
                        
                    }

                    else if (model.data.updateType === 'static_rotation') {
                        // Position bleibt fest (wurde im Loader gesetzt)
                        // Nur leichte Rotation um die eigene Achse f√ºr Dynamik
                        model.scene.rotation.z += 0.0005; 
                        model.scene.rotation.y += 0.0002;
                    }
                    // HIER K√ñNNTEST DU SP√ÑTER ANDERE updateTypes hinzuf√ºgen (z.B. 'sun_orbit')
                });
            }

            let tempVec = new THREE.Vector3();
            earth.getWorldPosition(tempVec);
            earth.material.uniforms.uObjectWorldPosition.value.copy(tempVec);
            
            let moonWorldPosition = new THREE.Vector3();
            moon.getWorldPosition(moonWorldPosition);
            earth.material.uniforms.uMoonPosition.value.copy(moonWorldPosition);
            
            //  Mondradius-Uniform basierend auf Skalierung aktualisieren 
            earth.material.uniforms.uMoonRadius.value = MOON_RADIUS * moon.scale.x;


            if (isDemoActive && demoType === 'mofi') {
                const animProgress = (currentDay - demoLoopStartDay) / (demoLoopEndDay - demoLoopStartDay);
                const dayToProgress = (d) => (d - demoLoopStartDay) / (demoLoopEndDay - demoLoopStartDay);
                
                const peakDay = 14.765; 
                const peakProgress = dayToProgress(peakDay); 
                
                //  ANGEPASSTE WERTE 
                
                // Rot-werden beginnt: Vorverlegung auf z.B. 0.5 Tage vor dem H√∂hepunkt (vorher 0.45)
                const redFadeInStart = dayToProgress(peakDay - 0.48); 
                // : Ende des Einblendens (Rot erreicht maximale Helligkeit, z.B. 0.2 Tage nach H√∂hepunkt)
                const redFullIntensityStart = dayToProgress(peakDay - 0.43);
                
                // Rot-werden verblasst: Startet z.B. 0.2 Tage nach dem H√∂hepunkt (wie gehabt)
                const redFadeOutStart = dayToProgress(peakDay + 0.3); 
                const redFadeOutEnd = dayToProgress(peakDay + 0.5); 
                
                // Schatten beginnt: Vorverlegung auf z.B. 0.7 Tage vor dem H√∂hepunkt (vorher 0.6)
                const shadowFadeInStart = dayToProgress(peakDay - 0.48); 
                const shadowFadeInEnd = dayToProgress(peakDay - 0.43);         
                
                // Schatten verblasst: Startet z.B. 0.2 Tage nach dem H√∂hepunkt (wie gehabt)
                const shadowFadeOutStart = dayToProgress(peakDay + 0.2); 
                const shadowFadeOutEnd = dayToProgress(peakDay + 0.5);
                
                //  ENDE ANPASSUNG 
                
                const shadowTargetBrightness = 0.6; 
                
                // ... (Der Rest des Animationscodes folgt, unver√§ndert) ...
                let redIntensity = 0.0; 
                let shadowBrightness = 0.0;

                if (animProgress <= redFullIntensityStart) {
                    // Phase 1: Rot blenden EIN (von redFadeInStart bis redFullIntensityStart)
                    const fadeDuration = redFullIntensityStart - redFadeInStart;
                    const fadeProgress = Math.min(1.0, Math.max(0.0, (animProgress - redFadeInStart) / fadeDuration));
                    redIntensity = fadeProgress; 
                } else if (animProgress <= redFadeOutStart) {
                    // Phase 2: Volle Intensit√§t halten
                    redIntensity = 1.0;
                } else if (animProgress <= redFadeOutEnd) {
                    // Phase 3: Rot blenden AUS (von redFadeOutStart bis redFadeOutEnd)
                    const fadeDuration = redFadeOutEnd - redFadeOutStart;
                    const fadeProgress = Math.min(1.0, Math.max(0.0, (animProgress - redFadeOutStart) / fadeDuration));
                    redIntensity = 1.0 - fadeProgress; 
                }
                if (animProgress > shadowFadeInStart && animProgress <= shadowFadeInEnd) {
                    const fadeProgress = (animProgress - shadowFadeInStart) / (shadowFadeInEnd - shadowFadeInStart);
                    shadowBrightness = fadeProgress * shadowTargetBrightness;
                } else if (animProgress > shadowFadeInEnd && animProgress <= shadowFadeOutStart) {
                     shadowBrightness = shadowTargetBrightness;
                } else if (animProgress > shadowFadeOutStart && animProgress <= shadowFadeOutEnd) {
                    const fadeProgress = (animProgress - shadowFadeOutStart) / (shadowFadeOutEnd - shadowFadeOutStart);
                    shadowBrightness = shadowTargetBrightness - ((fadeProgress * fadeProgress) * shadowTargetBrightness);
                }
                originalMoonMaterial.uniforms.uShadowBrightness.value = shadowBrightness;
                originalMoonMaterial.uniforms.uRedOverlayIntensity.value = redIntensity;
            }
            moon.getWorldPosition(tempVec);
            if (moon.material.uniforms) {
                originalMoonMaterial.uniforms.uObjectWorldPosition.value.copy(tempVec);
                earth.getWorldPosition(tempVec); 
                originalMoonMaterial.uniforms.uEarthPosition.value.copy(tempVec);
                //  Mondradius-Uniform basierend auf Skalierung aktualisieren 
                originalMoonMaterial.uniforms.uMoonRadius.value = MOON_RADIUS * moon.scale.x;
            }

            // --- ASTEROIDEN UPDATE ---
            if (asteroidInstancedMesh) {
                const asteroids = asteroidInstancedMesh.userData.asteroids;
                const dummy = new THREE.Object3D();
                
                // Wir durchlaufen jeden Asteroiden und berechnen seine e Position
                for (let i = 0; i < asteroids.length; i++) {
                    const data = asteroids[i];
                    
                    // Winkel basierend auf dem Tag berechnen
                    // Wir teilen durch einen Faktor, damit sie nicht zu schnell rasen
                    const currentAngle = data.startAngle + (day * data.speed * -0.1); 

                    const x = Math.cos(currentAngle) * data.distance;
                    const z = Math.sin(currentAngle) * data.distance;
                    
                    dummy.position.set(x, data.y, z);
                    
                    // Wir holen uns die alte Matrix, um Rotation/Skalierung zu behalten
                    // (Optimierung: Man k√∂nnte Rotation auch animieren, kostet aber Performance)
                    const currentMatrix = new THREE.Matrix4();
                    asteroidInstancedMesh.getMatrixAt(i, currentMatrix);
                    
                    // Extrahiere Rotation/Scale aus der alten Matrix
                    const position = new THREE.Vector3();
                    const quaternion = new THREE.Quaternion();
                    const scale = new THREE.Vector3();
                    currentMatrix.decompose(position, quaternion, scale);
                    
                    dummy.quaternion.copy(quaternion);
                    dummy.scale.copy(scale);
                    
                    dummy.updateMatrix();
                    asteroidInstancedMesh.setMatrixAt(i, dummy.matrix);
                }
                // Der Grafikkarte sagen, dass sich Positionen ge√§ndert haben
                asteroidInstancedMesh.instanceMatrix.needsUpdate = true;
            }

            // Position des Mondes f√ºr die Shader aktualisieren
            if (moon && surfaceObjectsMaterials.length > 0) {
                const moonWorldPos = new THREE.Vector3();
                moon.getWorldPosition(moonWorldPos);
                
                const sunWorldPos = new THREE.Vector3();
                if(sun) sun.getWorldPosition(sunWorldPos);

                // Slider Wert holen
                const sliderEl = document.getElementById('darkness-slider');
                const currentBrightness = sliderEl ? parseFloat(sliderEl.value) : 0.04;

                surfaceObjectsMaterials.forEach(mat => {
                    // Wir greifen auf den gespeicherten Shader im userData zu
                    if (mat.userData.shader) {
                        const uniforms = mat.userData.shader.uniforms;
                        
                        if (uniforms.uMoonCenter) uniforms.uMoonCenter.value.copy(moonWorldPos);
                        if (uniforms.uSunPosition) uniforms.uSunPosition.value.copy(sunWorldPos);
                        if (uniforms.uNightBrightness) uniforms.uNightBrightness.value = currentBrightness;
                    }
                });
            }

            // --- NEU: LICHTER STEUERN ---
    
            // 1. Slider Wert holen
            const sliderEl = document.getElementById('darkness-slider');
            const sliderValue = sliderEl ? parseFloat(sliderEl.value) : 0.04;

            // Hilfsvektoren f√ºr die Mathematik (Performance)
            const _lightWorldPos = new THREE.Vector3();
            const _moonCenterPos = new THREE.Vector3();
            const _sunPos = new THREE.Vector3();

            // Positionen holen
            if (moon) moon.getWorldPosition(_moonCenterPos);
            if (sun) sun.getWorldPosition(_sunPos);

            // 2. Alle Lichter durchgehen und individuell berechnen
            nightTimeLights.forEach(light => {
                
                // A) Wo ist dieses spezielle Licht gerade im Weltraum?
                light.getWorldPosition(_lightWorldPos);

                // B) Tag/Nacht-Berechnung f√ºr DIESES Licht
                // Vektor vom Mondkern zum Licht ("Oben")
                const surfaceUp = new THREE.Vector3().subVectors(_lightWorldPos, _moonCenterPos).normalize();
                // Vektor zur Sonne
                const sunDir = new THREE.Vector3().subVectors(_sunPos, _lightWorldPos).normalize();
                
                // Wie stark scheint die Sonne hier? (1.0 = Mittag, 0.0 = D√§mmerung, -1.0 = Nacht)
                const sunIntensity = surfaceUp.dot(sunDir);
                
                // Wir machen daraus einen Faktor: 1.0 bei Nacht, 0.0 bei Tag
                // smoothstep sorgt f√ºr weichen √úbergang am Terminator
                // Werte < 0.0 (Nacht) werden zu 1.0 (Licht an)
                // Werte > 0.2 (Tag) werden zu 0.0 (Licht aus)
                const nightFactor = 1.0 - THREE.MathUtils.smoothstep(sunIntensity, -0.1, 0.2);

                // C) Slider-Logik (wie vorher)
                let sliderFactor = sliderValue * 2.5; 
                if (sliderFactor > 1.0) sliderFactor = 1.0;

                // D) Die finale Helligkeit berechnen
                
                // Grundst√§rke (vom Slider gesteuert, aber NUR wenn Nacht ist)
                let currentIntensity = light.userData.baseIntensity * sliderFactor * nightFactor;

                // E) Der Astronauten-Fix (Mindesthelligkeit)
                // Wenn "minBrightness" gesetzt ist (z.B. 0.23), darf das Licht nie dunkler als das sein.
                // WICHTIG: Das gilt auch am Tag!
                // Wir skalieren 0.23 relativ zur Basis-Intensit√§t
                const minIntensity = light.userData.baseIntensity * light.userData.minBrightness;
                
                if (currentIntensity < minIntensity) {
                    currentIntensity = minIntensity;
                }

                // Licht anwenden
                light.intensity = currentIntensity;
            });
        }
        
        

        function updateCamera(isJump = false) {
            if (isCameraTransitioning || isJump) return;
            
            if (isRealScaleActive) {
                if (realityCheckPhase === 'active' || realityCheckPhase === 'active_distant') {
                    lastCameraTargetPos.copy(controls.target);
                }
                return; 
            }

            let targetObject;

            if (typeof cameraFocus === 'string') {
                if (cameraFocus === 'eclipse_frequency_view') {
                    let camPos = new THREE.Vector3();
                    let targetPos = new THREE.Vector3();
                    earthTiltPivot.getWorldPosition(camPos);
                    sun.getWorldPosition(targetPos);
                    camera.position.copy(camPos);
                    controls.target.copy(targetPos);
                    lastCameraTargetPos.copy(targetPos);
                    return;
                }
                if (cameraFocus === 'earthView') {
                    if (isUserControllingCamera) {
                        cameraFocus = moon; 
                        moon.getWorldPosition(lastCameraTargetPos);
                        return; 
                    } else {
                        let earthPos = new THREE.Vector3();
                        let moonPos = new THREE.Vector3();
                        earth.getWorldPosition(earthPos);
                        moon.getWorldPosition(moonPos);
                        camera.position.copy(earthPos); 
                        controls.target.copy(moonPos);
                        lastCameraTargetPos.copy(moonPos);
                        return; 
                    }
                }
                // UFO Verfolgung
                if (cameraFocus === 'ufo_to_earth') {
                    let ufoPos = new THREE.Vector3();
                    let earthPos = new THREE.Vector3();
                    ufo.getWorldPosition(ufoPos);
                    earth.getWorldPosition(earthPos);
                    controls.target.copy(earthPos); 
                    const behindDir = new THREE.Vector3().subVectors(ufoPos, earthPos).normalize();
                    //Distanz
                    const camPos = ufoPos.clone().add(behindDir.multiplyScalar(1.2 * SCENE_SCALE));
                    //H√∂he
                    camPos.y += 3 * SCENE_SCALE; 
                    camera.position.lerp(camPos, 0.05); 
                    return;
                }
                if (cameraFocus === 'ufo_leaving_watch') {
                    ufo.getWorldPosition(controls.target);
                    return;
                }
                if (cameraFocus === 'ecliptic_side_view') {
                    let earthPos = new THREE.Vector3();
                    earth.getWorldPosition(earthPos);
                    let offset = earthPos.clone().normalize().multiplyScalar(40);
                    let sideOffset = new THREE.Vector3(-earthPos.z, 0, earthPos.x).normalize().multiplyScalar(4); 
                    const endPos = earthPos.clone().add(offset).add(sideOffset);
                    endPos.y = 0; 
                    camera.position.copy(endPos);
                    controls.target.set(0, 0, 0);
                    lastCameraTargetPos.copy(controls.target);
                    return;
                }
                if (cameraFocus === 'transitioning') return;
                setFocus(sun, 0); 
                return;
            }
            
            targetObject = cameraFocus; 
            if (!targetObject) { targetObject = sun; cameraFocus = sun; }
            
            let currentTargetPos = new THREE.Vector3();
            targetObject.getWorldPosition(currentTargetPos);

            // --- RAKETEN KAMERA LOGIK (UPDATE: FOKUS AUF KAPSEL) ---
            if (targetObject.userData && targetObject.userData.isRocket) {
                const rInst = rocketInstance;
                if (rInst) {
                    // 1. Wir holen uns die Position der KAPSEL, nicht der ganzen Rakete
                    // Da die Kapsel immer existiert, springt die Kamera nie.
                    const capsulePos = new THREE.Vector3();
                    rInst.meshCapsule.getWorldPosition(capsulePos);
                    
                    // 2. Kamera-Differenz berechnen basierend auf letzter Zielposition
                    const delta = capsulePos.clone().sub(lastCameraTargetPos);

                    // 3. Kamera mitbewegen
                    camera.position.add(delta);
                    
                    // 4. Zielpunkt auf die Kapsel setzen
                    controls.target.copy(capsulePos);
                    
                    // 5. Letzte Position speichern
                    lastCameraTargetPos.copy(capsulePos);
                    
                    return; 
                }
            }
            // ----------------------------------------------------
            
            if (isPlaying || isDemoActive || isFrequencyDemoActive || isRewinding) { 
                const delta = currentTargetPos.clone().sub(lastCameraTargetPos);
                camera.position.add(delta);
                controls.target.add(delta);
            }
            lastCameraTargetPos.copy(currentTargetPos);
        }
        
        function updateUI() {
            let sunPos = new THREE.Vector3();
            let earthPos = new THREE.Vector3();
            let moonPos = new THREE.Vector3();
            sun.getWorldPosition(sunPos);
            earth.getWorldPosition(earthPos);
            moon.getWorldPosition(moonPos);
            const vecEarthToMoon = new THREE.Vector3().subVectors(moonPos, earthPos);
            const vecEarthToSun = new THREE.Vector3().subVectors(sunPos, earthPos); 
            let angle = Math.atan2(vecEarthToSun.z, vecEarthToSun.x) - Math.atan2(vecEarthToMoon.z, vecEarthToMoon.x);
            angle = (angle + Math.PI * 2) % (Math.PI * 2);
            let phaseIndex = Math.floor(normalizedAngle = angle / (Math.PI * 2) * 8 + 0.5) % 8;
            const phaseNames = ["mond", "Zunehmende Sichel", "Zunehmender Halbmond", "Zunehmendes Drittel", "Vollmond", "Abnehmendes Drittel", "Abnehmender Halbmond", "Abnehmende Sichel"];
            let phaseName = phaseNames[phaseIndex];
            
            let infoText = `Mondphase: ${phaseName}`;
            
            //  Info-Text f√ºr Frequenz-Demo 
            if (isFrequencyDemoActive) {
                infoText = "Ansicht: Finsternis-H√§ufigkeit";
                // Zeige Neigung der Mondbahn
                let moonWorldY = moon.getWorldPosition(new THREE.Vector3()).y;
                let earthWorldY = earth.getWorldPosition(new THREE.Vector3()).y; 
                let yDiff = moonWorldY - earthWorldY;
                infoText += ` | Mond-Neigung: ${yDiff.toFixed(1)}`;
            
            } else if (isDemoActive) {
                if (demoType === 'sofi') infoText = "SONNENFINSTERNIS (Demo)";
                else if (demoType === 'mofi') infoText = "MONDFINSTERNIS (Demo)";
            } else {
                let moonWorldY = moon.getWorldPosition(new THREE.Vector3()).y;
                let earthWorldY = earth.getWorldPosition(new THREE.Vector3()).y; 
                let yDiff = Math.abs(moonWorldY - earthWorldY);
                const ECLIPSE_TOLERANCE = (MOON_RADIUS + EARTH_RADIUS) / 3; 
                if (phaseIndex === 0 && yDiff < ECLIPSE_TOLERANCE) infoText += " (M√∂gliche SoFi)";
                if (phaseIndex === 4 && yDiff < ECLIPSE_TOLERANCE) infoText += " (M√∂gliche MoFi)";
            }
            
            
            if (comet && comet.mesh) {
                 const speedKmh = Math.round(comet.velocity.length() * 25000);
                 if (comet.hitbox && comet.hitbox.userData.info) {
                    comet.hitbox.userData.info.velocity = `ca. ${speedKmh.toLocaleString('de-DE')} km/h`;
                 }
                 
                 infoText += ` | Komet: ${speedKmh.toLocaleString('de-DE')} km/h`;
            }
            
            if (realityCheckPhase === 'flying_out' || realityCheckPhase === 'flying_in') {
                 const kmPerUnit = 149600000 / REAL_EARTH_DIST_VALUE;
                 const currentKm = Math.round(currentEarthDistance * kmPerUnit);
                 infoText = `Distanz zur Sonne: ${currentKm.toLocaleString('de-DE')} km`;
            }

            infoBox.textContent = infoText;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
       
         
        function onTouchEnd(event) {
            const targetElement = event.target;
            
            // Wenn die Kamerasteuerung aktiv war, war dies ein "Drag" und kein "Tap".
            if (isUserControllingCamera) { 
                return; 
            }

            // iPad Ghost-Click-Fix
            lastTouchTime = new Date().getTime();

            const touch = event.changedTouches[0];
            if (!touch) return; 
            const popupOpened = handleInteraction(touch.clientX, touch.clientY, targetElement);
            if (popupOpened) event.preventDefault(); // Verhindert Scrollen, aber nicht immer den Klick
        }

        function onMouseClick(event) {
            // "Ghost Click" nach Touch-Event auf iPad verhindern
            if (new Date().getTime() - lastTouchTime < 500) {
                return; 
            }

            handleInteraction(event.clientX, event.clientY, event.target);
        }
        function handleInteraction(x, y, targetElement) {
            const uiContainer = document.getElementById('ui-container');
            const popup = document.getElementById('info-popup');
            const ufoDialog = document.getElementById('ufo-dialog');
            
            // *** √ÑNDERUNG 2: Rewind-Button von Klicks ausschliessen ***
            if (uiContainer.contains(targetElement) || popup.contains(targetElement) || ufoDialog.contains(targetElement) || infoToastButton.contains(targetElement) || targetElement.id === 'rewind-btn') {
                return false; 
            }
            //  Ende √Ñnderung 2 
            
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects, true); 

            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                while (clickedObject.parent && !clickableObjects.includes(clickedObject)) {
                    clickedObject = clickedObject.parent;
                }

                if (clickedObject.userData.isUFO && ufoState === 'hovering') { 
                    ufoState = 'interacted';
                    //  Text basierend auf Z√§hler setzen 
                    setupUfoDialogText();

                    document.getElementById('ufo-dialog').style.display = 'block';
                    if (isPlaying) pauseSimulation();
                    return true;
                }

                if (clickedObject.userData.info) {
                    currentSelectedInfo = clickedObject.userData.info;
                    infoToastButton.textContent = `üí° Info: ${currentSelectedInfo.name}`;
                    infoToastButton.style.display = 'block';
                    return true; 
                }
            } else {
                infoToastButton.style.display = 'none';
                currentSelectedInfo = null;
            }
            return false; 
        }
        function showInfoPopup(info) {
            const popup = document.getElementById('info-popup');
            const titleEl = document.getElementById('popup-title');
            const detailsEl = document.getElementById('popup-details');
            titleEl.textContent = info.name;
            
            if (info.type === 'comet') {
                // ... (Kometen-Code bleibt unver√§ndert) ...
                let detailsHTML = '';
                if (info.radius_km) detailsHTML += `<p><strong>Gr√∂√üe:</strong> <span>${info.radius_km}</span></p>`;
                if (info.velocity) detailsHTML += `<p><strong>Geschwindigkeit:</strong> <span id="popup-velocity">${info.velocity}</span></p>`;
                if (info.funFacts && info.funFacts.length > 0) {
                    info.funFacts.forEach((fact, index) => {
                        const style = (index === 0) ? 'margin-top: 15px; padding-top: 10px; border-top: 1px dashed #444;' : '';
                        detailsHTML += `<p class="fun-fact" style="${style}">${fact}</p>`;
                    });
                }
                detailsEl.innerHTML = detailsHTML;
                popup.style.display = 'flex';
                return;
            }

            const factMap = {
                planetType_de: 'Planetentyp',
                earthCompareRadius: 'Gr√∂√üe',
                radius_km: 'Radius', 
                distance_Mio_km: 'Abstand zur Sonne', 
                umlaufzeit: 'Umlaufzeit (Sonne)', 
                taglaenge: 'Tagesl√§nge',
                temperatur: 'Durchschnittstemp.', 
                oberflaeche_temp: 'Oberfl√§chentemp.',
                zusammensetzung: 'Zusammensetzung',
                velocity: 'Geschwindigkeit' //  f√ºr Rakete
            };

            if (info.name === 'Sonne') {
                 factMap['earthCompareRadius'] = 'Gr√∂√üe (Vergleich)';
            } else if (info.name.includes('Mond')) { 
                 factMap['distance_Mio_km'] = `Abstand zu/r ${info.parentName}`; 
                 factMap['umlaufzeit'] = `Umlaufzeit (${info.parentName})`; 
            }
            else if (info.name.includes('ISS')|| info.name.includes('Hubble')) {
                factMap['radius_km'] = 'Flugh√∂he';
                factMap['umlaufzeit'] = `Umlaufzeit (${info.parentName})`;
                factMap['taglaenge'] = 'Sonnenaufg√§nge';
            }

            else if (info.name.includes('Voyager')) {
                 factMap['radius_km'] = 'Distanz zur Erde';
                 factMap['taglaenge'] = 'Missionsdauer';
            }

            // +++  RAKETEN-LABEL ANPASSEN +++
            else if (info.type === 'rocket') {
                factMap['radius_km'] = 'H√∂he'; // "Radius" wird zu "H√∂he"
                // Da wir "distance_Mio_km" im Objekt gel√∂scht haben, 
                // wird "Abstand zur Sonne" automatisch nicht angezeigt.
            }
            // +++ ENDE  +++

            let detailsHTML = ``;
            
            // velocity hinzugef√ºgt
            const orderedKeys = ['earthCompareRadius', 'radius_km', 'distance_Mio_km', 'planetType_de', 'umlaufzeit', 'taglaenge', 'temperatur', 'oberflaeche_temp', 'zusammensetzung', 'velocity'];
            
            orderedKeys.forEach(key => {
                if (info.name === 'Sonne' && key === 'umlaufzeit') return;

                if (info[key] && factMap[key]) {
                    detailsHTML += `<p><strong>${factMap[key]}:</strong> <span>${info[key]}</span></p>`;
                }
            });

            if (info.funFacts && info.funFacts.length > 0) {
                info.funFacts.forEach((fact, index) => {
                    const style = (index === 0) ? 'margin-top: 15px; padding-top: 10px; border-top: 1px dashed #444;' : '';
                    detailsHTML += `<p class="fun-fact" style="${style}">${fact}</p>`;
                });
            }
            detailsEl.innerHTML = detailsHTML;
            popup.style.display = 'flex';
        }

        // --- REWIND BUTTON ICON ---
        const iconRewind = `
            <svg viewBox="0 0 24 24">
                <path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/>
            </svg>`;

        const rewindBtn = document.getElementById('rewind-btn');
        if (rewindBtn) {
            rewindBtn.innerHTML = iconRewind;
        }

        // --- VOLLBILD FUNKTION (Mit iPad Fix & SVG Icons) ---
        
        // Icons ohne Rahmen wirken besser, wenn sie simpel sind
        const iconEnter = `
            <svg viewBox="0 0 24 24">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
            </svg>`;

        const iconExit = `
            <svg viewBox="0 0 24 24">
                <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
            </svg>`;

        const fullscreenBtn = document.getElementById('fullscreen-btn');
        
        // --- SVG ICONS DEFINITION ---
        const iconPlay = `
            <svg viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z"/> </svg>`;

        const iconPause = `
            <svg viewBox="0 0 24 24">
                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/> </svg>`;

        // Initiales Icon setzen
        fullscreenBtn.innerHTML = iconEnter;

        // Hilfsfunktion: Pr√ºfen, ob Vollbild aktiv ist (auch f√ºr Safari/iPad)
        function isFullscreen() {
            return document.fullscreenElement || 
                   document.webkitFullscreenElement || 
                   document.mozFullScreenElement || 
                   document.msFullscreenElement;
        }

        fullscreenBtn.addEventListener('click', () => {
            const elem = document.documentElement; // Das gesamte HTML-Dokument

            if (!isFullscreen()) {
                // --- Vollbild AKTIVIEREN ---
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.log(err));
                } else if (elem.webkitRequestFullscreen) { /* Safari / iPad */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
                
                // Icon √§ndern
                fullscreenBtn.innerHTML = iconExit;
                fullscreenBtn.title = "Vollbild beenden";
                
            } else {
                // --- Vollbild BEENDEN ---
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari / iPad */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
                
                // Icon √§ndern
                fullscreenBtn.innerHTML = iconEnter;
                fullscreenBtn.title = "Vollbild aktivieren";
            }
        });

        // Event-Listener f√ºr alle Browser-Varianten
        ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(
            eventType => document.addEventListener(eventType, () => {
                
                if (isFullscreen()) {
                    // --- Vollbild ist AKTIV ---
                    fullscreenBtn.innerHTML = iconExit;
                    fullscreenBtn.title = "Vollbild beenden";
                    
                    // WICHTIG: Klasse hinzuf√ºgen, damit CSS reagieren kann
                    document.body.classList.add('is-fullscreen');
                    
                } else {
                    // --- Vollbild ist INAKTIV ---
                    fullscreenBtn.innerHTML = iconEnter;
                    fullscreenBtn.title = "Vollbild aktivieren";
                    
                    // WICHTIG: Klasse entfernen
                    document.body.classList.remove('is-fullscreen');
                }
            })
        );

        init();
    </script>
</body>
</html>