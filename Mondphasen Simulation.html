<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sonnensystem-Simulation (6. Klasse)</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-container {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.75);
            padding: 15px;
            border-radius: 12px;
            max-width: 320px;
            width: calc(100% - 40px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            transition: max-width 0.3s ease, padding 0.3s ease;
            z-index: 1000; /* Sicherstellen, dass UI Ã¼ber 3D-Szene ist */
        }

        /* Neu: FÃ¼r minimierbare UI */
        #toggle-ui {
            width: 100%;
            margin-bottom: 10px;
            font-size: 12px;
            padding: 6px;
        }
        #ui-container.minimized {
            max-width: 100px;
            padding: 10px 5px;
            overflow: hidden;
        }
        #ui-container.minimized .control-group {
            display: none;
        }
        #ui-container.minimized #toggle-ui {
            margin-bottom: 0;
        }
        /* Ende Neu */

        .control-group {
            margin-bottom: 15px;
        }

        .control-group h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 10px 0;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: 500;
        }

        .btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .btn:hover {
            background-color: #0056b3;
        }
        
        .btn:active {
            transform: scale(0.98);
        }

        .btn-secondary {
            background-color: #4a4a4a;
        }
        .btn-secondary:hover {
            background-color: #666;
        }
        
        .btn-warning {
            background-color: #ffc107;
            color: #000;
        }
        .btn-warning:hover {
            background-color: #e0a800;
        }
        
        .btn-danger { /* Neuer Button-Style */
            background-color: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }


        .btn-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .btn-group button {
            flex-grow: 1;
            font-size: 12px;
            padding: 6px 8px;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        
        #info-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            margin-top: 10px;
            min-height: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        
        #moon-phases-ui {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }
        
        #moon-phases-ui button {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 5px;
            height: 42px; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            line-height: 1;
        }
        
        #moon-phases-ui button:hover {
            background: #444;
        }
        
        #moon-phases-ui button.active {
            background: #4A4A4A; 
            border-color: #ffc107; 
            font-weight: bold;
            box-shadow: 0 0 8px 1px rgba(255, 193, 7, 0.7); 
        }

        #demo-speed-control {
            display: none; 
            margin-top: 10px;
        }

    </style>
</head>
<body>

    <div id="container"></div>

    <div id="ui-container">
        
        <button id="toggle-ui" class="btn btn-secondary">Verbergen</button>

        <div class="control-group">
            <h3>Steuerung</h3>
            <div class="btn-group" style="margin-bottom: 15px;">
                <button id="play-pause-btn" class="btn">Pause</button>
            </div>
            
            <label for="day-slider">Tag im Jahr: <span id="day-label">0</span></label>
            <input type="range" id="day-slider" min="0" max="365" value="0" step="0.1">
            
            <label for="speed-slider" style="margin-top: 10px;">Geschwindigkeit: <span id="speed-label">1.0</span>x</label>
            <input type="range" id="speed-slider" min="0" max="100" value="10" step="1"> <!-- Startwert auf 10 (langsamer) gesetzt -->

            <!-- MODIFIZIERT: Label-Text geÃ¤ndert -->
            <label class="checkbox-label" style="margin-top: 15px;">
                <input type="checkbox" id="orbit-checkbox" checked>
                Erd-/Mondbahn anzeigen
            </label>
            
            <!-- MODIFIZIERT: Label-Text geÃ¤ndert -->
            <label class="checkbox-label" style="margin-top: 10px;">
                <input type="checkbox" id="planets-checkbox" checked>
                Andere Planeten & Bahnen
            </label>
            
            <label for="darkness-slider" style="margin-top: 10px;">Helligkeit (Nachtseite): <span id="darkness-label">0.30</span></label>
            <input type="range" id="darkness-slider" min="0" max="0.9" value="0.3" step="0.01">
        </div>

        <div class="control-group">
            <h3>Kamera-Fokus</h3>
            <div class="btn-group">
                <button id="focus-system" class="btn btn-secondary">Sonnensystem</button>
                <button id="focus-earth" class="btn btn-secondary">Erde</button>
                <button id="focus-moon" class="btn btn-secondary">Mond</button>
                <button id="focus-ecliptic" class="btn btn-secondary">Ekliptik-Sicht</button>
            </div>
            <!-- NEU: Container fÃ¼r Planeten-Fokus-Buttons -->
            <div id="planet-focus-buttons" class="btn-group" style="margin-top: 10px; display: none;">
                <!-- Wird per JS befÃ¼llt -->
            </div>
        </div>

        <div class="control-group">
            <h3>Ereignisse</h3>
            <div class="btn-group" id="demo-buttons">
                <button id="demo-sofi" class="btn btn-warning">Demo: SoFi</button>
                <button id="demo-mofi" class="btn btn-warning">Demo: MoFi</button>
            </div>
            <div class="btn-group" id="demo-control-buttons" style="display: none; margin-top: 10px;">
                <button id="end-demo-btn" class="btn btn-danger">Demo beenden</button>
            </div>
            
            <div id="demo-speed-control">
                 <label for="demo-speed-slider" style="margin-top: 10px;">Demo-Geschw.: <span id="demo-speed-label">1.0</span>x</label>
                 <input type="range" id="demo-speed-slider" min="0" max="100" value="50" step="1">
            </div>
            
            <div id="info-box">Tag: 0</div>
        </div>

        <div class="control-group">
            <h3>Mondphasen</h3>
            <div id="moon-phases-ui">
                <button id="phase-0" data-phase-index="0" class="moon-phase-btn" title="Neumond (Springen)">ðŸŒ‘</button>
                <button id="phase-1" data-phase-index="1" class="moon-phase-btn" title="Zunehmende Sichel (Springen)">ðŸŒ’</button>
                <button id="phase-2" data-phase-index="2" class="moon-phase-btn" title="Zunehmender Halbmond (Springen)">ðŸŒ“</button>
                <button id="phase-3" data-phase-index="3" class="moon-phase-btn" title="Zunehmendes Drittel (Springen)">ðŸŒ”</button>
                <button id="phase-4" data-phase-index="4" class="moon-phase-btn" title="Vollmond (Springen)">ðŸŒ•</button>
                <button id="phase-5" data-phase-index="5" class="moon-phase-btn" title="Abnehmendes Drittel (Springen)">ðŸŒ–</button>
                <button id="phase-6" data-phase-index="6" class="moon-phase-btn" title="Abnehmender Halbmond (Springen)">ðŸŒ—</button>
                <button id="phase-7" data-phase-index="7" class="moon-phase-btn" title="Abnehmende Sichel (Springen)">ðŸŒ˜</button>
            </div>
        </div>
    </div>

    <script>
        // --- Globale Variablen ---
        let scene, camera, renderer, controls;
        let sun, earth, moon, earthPivot, moonPivot;
        let earthOrbitLine, moonOrbitLine;
        let starField;
        
        let otherPlanets = [];
        let otherPlanetPivots = [];
        let otherPlanetOrbits = [];
        let planetsData = [];
        let saturnRingMaterial;
        
        let isPlaying = true;
        let currentDay = 0;
        let speed = 1.0;
        let cameraFocus = 'system';
        let lastCameraTargetPos = new THREE.Vector3();
        let isDemoActive = false;
        let originalMoonMaterial;
        let moonPhaseButtons = [];

        // Demo-spezifische Variablen
        let demoLoopStartDay = 0;
        let demoLoopEndDay = 0;
        let demoLoopSpeed = 0.1; 
        let demoType = ''; 
        let demoShadowBrightness = 0.0; 
        let demoRedOverlay = 0.0; 
        let earthDemoRotationOffset = 0.0;

        // --- Konstanten ---
        const SCENE_SCALE = 1.0;
        const SUN_RADIUS = 20 * SCENE_SCALE; 
        const EARTH_RADIUS = 2.5 * SCENE_SCALE;
        const MOON_RADIUS = 0.7 * SCENE_SCALE;
        
        const EARTH_DISTANCE = 150 * SCENE_SCALE;
        const MOON_DISTANCE = 15 * SCENE_SCALE;

        const EARTH_TILT_RAD = (23.5 * Math.PI) / 180;
        const MOON_TILT_RAD = (5.1 * Math.PI) / 180; 

        const EARTH_YEAR_DAYS = 365.25;
        const LUNAR_MONTH_DAYS = 29.53; 
        
        const PHASE_OFFSET_DAYS = 5; 
        
        const PHASE_DAY_MAP = [
            LUNAR_MONTH_DAYS * 0.02  + PHASE_OFFSET_DAYS, // Neumond
            LUNAR_MONTH_DAYS * 0.145 + PHASE_OFFSET_DAYS, // Zun. Sichel (Index 1)
            LUNAR_MONTH_DAYS * 0.27  + PHASE_OFFSET_DAYS, // Zun. Halbmond (Index 2)
            LUNAR_MONTH_DAYS * 0.395 + PHASE_OFFSET_DAYS, // Zun. Drittel (Index 3)
            LUNAR_MONTH_DAYS * 0.55  + PHASE_OFFSET_DAYS, // Vollmond
            LUNAR_MONTH_DAYS * 0.71  + PHASE_OFFSET_DAYS, // Abn. Drittel (Index 5)
            LUNAR_MONTH_DAYS * 0.85  + PHASE_OFFSET_DAYS, // Abn. Halbmond (Index 6)
            LUNAR_MONTH_DAYS * 0.97  + PHASE_OFFSET_DAYS  // Abn. Sichel (Index 7)
        ];
        
        // --- DOM-Elemente ---
        const container = document.getElementById('container');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const daySlider = document.getElementById('day-slider');
        const dayLabel = document.getElementById('day-label');
        const speedSlider = document.getElementById('speed-slider');
        const speedLabel = document.getElementById('speed-label');
        const orbitCheckbox = document.getElementById('orbit-checkbox');
        const infoBox = document.getElementById('info-box');
        
        const planetsCheckbox = document.getElementById('planets-checkbox');
        const planetFocusContainer = document.getElementById('planet-focus-buttons');

        const darknessSlider = document.getElementById('darkness-slider');
        const darknessLabel = document.getElementById('darkness-label');

        const demoButtons = document.getElementById('demo-buttons');
        const demoControlButtons = document.getElementById('demo-control-buttons');
        const endDemoBtn = document.getElementById('end-demo-btn');
        const demoSpeedControl = document.getElementById('demo-speed-control');
        const demoSpeedSlider = document.getElementById('demo-speed-slider');
        const demoSpeedLabel = document.getElementById('demo-speed-label');
        
        // --- Shader (Erde & ANDERE PLANETEN) ---
        const earthVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            
            void main() {
                vUv = uv;
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const earthFragmentShader = `
            uniform sampler2D dayTexture;
            uniform vec3 uSunPosition;
            uniform vec3 uObjectWorldPosition;
            uniform float uNightBrightness;
            
            uniform bool uSofiDemoActive;
            uniform vec3 uMoonPosition;
            uniform float uMoonRadius;
            uniform float uSunRadius;
            
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            
            float calculateMoonShadowIntensity(vec3 pixelPos, vec3 moonPos, float moonRadius, vec3 sunPos, float sunRadius) {
                
                vec3 sunToMoon = moonPos - sunPos;
                vec3 shadowAxis = normalize(sunToMoon);

                vec3 sunToPixel = pixelPos - sunPos;
                
                float depthInShadow = dot(sunToPixel, shadowAxis);
                if (depthInShadow < 0.0) return 1.0; 

                vec3 closestPointOnAxis = sunPos + shadowAxis * depthInShadow;
                
                float pixelDistanceToAxis = distance(pixelPos, closestPointOnAxis);

                float umbraRadius = moonRadius * 0.1;
                float penumbraRadius = moonRadius * 1.0; 

                if (pixelDistanceToAxis > penumbraRadius) {
                    return 1.0;
                }

                if (pixelDistanceToAxis < umbraRadius) {
                    return 0.0;
                }

                float progress = (pixelDistanceToAxis - umbraRadius) / (penumbraRadius - umbraRadius);
                return mix(0.4, 0.9, progress);
            }
            
            void main() {
                vec3 objectToSun = normalize(uSunPosition - uObjectWorldPosition);
                vec3 objectToFragment = normalize(vWorldPosition - uObjectWorldPosition);
                
                float intensity = (dot(objectToFragment, objectToSun) + 1.0) / 2.0;
                
                float nightBrightness = uNightBrightness;
                float lightMix = smoothstep(0.48, 0.59, intensity);
                
                vec4 dayColor = texture2D(dayTexture, vUv);
                vec4 nightColor = dayColor * nightBrightness;
                
                vec4 finalColor = mix(nightColor, dayColor, lightMix);

                if (uSofiDemoActive) {
                    if (intensity > 0.01) { 
                        float moonShadowIntensity = calculateMoonShadowIntensity(
                            vWorldPosition, 
                            uMoonPosition, 
                            uMoonRadius,
                            uSunPosition,
                            uSunRadius
                        );
                        finalColor.rgb *= moonShadowIntensity;
                    }
                }

                gl_FragColor = finalColor;
            }
        `;
        
        // --- Shader (Mond) ---
        const moonVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            
            void main() {
                vUv = uv;
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const moonFragmentShader = `
            uniform sampler2D dayTexture;
            uniform vec3 uSunPosition;
            uniform vec3 uEarthPosition;
            uniform vec3 uObjectWorldPosition;
            
            uniform float uEarthRadius;
            uniform float uSunRadius;
            uniform float uMoonRadius;
            uniform float uNightBrightness;
            
            uniform bool uDemoActive;
            uniform float uShadowBrightness;
            uniform float uRedOverlayIntensity;

            varying vec2 vUv;
            varying vec3 vWorldPosition;

            float calculateShadowIntensity(vec3 pixelPos, vec3 earthPos, float earthRadius, vec3 sunPos, float sunRadius) {
                
                vec3 sunToEarth = earthPos - sunPos;
                vec3 shadowAxis = normalize(sunToEarth);

                vec3 sunToPixel = pixelPos - sunPos;
                
                float depthInShadow = dot(sunToPixel, shadowAxis);
                if (depthInShadow < 0.0) return 1.0;

                vec3 closestPointOnAxis = sunPos + shadowAxis * depthInShadow;
                
                float pixelDistanceToAxis = distance(pixelPos, closestPointOnAxis);

                float umbraRadius = uEarthRadius * 0.9;
                
                float startRatio = 0.95; 
                float endRatio = 1.05;   
                
                float intensity = smoothstep(umbraRadius * startRatio, umbraRadius * endRatio, pixelDistanceToAxis);
                
                return intensity; 
            }

            void main() {
                vec4 textureColor = texture2D(dayTexture, vUv);
                
                vec3 objectToSun = normalize(uSunPosition - uObjectWorldPosition);
                vec3 objectToFragment = normalize(vWorldPosition - uObjectWorldPosition);
                float sunLightIntensity = (dot(objectToFragment, objectToSun) + 1.0) / 2.0;
                float nightBrightness = uNightBrightness;
                float sunLightMix = smoothstep(0.5, 0.6, sunLightIntensity);
                
                vec4 sunLitColor = mix(textureColor * nightBrightness, textureColor, sunLightMix);

                if (uDemoActive) {
                    vec4 finalColor = vec4(sunLitColor.rgb, 1.0);

                    float earthShadowIntensity = calculateShadowIntensity(
                        vWorldPosition, 
                        uEarthPosition, 
                        uEarthRadius, 
                        uSunPosition, 
                        uSunRadius
                    );

                    if (earthShadowIntensity < 1.0) {
                        if (earthShadowIntensity == 0.0) {
                            finalColor.rgb = mix(finalColor.rgb, finalColor.rgb * uShadowBrightness, sunLightMix);
                        } else {
                             finalColor.rgb *= (1.0 - (1.0 - earthShadowIntensity) * sunLightMix); 
                        }
                    }
                    
                    vec3 bloodMoonColor = vec3(1.0, 0.2, 0.0);
                    float redMixAmount = uRedOverlayIntensity * sunLightMix * 0.4;
                    
                    finalColor.rgb = mix(finalColor.rgb, bloodMoonColor, redMixAmount);
                    
                    gl_FragColor = finalColor;

                } else {
                    gl_FragColor = sunLitColor;
                }
            }
        `;
        
        // --- Shader (Saturn-Ring) ---
        const ringVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPosition;
            
            void main() {
                vUv = uv;
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const ringFragmentShader = `
            uniform sampler2D ringTexture;
            uniform vec3 uSunPosition;
            uniform vec3 uSaturnPosition;
            uniform float uSaturnRadius;
            uniform float uNightBrightness;
            
            varying vec2 vUv;
            varying vec3 vWorldPosition;

            float getShadow(vec3 fragPos, vec3 shadowCasterPos, float casterRadius, vec3 sunPos) {
                vec3 sunToCaster = normalize(shadowCasterPos - sunPos);
                vec3 casterToFrag = fragPos - shadowCasterPos;

                float distOnAxis = dot(casterToFrag, sunToCaster);
                if (distOnAxis < 0.0) return 1.0;

                vec3 closestPointOnAxis = shadowCasterPos + sunToCaster * distOnAxis;
                float distToAxis = distance(fragPos, closestPointOnAxis);
                
                return smoothstep(casterRadius * 0.9, casterRadius * 1.1, distToAxis);
            }

            void main() {
                vec4 texColor = texture2D(ringTexture, vUv);
                
                float shadowIntensity = getShadow(vWorldPosition, uSaturnPosition, uSaturnRadius, uSunPosition);
                
                vec4 nightColor = vec4(texColor.rgb * uNightBrightness, texColor.a);
                
                gl_FragColor = mix(nightColor, texColor, shadowIntensity);
                
                gl_FragColor.a *= texColor.a;
            }
        `;

        // --- Initialisierung ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(EARTH_DISTANCE * 1.5, EARTH_DISTANCE * 0.7, EARTH_DISTANCE * 1.5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.touches = {
                ONE: 0,
                TWO: 2
            };

            definePlanetData();
            createSolarSystem();
            createOrbits();
            setupUI();

            cameraFocus = sun; 

            animate();
            
            window.addEventListener('resize', onWindowResize);
            
            updatePositions(currentDay);
            updateCamera(true); 
        }
        
        // --- Planetendaten (MODIFIZIERT: Pluto hinzugefÃ¼gt) ---
        function definePlanetData() {
            const textureBasePath = 'https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/Images/';
            
            planetsData = [
                { 
                    name: 'Mercury', 
                    radius: 1.0 * SCENE_SCALE, 
                    distance: 60 * SCENE_SCALE, 
                    yearDays: 88, 
                    texture: textureBasePath + '2k_mercury.jpg',
                    axialTilt: 0.03,
                    rotationSpeed: 0.017 // NEU (1 / 58.6 Tage)
                },
                { 
                    name: 'Venus', 
                    radius: 2.2 * SCENE_SCALE, 
                    distance: 110 * SCENE_SCALE, 
                    yearDays: 225, 
                    texture: textureBasePath + '2k_venus_surface.jpg',
                    axialTilt: 177.0,
                    rotationSpeed: -0.0041 // NEU (Retrograd, 1 / 243 Tage)
                },
                { 
                    name: 'Mars', 
                    radius: 1.5 * SCENE_SCALE, 
                    distance: 230 * SCENE_SCALE, 
                    yearDays: 687, 
                    texture: textureBasePath + '2k_mars.jpg',
                    axialTilt: 25.19,
                    rotationSpeed: 0.97 // NEU (1 / 1.03 Tage)
                },
                { 
                    name: 'Jupiter', 
                    radius: 16.0 * SCENE_SCALE, 
                    distance: 500 * SCENE_SCALE, 
                    yearDays: 4333, 
                    texture: textureBasePath + '2k_jupiter.jpg',
                    axialTilt: 3.13,
                    rotationSpeed: 2.43 // NEU (Sehr schnell, 1 / 0.41 Tage)
                },
                { 
                    name: 'Saturn', 
                    radius: 13.0 * SCENE_SCALE, 
                    distance: 750 * SCENE_SCALE, 
                    yearDays: 10759, 
                    texture: textureBasePath + '2k_saturn.jpg',
                    ringTexture: textureBasePath + '2k_saturn_ring_alpha.png',
                    axialTilt: 26.73,
                    rotationSpeed: 2.22 // NEU (Schnell, 1 / 0.45 Tage)
                },
                { 
                    name: 'Uranus', 
                    radius: 6.0 * SCENE_SCALE, 
                    distance: 900 * SCENE_SCALE, 
                    yearDays: 30687, 
                    texture: textureBasePath + '2k_uranus.jpg',
                    axialTilt: 97.77,
                    rotationSpeed: 1.38 // NEU (Retrograd, 1 / 0.72 Tage)
                },
                { 
                    name: 'Neptune', 
                    radius: 5.8 * SCENE_SCALE, 
                    distance: 1100 * SCENE_SCALE, 
                    yearDays: 60190, 
                    texture: textureBasePath + '2k_neptune.jpg',
                    axialTilt: 28.32,
                    rotationSpeed: 1.49 // NEU (1 / 0.67 Tage)
                },
                // --- NEU: Pluto ---
                {
                    name: 'Pluto',
                    radius: 0.5 * SCENE_SCALE, // Sehr klein
                    distance: 1300 * SCENE_SCALE, // Weiter weg als Neptun
                    yearDays: 90582, // ca. 248 Erdjahre
                    texture: textureBasePath + '2k_pluto.jpg', // Platzhalter fÃ¼r deine Textur
                    axialTilt: 122.5, // Extreme Achsenneigung
                    orbitalInclination: 17.16, // Starke Bahnneigung
                    rotationSpeed: -0.156 // NEU (Retrograd, 1 / 6.39 Tage)
                }
                // --- ENDE NEU ---
            ];
        }

        // --- HimmelskÃ¶rper erstellen ---
        // (MODIFIZIERT: Bahneigung fÃ¼r Pluto)
        function createSolarSystem() {
            const textureLoader = new THREE.TextureLoader();

            // 1. Sternenhimmel
            const starGeometry = new THREE.SphereGeometry(3000, 32, 32); 
            const starTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/8k_stars.jpg');
            const starMaterial = new THREE.MeshBasicMaterial({
                map: starTexture,
                side: THREE.BackSide 
            });
            starField = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(starField);

            // 2. Sonne
	        const sunTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/2k_sun.jpg');
            const sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture });
	        sun = new THREE.Mesh(new THREE.SphereGeometry(SUN_RADIUS, 32, 32), sunMaterial);
            scene.add(sun);
            
            // 3. Erde
            earthPivot = new THREE.Group();
            scene.add(earthPivot);

            const earthMaterial = new THREE.ShaderMaterial({
                vertexShader: earthVertexShader,
                fragmentShader: earthFragmentShader,
                uniforms: {
                    dayTexture: { value: textureLoader.load('https://stemkoski.github.io/Three.js/images/earth-day.jpg') },
                    uSunPosition: { value: new THREE.Vector3(0, 0, 0) },
                    uObjectWorldPosition: { value: new THREE.Vector3() },
                    uNightBrightness: { value: 0.3 }, 
                    uSofiDemoActive: { value: false },
                    uMoonPosition: { value: new THREE.Vector3() },
                    uMoonRadius: { value: MOON_RADIUS },
                    uSunRadius: { value: SUN_RADIUS } 
                }
            });
            earth = new THREE.Mesh(new THREE.SphereGeometry(EARTH_RADIUS, 32, 32), earthMaterial);
            earth.position.x = EARTH_DISTANCE;
            earth.rotation.order = 'YXZ'; 
            earth.rotation.z = EARTH_TILT_RAD; 
            earthPivot.add(earth);

            // 4. Mond
            moonPivot = new THREE.Group();
            moonPivot.rotation.x = MOON_TILT_RAD; 
            scene.add(moonPivot); 

            originalMoonMaterial = new THREE.ShaderMaterial({
                vertexShader: moonVertexShader,
                fragmentShader: moonFragmentShader,
                uniforms: {
                    dayTexture: { value: textureLoader.load('https://cdn.jsdelivr.net/gh/NisuSchnisuu/Simulation-Mondphasen@main/2k_moon.jpg') },
                    uSunPosition: { value: new THREE.Vector3(0, 0, 0) },
                    uEarthPosition: { value: new THREE.Vector3() },
                    uObjectWorldPosition: { value: new THREE.Vector3() },
                    uEarthRadius: { value: EARTH_RADIUS },
                    uSunRadius: { value: SUN_RADIUS },
                    uMoonRadius: { value: MOON_RADIUS },
                    uNightBrightness: { value: 0.3 },
                    uDemoActive: { value: false },
                    uShadowBrightness: { value: 0.0 }, 
                    uRedOverlayIntensity: { value: 0.0 } 
                }
            });
            moon = new THREE.Mesh(new THREE.SphereGeometry(MOON_RADIUS, 32, 32), originalMoonMaterial);
            moon.position.x = -MOON_DISTANCE; 
            moonPivot.add(moon);
            
            // 5. Andere Planeten
            planetsData.forEach(data => {
                const pivot = new THREE.Group();
                
                // --- NEU: Bahneigung (Inklination) ---
                // PrÃ¼ft, ob der Planet eine Bahneigung hat (z.B. Pluto)
                if (data.orbitalInclination) {
                    pivot.rotation.x = (data.orbitalInclination * Math.PI) / 180;
                }
                // --- ENDE NEU ---
                
                scene.add(pivot);
                
                const material = new THREE.ShaderMaterial({
                    vertexShader: earthVertexShader,
                    fragmentShader: earthFragmentShader,
                    uniforms: {
                        dayTexture: { value: textureLoader.load(data.texture) },
                        uSunPosition: { value: new THREE.Vector3(0, 0, 0) },
                        uObjectWorldPosition: { value: new THREE.Vector3() },
                        uNightBrightness: { value: 0.3 },
                        uSofiDemoActive: { value: false },
                        uMoonPosition: { value: new THREE.Vector3() },
                        uMoonRadius: { value: 0.1 },
                        uSunRadius: { value: SUN_RADIUS } 
                    }
                });

                const planet = new THREE.Mesh(new THREE.SphereGeometry(data.radius, 32, 32), material);
                planet.position.x = data.distance;
                
                planet.rotation.order = 'YXZ';
                planet.rotation.z = (data.axialTilt * Math.PI) / 180;

                // Speziell fÃ¼r Saturn: Ring hinzufÃ¼gen
                if (data.name === 'Saturn') {
                    const ringTexture = textureLoader.load(data.ringTexture);
                    ringTexture.wrapT = THREE.RepeatWrapping;

                    saturnRingMaterial = new THREE.ShaderMaterial({
                        vertexShader: ringVertexShader,
                        fragmentShader: ringFragmentShader,
                        uniforms: {
                            ringTexture: { value: ringTexture },
                            uSunPosition: { value: new THREE.Vector3(0, 0, 0) },
                            uSaturnPosition: { value: new THREE.Vector3() },
                            uSaturnRadius: { value: data.radius },
                            uNightBrightness: { value: 0.3 }
                        },
                        transparent: true,
                        side: THREE.DoubleSide
                    });

                    const ringGeometry = new THREE.RingGeometry(data.radius * 1.2, data.radius * 2.2, 64);
                    
                    ringGeometry.rotateX(Math.PI / 2); 
                    
                    const pos = ringGeometry.attributes.position;
                    const uv = ringGeometry.attributes.uv;
                    const innerRadius = data.radius * 1.2;
                    const outerRadius = data.radius * 2.2;
                    const repeatFactor = 10; 
                    
                    for (let i = 0; i < pos.count; i++) {
                        const x = pos.getX(i);
                        const z = pos.getZ(i);
                        let angle = 1.0 - ((Math.atan2(z, x) / (Math.PI * 2)) + 0.5);
                        let v = angle * repeatFactor;
                        const r = Math.sqrt(x * x + z * z);
                        let u = (r - innerRadius) / (outerRadius - innerRadius);
                        uv.setXY(i, u, v);
                    }
                    
                    const ringMesh = new THREE.Mesh(ringGeometry, saturnRingMaterial);
                    planet.add(ringMesh);
                }
                
                pivot.add(planet);

                otherPlanets.push(planet);
                otherPlanetPivots.push(pivot);
            });
        }

        // --- Umlaufbahnen (Linien) ---
        // (MODIFIZIERT: Bahneigung fÃ¼r Pluto-Orbit)
        function createOrbits() {
            const createOrbitLine = (radius, color, segments = 128) => {
                const points = [];
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: color });
                return new THREE.Line(geometry, material);
            };

            earthOrbitLine = createOrbitLine(EARTH_DISTANCE, 0x0000FF);
            scene.add(earthOrbitLine);

            moonOrbitLine = createOrbitLine(MOON_DISTANCE, 0xFFFF00);
            moonOrbitLine.rotation.x = MOON_TILT_RAD; 
            scene.add(moonOrbitLine); 
            
            planetsData.forEach(data => {
                const orbitLine = createOrbitLine(data.distance, 0x555555); // Grau
                
                // --- NEU: Bahneigung (Inklination) fÃ¼r Orbitlinie ---
                if (data.orbitalInclination) {
                    orbitLine.rotation.x = (data.orbitalInclination * Math.PI) / 180;
                }
                // --- ENDE NEU ---
                
                scene.add(orbitLine);
                otherPlanetOrbits.push(orbitLine);
            });
        }

        // --- UI-Einrichtung ---
        // (MODIFIZIERT: Pluto-Button-Name)
        function setupUI() {
            //Verbergen Button toggle
             const uiContainer = document.getElementById('ui-container');
            const toggleBtn = document.getElementById('toggle-ui');
            toggleBtn.addEventListener('click', () => {
                uiContainer.classList.toggle('minimized');
                toggleBtn.textContent = uiContainer.classList.contains('minimized') ? 'Anzeigen' : 'Verbergen';
            });
            
            //Orbit Checkbox
            orbitCheckbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                earthOrbitLine.visible = isChecked;
                moonOrbitLine.visible = isChecked;
            });
            earthOrbitLine.visible = orbitCheckbox.checked;
            moonOrbitLine.visible = orbitCheckbox.checked;

            // Checkbox fÃ¼r andere Planeten
            planetsCheckbox.addEventListener('change', (e) => {
                const isVisible = e.target.checked;
                otherPlanetPivots.forEach(pivot => {
                    pivot.visible = isVisible;
                });
                otherPlanetOrbits.forEach(orbit => {
                    orbit.visible = isVisible;
                });
                planetFocusContainer.style.display = isVisible ? 'flex' : 'none';
            });
            const planetsInitiallyVisible = planetsCheckbox.checked;
            otherPlanetPivots.forEach(pivot => { pivot.visible = planetsInitiallyVisible; });
            otherPlanetOrbits.forEach(orbit => { orbit.visible = planetsInitiallyVisible; });

            
            // Event-Listener fÃ¼r Dunkelheits-Slider
            darknessSlider.addEventListener('input', (e) => {
                const brightness = parseFloat(e.target.value);
                
                earth.material.uniforms.uNightBrightness.value = brightness;
                originalMoonMaterial.uniforms.uNightBrightness.value = brightness;
                
                otherPlanets.forEach(planet => {
                    planet.material.uniforms.uNightBrightness.value = brightness;
                });
                
                if (saturnRingMaterial) {
                    saturnRingMaterial.uniforms.uNightBrightness.value = brightness;
                }
                
                darknessLabel.textContent = brightness.toFixed(2);
            });
            
            //Speedslider Fix
            speedSlider.addEventListener('input', onSpeedSliderChange);
            onSpeedSliderChange(); 
            //Play Button fix
            playPauseBtn.addEventListener('click', togglePlay);
            daySlider.addEventListener('input', () => {
                pauseSimulation();
                currentDay = parseFloat(daySlider.value);
                updatePositions(currentDay);
                updateUI();
            });
            
            // Initialwert setzen
            const initialBrightness = parseFloat(darknessSlider.value);
            earth.material.uniforms.uNightBrightness.value = initialBrightness;
            originalMoonMaterial.uniforms.uNightBrightness.value = initialBrightness;
            otherPlanets.forEach(planet => {
                planet.material.uniforms.uNightBrightness.value = initialBrightness;
            });
            if (saturnRingMaterial) {
                saturnRingMaterial.uniforms.uNightBrightness.value = initialBrightness;
            }
            darknessLabel.textContent = initialBrightness.toFixed(2);


            // Event Listener fÃ¼r Fokus
            document.getElementById('focus-system').addEventListener('click', () => setFocus(sun));
            document.getElementById('focus-earth').addEventListener('click', () => setFocus(earth));
            document.getElementById('focus-moon').addEventListener('click', () => setFocus(moon));

            // Listener fÃ¼r Ekliptik-Sicht
            document.getElementById('focus-ecliptic').addEventListener('click', () => {
                cameraFocus = 'ecliptic_side_view';
                
                let earthPos = new THREE.Vector3();
                earth.getWorldPosition(earthPos);
                
                controls.target.set(0, 0, 0); 
                
                let offset = earthPos.clone().normalize().multiplyScalar(40);
                let sideOffset = new THREE.Vector3(-earthPos.z, 0, earthPos.x).normalize().multiplyScalar(4); 
                
                camera.position.copy(earthPos).add(offset).add(sideOffset);
            });

            document.getElementById('demo-sofi').addEventListener('click', () => startDemo('sofi'));
            document.getElementById('demo-mofi').addEventListener('click', () => startDemo('mofi'));
            endDemoBtn.addEventListener('click', endDemo);
            
            demoSpeedSlider.addEventListener('input', onDemoSpeedSliderChange);
            onDemoSpeedSliderChange();

            document.querySelectorAll('#moon-phases-ui button').forEach(btn => {
                const index = parseInt(btn.dataset.phaseIndex);
                btn.addEventListener('click', () => jumpToPhase(index));
                moonPhaseButtons.push(btn);
            });
            
            // Planeten-Fokus-Buttons dynamisch erstellen
            planetsData.forEach((data, index) => {
                const btn = document.createElement('button');
                btn.id = `focus-${data.name.toLowerCase()}`;
                btn.className = 'btn btn-secondary';
                
                const germanNames = {
                    'Mercury': 'Merkur', 'Venus': 'Venus', 'Mars': 'Mars', 
                    'Jupiter': 'Jupiter', 'Saturn': 'Saturn', 'Uranus': 'Uranus', 'Neptune': 'Neptun',
                    'Pluto': 'Pluto' // NEU
                };
                btn.textContent = germanNames[data.name] || data.name;

                btn.addEventListener('click', () => {
                    setFocus(otherPlanets[index]);
                });
                planetFocusContainer.appendChild(btn);
            });
            
            // Initialen Status der Planeten-Fokus-Buttons setzen
            planetFocusContainer.style.display = planetsInitiallyVisible ? 'flex' : 'none';
        }
        
        // --- Event Handler ---
        function togglePlay() {
            isPlaying = !isPlaying;
            playPauseBtn.textContent = isPlaying ? 'Pause' : 'Play';
            controls.enableZoom = true;
        }

        function pauseSimulation() {
            if (isPlaying) {
                togglePlay();
            }
        }
        
        function onSpeedSliderChange() {
            const value = parseFloat(speedSlider.value); 
            const minSpeed = 0.00005; 
            const normalSpeed = 1.0; 
            const maxSpeed = 10.0;
            
            if (value <= 90) {
                // --- MODIFIZIERT: Exponentielle Skala fÃ¼r bessere Kontrolle im langsamen Bereich ---
                // (value / 90) wird quadriert, um den Slider am Anfang langsamer ansteigen zu lassen
                const normalizedValue = (value / 90.0);
                speed = minSpeed + (normalizedValue * normalizedValue) * (normalSpeed - minSpeed);
                // --- ENDE MODIFIZIERT ---
            } else {
                // Der schnelle Bereich bleibt linear
                speed = normalSpeed + ((value - 90) / 10) * (maxSpeed - normalSpeed);
            }
            
            // Diese Sonderregel ist durch die neue Skala nicht mehr nÃ¶tig
            // if (speedSlider.value === "45") {
            //     speed = 0.5;
            // }
            
            speedLabel.textContent = speed.toFixed(4) + 'x'; 
        }
        
        function onDemoSpeedSliderChange() {
            const value = parseFloat(demoSpeedSlider.value); 
            const minSpeed = 0.01;
            const normalSpeed = 0.1;
            const maxSpeed = 1.0;
            
            if (value <= 50) {
                demoLoopSpeed = minSpeed + (value / 50) * (normalSpeed - minSpeed);
            } else {
                demoLoopSpeed = normalSpeed + ((value - 50) / 50) * (maxSpeed - normalSpeed);
            }
            demoSpeedLabel.textContent = demoLoopSpeed.toFixed(2) + 'x';
        }

        function setFocus(targetObj) {
            cameraFocus = targetObj;
            
            let zoomFactor;
            const radius = targetObj.geometry.parameters.radius;
            
            if (targetObj === moon) {
                zoomFactor = 10.0;
            } else if (targetObj === sun) {
                zoomFactor = 0.2;
            } else {
                // Dynamischer Zoom basierend auf PlanetengrÃ¶ÃŸe im VerhÃ¤ltnis zur Erde
                zoomFactor = (EARTH_RADIUS / radius) * 2.5; 
            }

            const targetPos = new THREE.Vector3();
            targetObj.getWorldPosition(targetPos);
            
            const offset = camera.position.clone().sub(controls.target).normalize().multiplyScalar(EARTH_DISTANCE / zoomFactor);
            camera.position.copy(targetPos).add(offset);
            controls.target.copy(targetPos);
            lastCameraTargetPos.copy(targetPos);

            controls.enableZoom = true;
        }

        function resetToRealMode() {
            isDemoActive = false;
            demoType = '';
            controls.enableZoom = true;

            demoButtons.style.display = 'flex';
            demoControlButtons.style.display = 'none';
            demoSpeedControl.style.display = 'none';

            earth.rotation.z = EARTH_TILT_RAD;
            earth.rotation.x = 0; 
            moonPivot.rotation.x = MOON_TILT_RAD; 
            
            earth.material.uniforms.uSofiDemoActive.value = false;
            
            if (moon.material.uniforms) {
                originalMoonMaterial.uniforms.uDemoActive.value = false; 
                originalMoonMaterial.uniforms.uShadowBrightness.value = 0.0;
                originalMoonMaterial.uniforms.uRedOverlayIntensity.value = 0.0;
            }
        }
        
        function startDemo(type) {
            pauseSimulation(); 
            resetToRealMode(); 
            
            isDemoActive = true;
            demoType = type;
            isPlaying = true; 
            playPauseBtn.textContent = 'Pause';
            controls.enableZoom = true; 

            demoButtons.style.display = 'none'; 
            demoControlButtons.style.display = 'flex'; 
            demoSpeedControl.style.display = 'block'; 
            
            if (type === 'sofi') {
                earth.rotation.z = -EARTH_TILT_RAD;
            } else {
                earth.rotation.z = 0;
            }
            
            let demoDurationDays;

            if (type === 'sofi') {
                demoDurationDays = 2; 
                currentDay = LUNAR_MONTH_DAYS * 0.0 - (demoDurationDays / 2); 
                demoLoopStartDay = currentDay;
                demoLoopEndDay = LUNAR_MONTH_DAYS * 0.0 + (demoDurationDays / 2); 
                
                earth.material.uniforms.uSofiDemoActive.value = true;
                
                earthDemoRotationOffset = 4 * Math.PI / 4; 
                
                moon.position.y = 0.3; 

                setFocus(earth);
            } else if (type === 'mofi') {
                demoDurationDays = 17.5 - 14.3; 
                currentDay = 14.3; 
                demoLoopStartDay = currentDay;
                demoLoopEndDay = 17.5; 

                moonPivot.position.y = MOON_RADIUS * 1.0; 
                
                originalMoonMaterial.uniforms.uDemoActive.value = true;
                
                setFocus(moon);
            }
            
            updatePositions(currentDay);
            daySlider.value = currentDay;
            updateUI();
        }

        function endDemo() {
            resetToRealMode();
            currentDay = 0; 
            daySlider.value = currentDay;
            moonPivot.position.y = 0; 
            
            earthDemoRotationOffset = 0.0; 
            moon.position.y = 0; 
            
            updatePositions(currentDay);
            updateUI();
        }
        
        function jumpToPhase(index) {
            pauseSimulation(); 
            resetToRealMode(); 
            
            earthDemoRotationOffset = 0.0; 
            moonPivot.position.y = 0; 
            moon.position.y = 0;
            
            currentDay = PHASE_DAY_MAP[index];

            moonPhaseButtons.forEach(btn => {
                btn.classList.remove('active');
            });
            
            const clickedButton = moonPhaseButtons.find(btn => parseInt(btn.dataset.phaseIndex) === index);
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
            
            updatePositions(currentDay);
            daySlider.value = currentDay;
            updateUI();

            cameraFocus = 'earthView';
            
            let earthPos = new THREE.Vector3();
            let moonPos = new THREE.Vector3();
            earth.getWorldPosition(earthPos);
            moon.getWorldPosition(moonPos);
            
            camera.position.copy(earthPos); 
            controls.target.copy(moonPos); 
            lastCameraTargetPos.copy(moonPos);
        }

        // --- Animations-Loop ---
        function animate() {
            requestAnimationFrame(animate);

            let actualSpeed = speed;

            if (isDemoActive) {
                actualSpeed = demoLoopSpeed;
            }

            if (isPlaying) {
                const deltaDays = (actualSpeed * (1 / 60)) * (isDemoActive ? 1 : EARTH_YEAR_DAYS / 60); 
                currentDay += deltaDays;
                
                if (isDemoActive) {
                    if (currentDay > demoLoopEndDay) {
                        currentDay = demoLoopStartDay; 
                    } else if (currentDay < demoLoopStartDay) { 
                        currentDay = demoLoopEndDay;
                    }
                }
                
                daySlider.value = currentDay % EARTH_YEAR_DAYS;
                updateUI();
            }

            updatePositions(currentDay);
            updateCamera(false);
            
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Update-Funktionen ---
        function updatePositions(day) {
            // 1. Umlaufbahn der Erde (um die Sonne)
            const earthOrbitAngle = (day / EARTH_YEAR_DAYS) * Math.PI * 2;
            earthPivot.rotation.y = earthOrbitAngle;

            // 2. Eigendrehung der Erde (1x pro Tag)
            let rotationFactor = 1.0;
            
            if (isDemoActive && demoType === 'sofi') {
                rotationFactor = 0.1; 
            }
            
            earth.rotation.y = (day * rotationFactor) * Math.PI * 2; 
            earth.rotation.y += earthDemoRotationOffset; 

            // 3. Umlaufbahn des Mondes (um die Erde)
            let moonOrbitAngle;
            if (isDemoActive) {
                moonOrbitAngle = (day / LUNAR_MONTH_DAYS) * Math.PI * 2;
            } else {
                moonOrbitAngle = ((day - PHASE_OFFSET_DAYS) / LUNAR_MONTH_DAYS) * Math.PI * 2;
            }
            
            let earthPos = new THREE.Vector3();
            earth.getWorldPosition(earthPos);
            
            moonPivot.position.copy(earthPos);
            moonPivot.rotation.y = moonOrbitAngle; 
            moonOrbitLine.position.copy(earthPos);
            
            // 4. Eigendrehung des Mondes (Gebundene Rotation)
            moon.rotation.y = 0;

            // 5. Positionen der anderen Planeten aktualisieren
            otherPlanetPivots.forEach((pivot, index) => {
                const data = planetsData[index];
                const planet = otherPlanets[index];
                
                const orbitAngle = (day / data.yearDays) * Math.PI * 2;
                pivot.rotation.y = orbitAngle;
                
                // planet.rotation.y = (day * 1.0) * Math.PI * 2; 

                // --- MODIFIZIERT: Realistische Rotationsgeschwindigkeit ---
                // Nutzt den neuen 'rotationSpeed'-Wert aus definePlanetData()
                // (relativ zur Erde = 1.0)
                planet.rotation.y = (day * data.rotationSpeed) * Math.PI * 2;
                // --- ENDE MODIFIZIERT ---

                let tempVec = new THREE.Vector3();
                planet.getWorldPosition(tempVec);
                planet.material.uniforms.uObjectWorldPosition.value.copy(tempVec);
                
                if (data.name === 'Saturn' && saturnRingMaterial) {
                    saturnRingMaterial.uniforms.uSaturnPosition.value.copy(tempVec);
                }
            });

            // 6. Shader-Uniforms aktualisieren (war 5.)
            let tempVec = new THREE.Vector3();
            earth.getWorldPosition(tempVec);
            earth.material.uniforms.uObjectWorldPosition.value.copy(tempVec);
            
            let moonWorldPosition = new THREE.Vector3();
            moon.getWorldPosition(moonWorldPosition);
            earth.material.uniforms.uMoonPosition.value.copy(moonWorldPosition);

            // MoFi-Demo Logik
            if (isDemoActive && demoType === 'mofi') {
                const animProgress = (currentDay - demoLoopStartDay) / (demoLoopEndDay - demoLoopStartDay);
                
                const dayToProgress = (d) => (d - demoLoopStartDay) / (demoLoopEndDay - demoLoopStartDay);

                const peakDay = 15.7; 
                const peakProgress = dayToProgress(peakDay); 

                const redFadeInStart = peakProgress - 0.05; 
                const redFadeOutStart = dayToProgress(16.4); 
                const redFadeOutEnd = dayToProgress(16.5);   
                
                const shadowFadeInStart = peakProgress - 0.05; 
                const shadowFadeInEnd = peakProgress;         

                const shadowFadeOutStart = dayToProgress(16.2);
                const shadowFadeOutEnd = dayToProgress(16.5);
                
                const shadowTargetBrightness = 0.6; 

                let redIntensity = 0.0;
                let shadowBrightness = 0.0; 

                if (animProgress <= peakProgress) {
                    const fadeProgress = Math.max(0.0, (animProgress - redFadeInStart) / (peakProgress - redFadeInStart));
                    redIntensity = (fadeProgress * fadeProgress); 
                }
                else if (animProgress > peakProgress && animProgress <= redFadeOutEnd) {
                    const fadeProgress = (animProgress - peakProgress) / (redFadeOutEnd - peakProgress);
                    redIntensity = 1.0 - (fadeProgress * fadeProgress); 
                }

                if (animProgress > shadowFadeInStart && animProgress <= shadowFadeInEnd) {
                    const fadeProgress = (animProgress - shadowFadeInStart) / (shadowFadeInEnd - shadowFadeInStart);
                    shadowBrightness = (fadeProgress * fadeProgress) * shadowTargetBrightness;
                }
                else if (animProgress > shadowFadeInEnd && animProgress <= shadowFadeOutStart) {
                     shadowBrightness = shadowTargetBrightness;
                }
                else if (animProgress > shadowFadeOutStart && animProgress <= shadowFadeOutEnd) {
                    const fadeProgress = (animProgress - shadowFadeOutStart) / (shadowFadeOutEnd - shadowFadeOutStart);
                    shadowBrightness = shadowTargetBrightness - ((fadeProgress * fadeProgress) * shadowTargetBrightness);
                }
                
                originalMoonMaterial.uniforms.uShadowBrightness.value = shadowBrightness;
                originalMoonMaterial.uniforms.uRedOverlayIntensity.value = redIntensity;
            }
            
            moon.getWorldPosition(tempVec);
            if (moon.material.uniforms) {
                originalMoonMaterial.uniforms.uObjectWorldPosition.value.copy(tempVec);
                earth.getWorldPosition(tempVec); 
                originalMoonMaterial.uniforms.uEarthPosition.value.copy(tempVec);
            }
        }

        function updateCamera(isJump = false) {
            let targetObj;
            let currentTargetPos = new THREE.Vector3();

            if (cameraFocus === 'earthView') {
                earth.getWorldPosition(currentTargetPos); 
                
                if (isJump) {
                    lastCameraTargetPos.copy(currentTargetPos);
                } else if (isPlaying) { 
                    const delta = currentTargetPos.clone().sub(lastCameraTargetPos);
                    camera.position.add(delta);
                }
                lastCameraTargetPos.copy(currentTargetPos);
                
                let moonPos = new THREE.Vector3();
                moon.getWorldPosition(moonPos);
                controls.target.copy(moonPos);
                return;
            }

            if (cameraFocus === 'ecliptic_side_view') {
                targetObj = earth;
                
                targetObj.getWorldPosition(currentTargetPos);

                if (isJump) {
                    lastCameraTargetPos.copy(currentTargetPos);
                } else if (isPlaying || isDemoActive) { 
                    let offset = currentTargetPos.clone().normalize().multiplyScalar(40);
                    let sideOffset = new THREE.Vector3(-currentTargetPos.z, 0, currentTargetPos.x).normalize().multiplyScalar(4); 
                    
                    camera.position.copy(currentTargetPos).add(offset).add(sideOffset); 
                    camera.position.y = 0;
                }
                lastCameraTargetPos.copy(currentTargetPos);
                
                controls.target.set(0, 0, 0);
                return;
            }
            
            targetObj = cameraFocus; 
            
            if (!targetObj || typeof targetObj === 'string') {
                targetObj = sun;
                cameraFocus = sun;
            }
            
            targetObj.getWorldPosition(currentTargetPos);

            if (isJump) {
                lastCameraTargetPos.copy(currentTargetPos);
            }
            else if (isPlaying || isDemoActive) {
                const delta = currentTargetPos.clone().sub(lastCameraTargetPos);
                camera.position.add(delta);
                controls.target.add(delta);
            }
            
            lastCameraTargetPos.copy(currentTargetPos);
        }
        
        function updateUI() {
            dayLabel.textContent = Math.floor(currentDay % EARTH_YEAR_DAYS);
            
            let sunPos = new THREE.Vector3();
            let earthPos = new THREE.Vector3();
            let moonPos = new THREE.Vector3();
            
            sun.getWorldPosition(sunPos);
            earth.getWorldPosition(earthPos);
            moon.getWorldPosition(moonPos);

            const vecEarthToMoon = new THREE.Vector3().subVectors(moonPos, earthPos);
            const vecEarthToSun = new THREE.Vector3().subVectors(sunPos, earthPos); 
            
            let angle = Math.atan2(vecEarthToSun.z, vecEarthToSun.x) - Math.atan2(vecEarthToMoon.z, vecEarthToMoon.x);
            angle = (angle + Math.PI * 2) % (Math.PI * 2);
            
            let phaseIndex = 0;
            let normalizedAngle = angle;
            
            phaseIndex = Math.floor(normalizedAngle / (Math.PI * 2) * 8 + 0.5) % 8;
            
            const phaseNames = ["Neumond", "Zun. Sichel", "Zun. Halbmond", "Zun. Drittel", "Vollmond", "Abn. Drittel", "Abn. Halbmond", "Abn. Sichel"];
            let phaseName = phaseNames[phaseIndex];

            let infoText = `Tag: ${Math.floor(currentDay % EARTH_YEAR_DAYS)} | ${phaseName}`;
            
            // Finsternis-Logik (PrÃ¼fung)
            if (isDemoActive) {
                if (demoType === 'sofi') {
                    infoText = "SONNENFINSTERNIS (Demo)";
                } else if (demoType === 'mofi') {
                    infoText = "MONDFINSTERNIS (Demo)";
                }
            } else {
                let moonWorldY = moon.getWorldPosition(new THREE.Vector3()).y;
                let earthWorldY = earth.getWorldPosition(new THREE.Vector3()).y; 
                
                let yDiff = Math.abs(moonWorldY - earthWorldY);
                
                const ECLIPSE_TOLERANCE = (MOON_RADIUS + EARTH_RADIUS) / 3; 

                if (phaseIndex === 0 && yDiff < ECLIPSE_TOLERANCE) { 
                    infoText += " (MÃ¶gliche SoFi)";
                }
                if (phaseIndex === 4 && yDiff < ECLIPSE_TOLERANCE) { 
                     infoText += " (MÃ¶gliche MoFi)";
                }
            }
            infoBox.textContent = infoText;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start ---
        init();
    </script>
</body>
</html>
